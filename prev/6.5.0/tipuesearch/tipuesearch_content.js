var tipuesearch = {"pages":[{"text":"JSON-Fortran Brief description License Official Releases Miscellaneous Brief description A user-friendly, thread-safe, and object-oriented API for reading and writing JSON files, written in modern Fortran. License The JSON -Fortran source code and related files and documentation are\ndistributed under a permissive free software license (BSD-style).  See\nthe LICENSE file for more details. Official Releases The current stable release is 6.5.0 and can be downloaded\non GitHub or installed with Homebrew on Mac OSX. The\ndocumentation for the current version, 6.5.0 , can be\nfound here 1 , and a\nlist of changes from the previous version are here . A list of all past releases, links to their documentation, and the\nchange log can be found on the releases page . Miscellaneous For more information about JSON , see: http://www.json.org/ Documentation for a particular release does not contain links\nback to general documentation; use the browser's back button to\nnavigate back to http://jacobwilliams.github.io/json-fortran/ ↩ Developer Info Jacob Williams","title":" JSON-Fortran ","tags":"","loc":"index.html"},{"text":"This File Depends On sourcefile~~json_file_module.f90~~EfferentGraph sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_kinds.f90 json_kinds.F90 sourcefile~json_kinds.f90->sourcefile~json_file_module.f90 sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_kinds.f90->sourcefile~json_value_module.f90 sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_kinds.f90->sourcefile~json_parameters.f90 sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_kinds.f90->sourcefile~json_string_utilities.f90 sourcefile~json_value_module.f90->sourcefile~json_file_module.f90 sourcefile~json_parameters.f90->sourcefile~json_file_module.f90 sourcefile~json_parameters.f90->sourcefile~json_value_module.f90 sourcefile~json_parameters.f90->sourcefile~json_string_utilities.f90 sourcefile~json_string_utilities.f90->sourcefile~json_file_module.f90 sourcefile~json_string_utilities.f90->sourcefile~json_value_module.f90 var pansourcefilejson_file_modulef90EfferentGraph = svgPanZoom('#sourcefilejson_file_modulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~json_file_module.f90~~AfferentGraph sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_module.f90 json_module.F90 sourcefile~json_file_module.f90->sourcefile~json_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules json_file_module Source Code json_file_module.F90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Higher-level [[json_file]] interface for the [[json_value]] type. ! !### License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_file_module use , intrinsic :: iso_fortran_env use json_kinds use json_parameters , only : unit2str use json_string_utilities use json_value_module implicit none private #include \"json_macros.inc\" !********************************************************* !> author: Jacob Williams !  date: 12/9/2013 ! !  The `json_file` is the main public class that is !  used to open a file and get data from it. ! !  A `json_file` contains only two items: an instance of a [[json_core(type)]], !  which use used for all data manipulation, and a [[json_value]], !  which is used to construct the linked-list data structure. !  Note that most methods in the `json_file` class are simply wrappers !  to the lower-level routines in the [[json_value_module]]. ! !### Example ! !```fortran !    program test !    use json_module !    implicit none !    type(json_file) :: json !    integer :: ival !    real(real64) :: rval !    character(len=:),allocatable :: cval !    logical :: found !    call json%initialize(compact_reals=.true.) !    call json%load_file(filename='myfile.json') !    call json%print_file() !print to the console !    call json%get('var.i',ival,found) !    call json%get('var.r(3)',rval,found) !    call json%get('var.c',cval,found) !    call json%destroy() !    end program test !``` type , public :: json_file private type ( json_core ) :: core !! The instance of the [[json_core(type)]] factory used for this file. type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains generic , public :: initialize => initialize_json_core_in_file ,& set_json_core_in_file procedure , public :: get_core => get_json_core_in_file procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) generic , public :: matrix_info => MAYBEWRAP ( json_file_variable_matrix_info ) !error checking: procedure , public :: failed => json_file_failed procedure , public :: print_error_message => json_file_print_error_message procedure , public :: check_for_errors => json_file_check_for_errors procedure , public :: clear_exceptions => json_file_clear_exceptions procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 !> !  Rename a variable, specifying it by path generic , public :: rename => MAYBEWRAP ( json_file_rename ) #ifdef USE_UCS4 generic , public :: rename => json_file_rename_path_ascii , & json_file_rename_name_ascii #endif !> !  Verify that a path is valid !  (i.e., a variable with this path exists in the file). generic , public :: valid_path => MAYBEWRAP ( json_file_valid_path ) !> !  Get a variable from a [[json_file(type)]], by specifying the path. generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & MAYBEWRAP ( json_file_get_alloc_string_vec ), & json_file_get_root !> !  Add a variable to a [[json_file(type)]], by specifying the path. ! !### Example ! !```fortran !  program test !  use json_module, rk=>json_rk, ik=>json_ik !  implicit none !  type(json_file) :: f !  call f%initialize()  ! specify whatever init options you want. !  call f%add('inputs.t', 0.0_rk) !  call f%add('inputs.x', [1.0_rk,2.0_rk,3.0_rk]) !  call f%add('inputs.flag', .true.) !  call f%print_file() !  end program test !``` generic , public :: add => MAYBEWRAP ( json_file_add_object ), & MAYBEWRAP ( json_file_add_integer ), & MAYBEWRAP ( json_file_add_double ), & MAYBEWRAP ( json_file_add_logical ), & MAYBEWRAP ( json_file_add_string ), & MAYBEWRAP ( json_file_add_integer_vec ), & MAYBEWRAP ( json_file_add_double_vec ), & MAYBEWRAP ( json_file_add_logical_vec ), & MAYBEWRAP ( json_file_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_file_add_string_path_ascii , & json_file_add_string_value_ascii ,& json_file_add_string_vec_path_ascii ,& json_file_add_string_vec_vec_ascii #endif !> !  Update a scalar variable in a [[json_file(type)]], !  by specifying the path. ! !@note These have been mostly supplanted by the `add` !      methods, which do a similar thing (and can be used for !      scalars and vectors, etc.) generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #endif !traverse procedure , public :: traverse => json_file_traverse ! *************************************************** ! operators ! *************************************************** generic , public :: operator (. in .) => MAYBEWRAP ( json_file_valid_path_op ) procedure , pass ( me ) :: MAYBEWRAP ( json_file_valid_path_op ) ! *************************************************** ! private routines ! *************************************************** !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !initialize procedure :: initialize_json_core_in_file procedure :: set_json_core_in_file !get info: procedure :: MAYBEWRAP ( json_file_variable_info ) procedure :: MAYBEWRAP ( json_file_variable_matrix_info ) !rename: procedure :: MAYBEWRAP ( json_file_rename ) #ifdef USE_UCS4 procedure :: json_file_rename_path_ascii procedure :: json_file_rename_name_ascii #endif !validate path: procedure :: MAYBEWRAP ( json_file_valid_path ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: MAYBEWRAP ( json_file_get_alloc_string_vec ) procedure :: json_file_get_root !add: procedure :: MAYBEWRAP ( json_file_add_object ) procedure :: MAYBEWRAP ( json_file_add_integer ) procedure :: MAYBEWRAP ( json_file_add_double ) procedure :: MAYBEWRAP ( json_file_add_logical ) procedure :: MAYBEWRAP ( json_file_add_string ) procedure :: MAYBEWRAP ( json_file_add_integer_vec ) procedure :: MAYBEWRAP ( json_file_add_double_vec ) procedure :: MAYBEWRAP ( json_file_add_logical_vec ) procedure :: MAYBEWRAP ( json_file_add_string_vec ) #ifdef USE_UCS4 procedure :: json_file_add_string_path_ascii procedure :: json_file_add_string_value_ascii procedure :: json_file_add_string_vec_path_ascii procedure :: json_file_add_string_vec_vec_ascii #endif !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file !********************************************************* !********************************************************* !> author: Izaak Beekman !  date: 07/23/2015 ! !  Structure constructor to initialize a [[json_file(type)]] object !  with an existing [[json_value]] object, and either the [[json_core(type)]] !  settings or a [[json_core(type)]] instance. ! !### Example ! !```fortran ! ... ! type(json_file)  :: my_file ! type(json_value),pointer :: json_object ! type(json_core) :: json_core_object ! ... ! ! Construct a json_object: ! !could do this: !   my_file = json_file(json_object) ! !or: !   my_file = json_file(json_object,verbose=.true.) ! !or: !   my_file = json_file(json_object,json_core_object) !``` interface json_file module procedure initialize_json_file , initialize_json_file_v2 end interface !************************************************************************************* contains !***************************************************************************************** !***************************************************************************************** !> !  Check error status in the file. pure function json_file_failed ( me ) result ( failed ) implicit none class ( json_file ), intent ( in ) :: me logical ( LK ) :: failed !! will be true if there has been an error. failed = me % core % failed () end function json_file_failed !***************************************************************************************** !***************************************************************************************** !> !  Retrieve error status and message from the class. subroutine json_file_check_for_errors ( me , status_ok , error_msg ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) call me % core % check_for_errors ( status_ok , error_msg ) end subroutine json_file_check_for_errors !***************************************************************************************** !***************************************************************************************** !> !  Clear exceptions in the class. pure subroutine json_file_clear_exceptions ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % clear_exceptions () end subroutine json_file_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> !  This is a wrapper for [[json_print_error_message]]. subroutine json_file_print_error_message ( me , io_unit ) implicit none class ( json_file ), intent ( inout ) :: me integer , intent ( in ), optional :: io_unit call me % core % print_error_message ( io_unit ) end subroutine json_file_print_error_message !***************************************************************************************** !***************************************************************************************** !> !  Initialize the [[json_core(type)]] for this [[json_file]]. !  This is just a wrapper for [[json_initialize]]. ! !@note: This does not destroy the data in the file. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. subroutine initialize_json_core_in_file ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) implicit none class ( json_file ), intent ( inout ) :: me #include \"json_initialize_arguments.inc\" call me % core % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) end subroutine initialize_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> !  Set the [[json_core(type)]] for this [[json_file]]. ! !@note: This does not destroy the data in the file. ! !@note: This one is used if you want to initialize the file with !       an already-existing [[json_core(type)]] (presumably, this was already !       initialized by a call to [[initialize_json_core]] or similar). subroutine set_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_core ), intent ( in ) :: core me % core = core end subroutine set_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> !  Get a copy of the [[json_core(type)]] in this [[json_file]]. subroutine get_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( in ) :: me type ( json_core ), intent ( out ) :: core core = me % core end subroutine get_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 07/23/2015 ! !  Cast a [[json_value]] object as a [[json_file(type)]] object. !  It also calls the `initialize()` method. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. function initialize_json_file ( p , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object #include \"json_initialize_arguments.inc\" call file_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) if ( present ( p )) file_object % p => p end function initialize_json_file !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Cast a [[json_value]] pointer and a [[json_core(type)]] object !  as a [[json_file(type)]] object. function initialize_json_file_v2 ( json_value_object , json_core_object ) & result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , intent ( in ) :: json_value_object type ( json_core ), intent ( in ) :: json_core_object file_object % p => json_value_object file_object % core = json_core_object end function initialize_json_file_v2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the [[json_value]] data in a [[json_file(type)]]. !  This must be done when the variable is no longer needed, !  or will be reused to open a different file. !  Otherwise a memory leak will occur. ! !  Optionally, also destroy the [[json_core(type)]] instance (this !  is not necessary to prevent memory leaks, since a [[json_core(type)]] !  does not use pointers). ! !### History !  * 12/9/2013 : Created !  * 4/26/2016 : Added optional `destroy_core` argument subroutine json_file_destroy ( me , destroy_core ) implicit none class ( json_file ), intent ( inout ) :: me logical , intent ( in ), optional :: destroy_core !! to also destroy the [[json_core(type)]]. !! default is to leave it as is. if ( associated ( me % p )) call me % core % destroy ( me % p ) if ( present ( destroy_core )) then if ( destroy_core ) call me % core % destroy () end if end subroutine json_file_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2014 ! !  Move the [[json_value]] pointer from one [[json_file(type)]] to another. !  The \"from\" pointer is then nullified, but not destroyed. ! !@note If \"from%p\" is not associated, then an error is thrown. subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then if ( from % failed ()) then !Don't get the data if the FROM file has an !active exception, since it may not be valid. call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'error exception in FROM file.' ) else call to % initialize () !initialize and clear any exceptions that may be present to % p => from % p nullify ( from % p ) end if else call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Load the JSON data from a file. ! !### Example ! !```fortran !     program main !      use json_module !      implicit none !      type(json_file) :: f !      call f%load_file('my_file.json') !      !... !      call f%destroy() !     end program main !``` subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use !! (if not present, a newunit !! is used) call me % core % parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/13/2015 ! !  Load the JSON data from a string. ! !### Example ! !  Load JSON from a string: !```fortran !     type(json_file) :: f !     call f%load_from_string('{ \"name\": \"Leonidas\" }') !``` subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call me % core % parse ( str = str , p = me % p ) end subroutine json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_load_from_string]], where \"str\" is kind=CDK. subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call me % load_from_string ( to_unicode ( str )) end subroutine wrap_json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to the console. subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % print ( me % p , iunit = output_unit ) end subroutine json_file_print_to_console !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Prints the JSON file to the specified file unit number. subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) if ( iunit /= unit2str ) then call me % core % print ( me % p , iunit = iunit ) else call me % core % throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON structure to the specified filename. !  The file is opened, printed, and then closed. ! !### Example !  Example loading a JSON file, changing a value, and then printing !  result to a new file: !```fortran !     type(json_file) :: f !     logical :: found !     call f%load_file('my_file.json')    !open the original file !     call f%update('version',4,found)    !change the value of a variable !     call f%print_file('my_file_2.json') !save file as new name !``` subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to call me % core % print ( me % p , filename ) end subroutine json_file_print_2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to a string. ! !### Example ! !  Open a JSON file, and then print the contents to a string: !```fortran !     type(json_file) :: f !     character(kind=CK,len=:),allocatable :: str !     call f%load_file('my_file.json') !     call f%print_file(str) !``` subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call me % core % print_to_string ( me % p , str ) end subroutine json_file_print_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Returns information about a variable in a [[json_file(type)]]. ! !@note If `found` is present, no exceptions will be thrown if an !      error occurs. Otherwise, an exception will be thrown if the !      variable is not found. subroutine json_file_variable_info ( me , path , found , var_type , n_children , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! the variable exists in the structure integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % core % info ( me % p , path , found , var_type , n_children , name ) end subroutine json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_variable_info]], where \"path\" is kind=CDK. ! !@note If `found` is present, no exceptions will be thrown if an !      error occurs. Otherwise, an exception will be thrown if the !      variable is not found. subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ), optional :: found integer ( IK ), intent ( out ), optional :: var_type integer ( IK ), intent ( out ), optional :: n_children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % info ( to_unicode ( path ), found , var_type , n_children , name ) end subroutine wrap_json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/26/2016 ! !  Returns matrix information about a variable in a [[json_file(type)]]. ! !@note If `found` is present, no exceptions will be thrown if an !      error occurs. Otherwise, an exception will be thrown if the !      variable is not found. subroutine json_file_variable_matrix_info ( me , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % core % matrix_info ( me % p , path , is_matrix , found , var_type , n_sets , set_size , name ) end subroutine json_file_variable_matrix_info !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_variable_matrix_info]], where \"path\" is kind=CDK. ! !@note If `found` is present, no exceptions will be thrown if an !      error occurs. Otherwise, an exception will be thrown if the !      variable is not found. subroutine wrap_json_file_variable_matrix_info ( me , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % matrix_info ( to_unicode ( path ), is_matrix , found , var_type , n_sets , set_size , name ) end subroutine wrap_json_file_variable_matrix_info !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 7/23/2015 ! !  Get a [[json_value]] pointer to the JSON file root. ! !@note This is equivalent to calling ```[[json_file]]%get('$',p)``` subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  A wrapper for [[json_file_valid_path]] for the `.in.` operator function json_file_valid_path_op ( path , me ) result ( found ) implicit none character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable class ( json_file ), intent ( in ) :: me !! the JSON file logical ( LK ) :: found !! if the variable was found type ( json_core ) :: core_copy !! a copy of `core` from `me` ! This is sort of a hack. Since `me` has to have `intent(in)` ! for the operator to work, we need to make a copy of `me%core` ! so we can call the low level routine (since it needs it to ! be `intent(inout)`) because it's technically possible for this ! function to raise an exception. This normally should never ! happen here unless the JSON structure is malformed. core_copy = me % core ! copy the settings (need them to know ! how to interpret the path) found = core_copy % valid_path ( me % p , path ) ! call the low-level routine call core_copy % destroy () ! just in case (but not really necessary) end function json_file_valid_path_op !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_valid_path_op]], where \"path\" is kind=CDK. function wrap_json_file_valid_path_op ( path , me ) result ( found ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable class ( json_file ), intent ( in ) :: me !! the JSON file logical ( LK ) :: found !! if the variable was found found = to_unicode ( path ) . in . me end function wrap_json_file_valid_path_op !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns true if the `path` is present in the JSON file. function json_file_valid_path ( me , path ) result ( found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ) :: found !! if the variable was found found = me % core % valid_path ( me % p , path ) end function json_file_valid_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_valid_path]], where \"path\" is kind=CDK. function wrap_json_file_valid_path ( me , path ) result ( found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ) :: found !! if the variable was found found = me % valid_path ( to_unicode ( path )) end function wrap_json_file_valid_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rename a variable in a JSON file. subroutine json_file_rename ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % core % rename ( me % p , path , name , found ) end subroutine json_file_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_rename]], where \"path\" and \"name\" are kind=CDK. subroutine wrap_json_file_rename ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % json_file_rename ( to_unicode ( path ), to_unicode ( name ), found ) end subroutine wrap_json_file_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Wrapper for [[json_file_rename]] where \"path\" is kind=CDK). subroutine json_file_rename_path_ascii ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % json_file_rename ( to_unicode ( path ), name , found ) end subroutine json_file_rename_path_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Wrapper for [[json_file_rename]] where \"name\" is kind=CDK). subroutine json_file_rename_name_ascii ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % json_file_rename ( path , to_unicode ( name ), found ) end subroutine json_file_rename_name_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Get a [[json_value]] pointer to an object from a JSON file. subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_object]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get an integer value from a JSON file. subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get an integer vector from a JSON file. subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a real(RK) variable value from a JSON file. subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a real(RK) vector from a JSON file. subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a logical(LK) value from a JSON file. subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get a logical(LK) vector from a JSON file. subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a character string from a json file. !  The output val is an allocatable character string. subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), allocatable , intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), allocatable , intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a string vector from a JSON file. subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec !! value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec !! value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/17/2016 ! !  Get an (allocatable length) string vector from a JSON file. !  This is just a wrapper for [[json_get_alloc_string_vec_by_path]]. subroutine json_file_get_alloc_string_vec ( me , path , vec , ilen , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec !! value vector integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , ilen , found ) end subroutine json_file_get_alloc_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_alloc_string_vec]], where \"path\" is kind=CDK. !  This is just a wrapper for [[wrap_json_get_alloc_string_vec_by_path]]. subroutine wrap_json_file_get_alloc_string_vec ( me , path , vec , ilen , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec !! value vector integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , ilen , found ) end subroutine wrap_json_file_get_alloc_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a [[json_value]] pointer to an object to a JSON file. subroutine json_file_add_object ( me , path , p , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! pointer to the variable to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , p , found , was_created ) end subroutine json_file_add_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_object]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_object ( me , path , p , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! pointer to the variable to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_object ( to_unicode ( path ), p , found , was_created ) end subroutine wrap_json_file_add_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add an integer value to a JSON file. subroutine json_file_add_integer ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created ) end subroutine json_file_add_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_integer]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_integer ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_integer ( to_unicode ( path ), val , found , was_created ) end subroutine wrap_json_file_add_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add an integer vector to a JSON file. subroutine json_file_add_integer_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created ) end subroutine json_file_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_integer_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_integer_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_integer_vec ( to_unicode ( path ), vec , found , was_created ) end subroutine wrap_json_file_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a real(RK) variable value to a JSON file. subroutine json_file_add_double ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created ) end subroutine json_file_add_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_double]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_double ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_double ( to_unicode ( path ), val , found , was_created ) end subroutine wrap_json_file_add_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a real(RK) vector to a JSON file. subroutine json_file_add_double_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created ) end subroutine json_file_add_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_double_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_double_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_double_vec ( to_unicode ( path ), vec , found , was_created ) end subroutine wrap_json_file_add_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a logical(LK) value to a JSON file. subroutine json_file_add_logical ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created ) end subroutine json_file_add_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_logical]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_logical ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_logical ( to_unicode ( path ), val , found , was_created ) end subroutine wrap_json_file_add_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a logical(LK) vector to a JSON file. subroutine json_file_add_logical_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created ) end subroutine json_file_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_logical_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_add_logical_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_logical_vec ( to_unicode ( path ), vec , found , was_created ) end subroutine wrap_json_file_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a character string to a json file. subroutine json_file_add_string ( me , path , val , found , was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created , trim_str , adjustl_str ) end subroutine json_file_add_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_string]], where \"path\" and \"val\" are kind=CDK. subroutine wrap_json_file_add_string ( me , path , val , found , was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string ( to_unicode ( path ), to_unicode ( val ), found ,& was_created , trim_str , adjustl_str ) end subroutine wrap_json_file_add_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Wrapper for [[json_file_add_string]] where \"path\" is kind=CDK). subroutine json_file_add_string_path_ascii ( me , path , val , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % json_file_add_string ( to_unicode ( path ), val , found ,& was_created , trim_str , adjustl_str ) end subroutine json_file_add_string_path_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Wrapper for [[json_file_add_string]] where \"val\" is kind=CDK). subroutine json_file_add_string_value_ascii ( me , path , val , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % json_file_add_string ( path , to_unicode ( val ), found ,& was_created , trim_str , adjustl_str ) end subroutine json_file_add_string_value_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Add a string vector to a JSON file. subroutine json_file_add_string_vec ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created , ilen , trim_str , adjustl_str ) end subroutine json_file_add_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_string_vec]], where \"path\" and \"vec\" are kind=CDK. subroutine wrap_json_file_add_string_vec ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string_vec ( to_unicode ( path ), to_unicode ( vec ), found ,& was_created , ilen , trim_str , adjustl_str ) end subroutine wrap_json_file_add_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_string_vec]], where \"path\" is kind=CDK. subroutine json_file_add_string_vec_path_ascii ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string_vec ( to_unicode ( path ), vec , found ,& was_created , ilen , trim_str , adjustl_str ) end subroutine json_file_add_string_vec_path_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Alternate version of [[json_file_add_string_vec]], where \"vec\" is kind=CDK. subroutine json_file_add_string_vec_vec_ascii ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string_vec ( path , to_unicode ( vec ), found ,& was_created , ilen , trim_str , adjustl_str ) end subroutine json_file_add_string_vec_vec_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !### See also !  * [[json_update_integer]] subroutine json_file_update_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found ) end subroutine json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_integer]], where \"path\" is kind=CDK. subroutine wrap_json_file_update_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !### See also !  * [[json_update_logical]] subroutine json_file_update_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found ) end subroutine json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_logical]], where \"path\" is kind=CDK. subroutine wrap_json_file_update_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !### See also !  * [[json_update_double]] subroutine json_file_update_real ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found ) end subroutine json_file_update_real !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_real]], where \"path\" is kind=CDK. subroutine wrap_json_file_update_real ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_update_real !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !### See also !  * [[json_update_string]] subroutine json_file_update_string ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found , trim_str , adjustl_str ) end subroutine json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"path\" and \"val\" are kind=CDK. subroutine wrap_json_file_update_string ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % update ( to_unicode ( path ), to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine wrap_json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"path\" is kind=CDK. subroutine json_file_update_string_name_ascii ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % update ( to_unicode ( path ), val , found , trim_str , adjustl_str ) end subroutine json_file_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"val\" is kind=CDK. subroutine json_file_update_string_val_ascii ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % update ( path , to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine json_file_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/11/2016 ! !  Traverse the JSON structure in the file. !  This routine calls the user-specified [[json_traverse_callback_func]] !  for each element of the structure. subroutine json_file_traverse ( me , traverse_callback ) implicit none class ( json_file ), intent ( inout ) :: me procedure ( json_traverse_callback_func ) :: traverse_callback call me % core % traverse ( me % p , traverse_callback ) end subroutine json_file_traverse !***************************************************************************************** !***************************************************************************************** end module json_file_module !*****************************************************************************************","title":"json_file_module.F90 – JSON-Fortran","tags":"","loc":"sourcefile/json_file_module.f90.html"},{"text":"Files Dependent On This One sourcefile~~json_kinds.f90~~AfferentGraph sourcefile~json_kinds.f90 json_kinds.F90 sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_kinds.f90->sourcefile~json_value_module.f90 sourcefile~json_module.f90 json_module.F90 sourcefile~json_kinds.f90->sourcefile~json_module.f90 sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_kinds.f90->sourcefile~json_file_module.f90 sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_kinds.f90->sourcefile~json_parameters.f90 sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_kinds.f90->sourcefile~json_string_utilities.f90 sourcefile~json_value_module.f90->sourcefile~json_module.f90 sourcefile~json_value_module.f90->sourcefile~json_file_module.f90 sourcefile~json_file_module.f90->sourcefile~json_module.f90 sourcefile~json_parameters.f90->sourcefile~json_value_module.f90 sourcefile~json_parameters.f90->sourcefile~json_module.f90 sourcefile~json_parameters.f90->sourcefile~json_file_module.f90 sourcefile~json_parameters.f90->sourcefile~json_string_utilities.f90 sourcefile~json_string_utilities.f90->sourcefile~json_value_module.f90 sourcefile~json_string_utilities.f90->sourcefile~json_file_module.f90 var pansourcefilejson_kindsf90AfferentGraph = svgPanZoom('#sourcefilejson_kindsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules json_kinds Source Code json_kinds.F90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  JSON-Fortran kind definitions. ! !### License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. ! !@note ```-DUSE_UCS4``` is an optional preprocessor flag. !      When present, Unicode support is enabled. Note that this !      is currently only supported with the gfortran compiler. !      Example: ```gfortran -DUSE_UCS4 ... ``` #ifdef USE_UCS4 #  pragma push_macro(\"USE_UCS4\") #  undef USE_UCS4 !      The documentation given here assumes ```USE_UCS4``` **is** defined. #  pragma pop_macro(\"USE_UCS4\") #else !      The documentation given here assumes ```USE_UCS4``` **is not** defined. #endif ! !@warning ```CK``` and ```CDK``` are the JSON-Fortran character kind and JSON-Fortran default !         character kind respectively. Client code **MUST** ensure characters of ```kind=CK``` !         are used for all character variables and strings passed to the JSON-Fortran !         library *EXCEPT* for file names which must be of ```'DEFAULT'``` character kind, !         provided here as ```CDK```. In particular, any variable that is a: json path, string !         value or object name passed to the JSON-Fortran library **MUST** be of type ```CK```. ! !@note Most string literal constants of default kind are fine to pass as arguments to !      JSON-Fortran procedures since they have been overloaded to accept ```intent(in)``` !      character arguments of the default (```CDK```) kind. If you find a procedure which does !      not accept an ```intent(in)``` literal string argument of default kind, please !      [file an issue](https://github.com/jacobwilliams/json-fortran/issues/new) on GitHub. ! !@note The default real kind (`RK`) and the default integer kind (`IK`) can be !      changed using optional preprocessor flags. This library was built with kinds: #ifdef REAL32 !      real(kind=real32) [4 bytes] #elif REAL64 !      real(kind=real64) [8 bytes] #elif REAL128 !      real(kind=real128) [16 bytes] #else !      real(kind=real64) [8 bytes] #endif !      and #ifdef INT8 !      integer(kind=int8) [1 byte] #elif INT16 !      integer(kind=int16) [2 bytes] #elif INT32 !      integer(kind=int32) [4 bytes] #elif INT64 !      integer(kind=int64) [8 bytes] #else !      integer(kind=int32) [4 bytes] #endif !      . module json_kinds use , intrinsic :: iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: RK = real32 !! Default real kind [4 bytes] #elif REAL64 integer , parameter , public :: RK = real64 !! Default real kind [8 bytes] #elif REAL128 integer , parameter , public :: RK = real128 !! Default real kind [16 bytes] #else integer , parameter , public :: RK = real64 !! Default real kind if not specified [8 bytes] #endif #ifdef INT8 integer , parameter , public :: IK = int8 !! Default integer kind [1 byte] #elif INT16 integer , parameter , public :: IK = int16 !! Default integer kind [2 bytes] #elif INT32 integer , parameter , public :: IK = int32 !! Default integer kind [4 bytes] #elif INT64 integer , parameter , public :: IK = int64 !! Default integer kind [8 bytes] #else integer , parameter , public :: IK = int32 !! Default integer kind if not specified [4 bytes] #endif !********************************************************* !> !  Processor dependendant 'DEFAULT' character kind. !  This is 1 byte for the Intel and Gfortran compilers. integer , parameter , public :: CDK = selected_char_kind ( 'DEFAULT' ) !********************************************************* !********************************************************* !> !  Default logical kind. !  This is 4 bytes for the Intel and Gfortran compilers !  (and perhaps others). !  The declaration ensures a valid kind !  if the compiler doesn't have a logical_kinds(3). integer , parameter , public :: LK = logical_kinds ( min ( 3 , size ( logical_kinds ))) !********************************************************* !********************************************************* !> !  String kind preprocessor macro. #if defined __GFORTRAN__ && defined USE_UCS4 ! gfortran compiler AND UCS4 support requested: character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'ISO_10646' #else ! this is the string kind to use unless compiling with GFortran AND ! UCS4/ISO 10646 support is requested character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'DEFAULT' #endif !********************************************************* !********************************************************* !> !  Default character kind used by JSON-Fortran. !  If ISO 10646 (UCS4) support is available, use that, !  otherwise, gracefully fall back on 'DEFAULT' characters. !  Currently only gfortran >= 4.9.2 will correctly support !  UCS4 which is stored in 4 bytes. !  (and perhaps others). integer , parameter , public :: CK = selected_char_kind ( json_fortran_string_kind ) !********************************************************* end module json_kinds !*****************************************************************************************","title":"json_kinds.F90 – JSON-Fortran","tags":"","loc":"sourcefile/json_kinds.f90.html"},{"text":"This File Depends On sourcefile~~json_module.f90~~EfferentGraph sourcefile~json_module.f90 json_module.F90 sourcefile~json_kinds.f90 json_kinds.F90 sourcefile~json_kinds.f90->sourcefile~json_module.f90 sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_kinds.f90->sourcefile~json_value_module.f90 sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_kinds.f90->sourcefile~json_file_module.f90 sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_kinds.f90->sourcefile~json_parameters.f90 sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_kinds.f90->sourcefile~json_string_utilities.f90 sourcefile~json_value_module.f90->sourcefile~json_module.f90 sourcefile~json_value_module.f90->sourcefile~json_file_module.f90 sourcefile~json_file_module.f90->sourcefile~json_module.f90 sourcefile~json_parameters.f90->sourcefile~json_module.f90 sourcefile~json_parameters.f90->sourcefile~json_value_module.f90 sourcefile~json_parameters.f90->sourcefile~json_file_module.f90 sourcefile~json_parameters.f90->sourcefile~json_string_utilities.f90 sourcefile~json_string_utilities.f90->sourcefile~json_value_module.f90 sourcefile~json_string_utilities.f90->sourcefile~json_file_module.f90 var pansourcefilejson_modulef90EfferentGraph = svgPanZoom('#sourcefilejson_modulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules json_module Source Code json_module.F90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  A Fortran 2008 JSON (JavaScript Object Notation) API. ! !  This module provides access to [[json_value_module]] and !  [[json_file_module]]. For normal JSON-Fortran use, using this module !  is all that is necessary. ! !  Note that this module renames the kind definition variables from [[json_kinds]] !  from [`RK`, `IK`, `LK`, `CK`, and `CDK`] to [`json_RK`, `json_IK`, `json_LK`, !  `json_CK`, and `json_CDK`] so as to avoid namespace pollution with short !  variable names. ! #ifdef USE_UCS4 #pragma push_macro(\"USE_UCS4\") #undef USE_UCS4 !  Since ```USE_UCS4``` **is** defined, this module also exports the !  operators `==`, `/=`, and `//` from [[json_string_utilities]] for !  `CK` and `CDK` operations. #pragma pop_macro(\"USE_UCS4\") #endif ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. ! !## History !  * Joseph A. Levin : March 2012 : Original [FSON](https://github.com/josephalevin/fson) !    code [retrieved on 12/2/2013]. !  * Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code. !    The original F95 code was split into four files: !    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95. !    The new code has been extensively updated, refactored and combined into this !    one module (json_module.f90). !    Various Fortran 2003/2008 features are now used !    (e.g., allocatable strings, newunit, generic, class, and abstract interface). !  * Development continues at: [Github](http://github.com/jacobwilliams/json-fortran) ! !## See also !  * [json-fortran development site](http://github.com/jacobwilliams/json-fortran) !  * [json-fortran online documentation](http://jacobwilliams.github.io/json-fortran) !  * [JSON website](http://www.json.org/) !  * [JSON validator](http://jsonlint.com/) ! !@note Originally JSON-Fortran was entirely contained within this module. module json_module use json_kinds , only : json_RK => RK , & json_IK => IK , & json_LK => LK , & json_CK => CK , & json_CDK => CDK #ifdef USE_UCS4 use json_string_utilities , only : operator ( == ),& operator ( // ),& operator ( /= ) #endif use json_parameters , only : json_unknown ,& json_null , & json_object , & json_array , & json_logical ,& json_integer ,& json_double , & json_string use json_value_module use json_file_module implicit none public end module json_module !*****************************************************************************************","title":"json_module.F90 – JSON-Fortran","tags":"","loc":"sourcefile/json_module.f90.html"},{"text":"This File Depends On sourcefile~~json_parameters.f90~~EfferentGraph sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_kinds.f90 json_kinds.F90 sourcefile~json_kinds.f90->sourcefile~json_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~json_parameters.f90~~AfferentGraph sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_parameters.f90->sourcefile~json_value_module.f90 sourcefile~json_module.f90 json_module.F90 sourcefile~json_parameters.f90->sourcefile~json_module.f90 sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_parameters.f90->sourcefile~json_file_module.f90 sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_parameters.f90->sourcefile~json_string_utilities.f90 sourcefile~json_value_module.f90->sourcefile~json_module.f90 sourcefile~json_value_module.f90->sourcefile~json_file_module.f90 sourcefile~json_file_module.f90->sourcefile~json_module.f90 sourcefile~json_string_utilities.f90->sourcefile~json_value_module.f90 sourcefile~json_string_utilities.f90->sourcefile~json_file_module.f90 var pansourcefilejson_parametersf90AfferentGraph = svgPanZoom('#sourcefilejson_parametersf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules json_parameters Source Code json_parameters.F90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Other parameters used by JSON-Fortran. !  This is a low-level module not meant to be used by a JSON-Fortran user. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_parameters use json_kinds implicit none public character ( kind = CDK , len =* ), parameter :: json_ext = '.json' !! JSON file extension ! The types of JSON data. integer ( IK ), parameter :: json_unknown = 0 !! Unknown JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_null = 1 !! Null JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_object = 2 !! Object JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_array = 3 !! Array JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_logical = 4 !! Logical JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_integer = 5 !! Integer JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_double = 6 !! Double JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter :: json_string = 7 !! String JSON data type !special JSON characters character ( kind = CK , len =* ), parameter :: space = CK_ ' ' character ( kind = CK , len =* ), parameter :: start_object = CK_ '{' character ( kind = CK , len =* ), parameter :: end_object = CK_ '}' character ( kind = CK , len =* ), parameter :: start_array = CK_ '[' character ( kind = CK , len =* ), parameter :: end_array = CK_ ']' character ( kind = CK , len =* ), parameter :: delimiter = CK_ ',' character ( kind = CK , len =* ), parameter :: colon_char = CK_ ':' character ( kind = CK , len =* ), parameter :: start_array_alt = CK_ '(' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: end_array_alt = CK_ ')' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: root = CK_ '$' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: this = CK_ '@' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: dot = CK_ '.' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: tilde = CK_ '~' !! RFC 6901 escape character character ( kind = CK , len =* ), parameter :: percent = CK_ '%' !! Fortran path separator character ( kind = CK , len =* ), parameter :: single_quote = CK_ \"'\" !! for JSONPath bracket-notation character ( kind = CK , len =* ), parameter :: bspace = achar ( 8 , kind = CK ) character ( kind = CK , len =* ), parameter :: horizontal_tab = achar ( 9 , kind = CK ) character ( kind = CK , len =* ), parameter :: newline = achar ( 10 , kind = CK ) character ( kind = CK , len =* ), parameter :: formfeed = achar ( 12 , kind = CK ) character ( kind = CK , len =* ), parameter :: carriage_return = achar ( 13 , kind = CK ) character ( kind = CK , len =* ), parameter :: quotation_mark = achar ( 34 , kind = CK ) character ( kind = CK , len =* ), parameter :: slash = achar ( 47 , kind = CK ) character ( kind = CK , len =* ), parameter :: backslash = achar ( 92 , kind = CK ) character ( kind = CDK , len =* ), parameter :: default_real_fmt = '(ss,E27.17E4)' !! default real number format statement (for writing real values to strings and files). !! Note that this can be overridden by calling [[json_initialize]]. character ( kind = CK , len =* ), parameter :: star = CK_ '*' !! for invalid numbers and !! list-directed real output #if defined __GFORTRAN__ !not parameters due to gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) character ( kind = CK , len = 26 ), protected :: upper = CK_ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( kind = CK , len = 26 ), protected :: lower = CK_ 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters #else character ( kind = CK , len =* ), parameter :: upper = CK_ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( kind = CK , len =* ), parameter :: lower = CK_ 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters #endif #if defined __GFORTRAN__ !not parameters due to gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) character ( kind = CK , len = 4 ), protected :: null_str = CK_ 'null' !! JSON Null variable string character ( kind = CK , len = 4 ), protected :: true_str = CK_ 'true' !! JSON logical True string character ( kind = CK , len = 5 ), protected :: false_str = CK_ 'false' !! JSON logical False string #else character ( kind = CK , len =* ), parameter :: null_str = CK_ 'null' !! JSON Null variable string character ( kind = CK , len =* ), parameter :: true_str = CK_ 'true' !! JSON logical True string character ( kind = CK , len =* ), parameter :: false_str = CK_ 'false' !! JSON logical False string #endif integer , private :: i_ !! just a counter for `control_chars` array character ( kind = CK , len =* ), dimension ( 32 ), parameter :: control_chars = & [( achar ( i_ , kind = CK ), i_ = 1 , 31 ), achar ( 127 , kind = CK )] !! Control characters, possibly in unicode !find out the precision of the floating point number system !and set safety factors integer ( IK ), parameter :: rp_safety_factor = 1_IK integer ( IK ), parameter :: rp_addl_safety = 2_IK integer ( IK ), parameter :: real_precision = rp_safety_factor * precision ( 1.0_RK ) + & rp_addl_safety !Get the number of possible digits in the exponent when using decimal number system integer ( IK ), parameter :: maxexp = maxexponent ( 1.0_RK ) integer ( IK ), parameter :: minexp = minexponent ( 1.0_RK ) integer ( IK ), parameter :: real_exponent_digits = floor ( 1 + log10 ( & real ( max ( maxexp , abs ( maxexp )),& kind = RK ) ) ) integer ( IK ), parameter :: max_numeric_str_len = real_precision + real_exponent_digits + 6 !! 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character ( kind = CDK , len =* ), parameter :: int_fmt = '(ss,I0)' !! minimum width format for integers integer ( IK ), parameter :: max_integer_str_len = 256 !! maximum string length of an integer. !! This is totally arbitrary (any way !! to get the compiler to tell us this?) integer ( IK ), parameter :: chunk_size = 100_IK !! for allocatable strings: allocate chunks of this size integer ( IK ), parameter :: unit2str = - 1_IK !! unit number to cause stuff to be !! output to strings rather than files. !! See 9.5.6.12 in the F2003/08 standard integer ( IK ), parameter :: seq_chunk_size = 256_IK !! chunk size for reading sequential files integer ( IK ), parameter :: pushed_char_size = 10_IK !! size for `pushed_char` !! array in [[json_core(type)]] end module json_parameters !*****************************************************************************************","title":"json_parameters.F90 – JSON-Fortran","tags":"","loc":"sourcefile/json_parameters.f90.html"},{"text":"This File Depends On sourcefile~~json_string_utilities.f90~~EfferentGraph sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_kinds.f90 json_kinds.F90 sourcefile~json_kinds.f90->sourcefile~json_string_utilities.f90 sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_kinds.f90->sourcefile~json_parameters.f90 sourcefile~json_parameters.f90->sourcefile~json_string_utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~json_string_utilities.f90~~AfferentGraph sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_string_utilities.f90->sourcefile~json_value_module.f90 sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_string_utilities.f90->sourcefile~json_file_module.f90 sourcefile~json_value_module.f90->sourcefile~json_file_module.f90 sourcefile~json_module.f90 json_module.F90 sourcefile~json_value_module.f90->sourcefile~json_module.f90 sourcefile~json_file_module.f90->sourcefile~json_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules json_string_utilities Source Code json_string_utilities.F90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  JSON-Fortran support module for string manipulation. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_string_utilities use json_kinds use json_parameters implicit none private !****************************************************** !> !  Convert a 'DEFAULT' kind character input to !  'ISO_10646' kind and return it interface to_unicode module procedure to_uni , to_uni_vec end interface !****************************************************** #ifdef USE_UCS4 !****************************************************** !> ! Provide a means to convert to UCS4 while ! concatenating UCS4 and default strings interface operator ( // ) module procedure ucs4_join_default , default_join_ucs4 end interface public :: operator ( // ) !****************************************************** !****************************************************** !> ! Provide a string `==` operator that works ! with mixed kinds interface operator ( == ) module procedure ucs4_comp_default , default_comp_ucs4 end interface public :: operator ( == ) !****************************************************** !****************************************************** !> ! Provide a string `/=` operator that works ! with mixed kinds interface operator ( /= ) module procedure ucs4_neq_default , default_neq_ucs4 end interface public :: operator ( /= ) !****************************************************** #endif public :: integer_to_string public :: real_to_string public :: string_to_integer public :: string_to_real public :: valid_json_hex public :: to_unicode public :: escape_string public :: unescape_string public :: lowercase_string public :: replace_string public :: decode_rfc6901 public :: encode_rfc6901 contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert an integer to a string. pure subroutine integer_to_string ( ival , int_fmt , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CDK , len =* ), intent ( in ) :: int_fmt !! format for integers character ( kind = CK , len =* ), intent ( out ) :: str !! `ival` converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !> !  Convert a string into an integer. ! !# History !  * Jacob Williams : 12/10/2013 : Rewrote original `parse_integer` routine. !    Added error checking. !  * Modified by Izaak Beekman !  * Jacob Williams : 2/4/2017 : moved core logic to this routine. subroutine string_to_integer ( str , ival , status_ok ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! the string to conver to an integer integer ( IK ), intent ( out ) :: ival !! the integer value logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer ! error check: status_ok = ( ierr == 0 ) if (. not . status_ok ) ival = 0_IK end subroutine string_to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert a real value to a string. ! !### Modified !  * Izaak Beekman : 02/24/2015 : added the compact option. !  * Jacob Williams : 10/27/2015 : added the star option. subroutine real_to_string ( rval , real_fmt , compact_real , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CDK , len =* ), intent ( in ) :: real_fmt !! format for real numbers logical ( LK ), intent ( in ) :: compact_real !! compact the string so that it is !! displayed with fewer characters character ( kind = CK , len =* ), intent ( out ) :: str !! `rval` converted to a string. integer ( IK ) :: istat if ( real_fmt == star ) then write ( str , fmt =* , iostat = istat ) rval else write ( str , fmt = real_fmt , iostat = istat ) rval end if if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Convert a string into a `real(RK)`. ! !# History !  * Jacob Williams, 10/27/2015 : Now using `fmt=*`, rather than !    `fmt=real_fmt`, since it doesn't work for some unusual cases !    (e.g., when `str='1E-5'`). !  * Jacob Williams : 2/6/2017 : moved core logic to this routine. subroutine string_to_real ( str , rval , status_ok ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ), intent ( out ) :: rval logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors integer ( IK ) :: ierr !! read iostat error code read ( str , fmt =* , iostat = ierr ) rval status_ok = ( ierr == 0 ) if (. not . status_ok ) rval = 0.0_RK end subroutine string_to_real !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 02/24/2015 ! !  Compact a string representing a real number, so that !  the same value is displayed with fewer characters. ! !# See also !  * [[real_to_string]] subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand character ( kind = CK , len = len ( str )) :: expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start integer ( IK ) :: decimal_pos integer ( IK ) :: sig_trim integer ( IK ) :: exp_trim integer ( IK ) :: i !! counter str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2014 ! !  Add the escape characters to a string for adding to JSON. subroutine escape_string ( str_in , str_out , escape_solidus ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out logical ( LK ), intent ( in ) :: escape_solidus !! if the solidus (forward slash) !! is also to be escaped integer ( IK ) :: i !! counter integer ( IK ) :: ipos !! accumulated string size !! (so we can allocate it in chunks for !! greater runtime efficiency) character ( kind = CK , len = 1 ) :: c !! for reading `str_in` one character at a time. #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! workaround for bug in gfortran 6.1 #endif logical :: to_be_escaped !! if there are characters to be escaped character ( kind = CK , len =* ), parameter :: specials_no_slash = quotation_mark // & backslash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab character ( kind = CK , len =* ), parameter :: specials = specials_no_slash // slash !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( escape_solidus ) then to_be_escaped = scan ( str_in , specials ) > 0 else to_be_escaped = scan ( str_in , specials_no_slash ) > 0 end if if ( to_be_escaped ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( backslash ) !test for unicode sequence: '\\uXXXX' ![don't add an extra '\\' for those] if ( i + 5 <= len ( str_in )) then if ( str_in ( i + 1 : i + 1 ) == CK_ 'u' . and . & valid_json_hex ( str_in ( i + 2 : i + 5 ))) then str_out ( ipos : ipos ) = c ipos = ipos + 1 cycle end if end if str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( quotation_mark ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( slash ) if ( escape_solidus ) then str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 else str_out ( ipos : ipos ) = c ipos = ipos + 1 end if case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = CK_ '' else #if defined __GFORTRAN__ tmp = str_out ( 1 : ipos - 1 ) !workaround for bug in gfortran 6.1 str_out = tmp #else str_out = str_out ( 1 : ipos - 1 ) !original #endif end if end if else str_out = str_in end if end subroutine escape_string !***************************************************************************************** !***************************************************************************************** !> !  Remove the escape characters from a JSON string and return it. ! !  The escaped characters are denoted by the `\\` character: ! !  * `\\\"`        - quotation mark !  * `\\\\`        - reverse solidus !  * `\\/`        - solidus !  * `\\b`        - backspace !  * `\\f`        - formfeed !  * `\\n`        - newline (LF) !  * `\\r`        - carriage return (CR) !  * `\\t`        - horizontal tab !  * `\\uXXXX`    - 4 hexadecimal digits subroutine unescape_string ( str_in , str_out , error_message ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in !! string as stored in a [[json_value]] character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out !! decoded string character ( kind = CK , len = :), allocatable , intent ( out ) :: error_message !! will be allocated if there was an error integer :: i !! counter integer :: n !! length of str_in integer :: m !! length of str_out character ( kind = CK , len = 1 ) :: c !! for scanning each character in string #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! for GFortran bug workaround #endif if ( scan ( str_in , backslash ) > 0 ) then !there is at least one escape character, so process this string: n = len ( str_in ) str_out = repeat ( space , n ) !size the output string (will be trimmed later) m = 0 !counter in str_out i = 0 !counter in str_in do i = i + 1 if ( i > n ) exit ! finished c = str_in ( i : i ) ! get next character in the string if ( c == backslash ) then if ( i < n ) then i = i + 1 c = str_in ( i : i ) !character after the escape if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then select case ( c ) case ( quotation_mark , backslash , slash ) !use d as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select m = m + 1 str_out ( m : m ) = c else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just returning them as is ![not checking to see if it is a valid hex value] ! ! Example: !   123456 !   \\uXXXX if ( i + 4 <= n ) then m = m + 1 str_out ( m : m + 5 ) = str_in ( i - 1 : i + 4 ) i = i + 4 m = m + 5 else error_message = 'Error in unescape_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // str_in ( i - 1 :) if ( allocated ( str_out )) deallocate ( str_out ) return end if else !unknown escape character error_message = 'Error in unescape_string:' // & ' unknown escape sequence in string \"' // & trim ( str_in ) // '\" [' // backslash // c // ']' if ( allocated ( str_out )) deallocate ( str_out ) return end if else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] m = m + 1 str_out ( m : m ) = c end if else m = m + 1 str_out ( m : m ) = c end if end do !trim trailing space: #if defined __GFORTRAN__ ! workaround for Gfortran 6.1.0 bug tmp = str_out ( 1 : m ) str_out = tmp #else str_out = str_out ( 1 : m ) #endif else !there are no escape characters, so return as is: str_out = str_in end if end subroutine unescape_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:6/14/2014 ! !  Returns true if the string is a valid 4-digit hex string. ! !# Examples !```fortran !    valid_json_hex('0000')  !returns true !    valid_json_hex('ABC4')  !returns true !    valid_json_hex('AB')    !returns false (< 4 characters) !    valid_json_hex('WXYZ')  !returns false (invalid characters) !``` pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n !! length of `str` integer ( IK ) :: i !! counter !> an array of the valid hex characters character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert string to unicode (CDK to CK). pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert array of strings to unicode (CDK to CK). ! !@note JW: may be able to remove this by making [[to_uni]] PURE ELEMENTAL ? pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CK`//`CDK` operator. pure function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CDK`//`CK` operator. pure function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CK`==`CDK` operator. pure elemental function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CDK`==`CK` operator. pure elemental function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  `CK`/=`CDK` operator. pure elemental function ucs4_neq_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str /= to_unicode ( def_str ) ) end function ucs4_neq_default !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  `CDK`/=`CK` operator. pure elemental function default_neq_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) /= ucs4_str ) end function default_neq_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns lowercase version of the `CK` string. pure elemental function lowercase_string ( str ) result ( s_lower ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! input string character ( kind = CK , len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: j !! index of uppercase character s_lower = str do i = 1 , len_trim ( str ) j = index ( upper , s_lower ( i : i )) if ( j > 0 ) s_lower ( i : i ) = lower ( j : j ) end do end function lowercase_string !***************************************************************************************** !***************************************************************************************** !> !  Replace all occurrences of `s1` in `str` with `s2`. ! !  A case-sensitive match is used. ! !@note `str` must be allocated. pure subroutine replace_string ( str , s1 , s2 ) implicit none character ( kind = CK , len = :), allocatable , intent ( inout ) :: str character ( kind = CK , len =* ), intent ( in ) :: s1 character ( kind = CK , len =* ), intent ( in ) :: s2 character ( kind = CK , len = :), allocatable :: tmp !! temporary string for accumulating result integer ( IK ) :: i !! counter integer ( IK ) :: n !! for accumulating the string integer ( IK ) :: ilen !! length of `str` string integer ( IK ) :: ilen1 !! length of `s1` string if ( len ( str ) > 0 ) then tmp = CK_ '' ! initialize ilen1 = len ( s1 ) !     . ! '123ab789' do ilen = len ( str ) i = index ( str , s1 ) if ( i > 0 ) then if ( i > 1 ) tmp = tmp // str ( 1 : i - 1 ) tmp = tmp // s2 ! replace s1 with s2 in new string n = i + ilen1 ! start of remainder of str to keep if ( n <= ilen ) then str = str ( n : ilen ) else ! done exit end if else ! done: get remainder of string tmp = tmp // str exit end if end do str = tmp end if end subroutine replace_string !***************************************************************************************** !***************************************************************************************** !> !  Decode a string from the \"JSON Pointer\" RFC 6901 format. ! !  It replaces `~1` with `/` and `~0` with `~`. pure function decode_rfc6901 ( str ) result ( str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str character ( kind = CK , len = :), allocatable :: str_out str_out = str call replace_string ( str_out , tilde // CK_ '1' , slash ) call replace_string ( str_out , tilde // CK_ '0' , tilde ) end function decode_rfc6901 !***************************************************************************************** !***************************************************************************************** !> !  Encode a string into the \"JSON Pointer\" RFC 6901 format. ! !  It replaces `~` with `~0` and `/` with `~1`. pure function encode_rfc6901 ( str ) result ( str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str character ( kind = CK , len = :), allocatable :: str_out str_out = str call replace_string ( str_out , tilde , tilde // CK_ '0' ) call replace_string ( str_out , slash , tilde // CK_ '1' ) end function encode_rfc6901 !***************************************************************************************** end module json_string_utilities !*****************************************************************************************","title":"json_string_utilities.F90 – JSON-Fortran","tags":"","loc":"sourcefile/json_string_utilities.f90.html"},{"text":"This File Depends On sourcefile~~json_value_module.f90~~EfferentGraph sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_kinds.f90 json_kinds.F90 sourcefile~json_kinds.f90->sourcefile~json_value_module.f90 sourcefile~json_parameters.f90 json_parameters.F90 sourcefile~json_kinds.f90->sourcefile~json_parameters.f90 sourcefile~json_string_utilities.f90 json_string_utilities.F90 sourcefile~json_kinds.f90->sourcefile~json_string_utilities.f90 sourcefile~json_parameters.f90->sourcefile~json_value_module.f90 sourcefile~json_parameters.f90->sourcefile~json_string_utilities.f90 sourcefile~json_string_utilities.f90->sourcefile~json_value_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~json_value_module.f90~~AfferentGraph sourcefile~json_value_module.f90 json_value_module.F90 sourcefile~json_module.f90 json_module.F90 sourcefile~json_value_module.f90->sourcefile~json_module.f90 sourcefile~json_file_module.f90 json_file_module.F90 sourcefile~json_value_module.f90->sourcefile~json_file_module.f90 sourcefile~json_file_module.f90->sourcefile~json_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules json_value_module Source Code json_value_module.F90 Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  This module provides a low-level interface for manipulation of JSON data. !  The two public entities are [[json_value]], and [[json_core(type)]]. !  The [[json_file_module]] provides a higher-level interface to some !  of these routines. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_value_module use , intrinsic :: iso_fortran_env , only : iostat_end , error_unit , output_unit use json_kinds use json_parameters use json_string_utilities implicit none private #include \"json_macros.inc\" !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 logical , parameter :: use_unformatted_stream = . false . #else logical , parameter :: use_unformatted_stream = . true . #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: access_spec = 'SEQUENTIAL' #else character ( kind = CDK , len =* ), parameter :: access_spec = 'STREAM' #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: form_spec = 'FORMATTED' #else character ( kind = CDK , len =* ), parameter :: form_spec = 'UNFORMATTED' #endif !********************************************************* !********************************************************* !> !  Type used to construct the linked-list JSON structure. !  Normally, this should always be a pointer variable. !  This type should only be used by an instance of [[json_core(type)]]. ! !### Example ! !  The following test program: ! !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'')   !create the root !     call json%add(p,'year',1805)    !add some data !     call json%add(p,'value',1.0_RK) !add some data !     call json%print(p,'test.json')  !write it to a file !     call json%destroy(p)            !cleanup !    end program test !```` ! !  Produces the JSON file **test.json**: ! !````json !    { !      \"year\": 1805, !      \"value\": 0.1E+1 !    } !```` type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name (unescaped) real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable !! (unescaped) integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value !********************************************************* !********************************************************* !> !  To access the core routines for manipulation !  of [[json_value]] pointer variables. This class allows !  for thread safe use of the module. ! !### Usage !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json     !<--have to declare this !     type(json_value),pointer :: p !     call json%create_object(p,'')   !create the root !     call json%add(p,'year',1805)    !add some data !     call json%add(p,'value',1.0_RK) !add some data !     call json%print(p,'test.json')  !write it to a file !     call json%destroy(p)            !cleanup !    end program test !```` type , public :: json_core private integer ( IK ) :: spaces_per_tab = 2 !! number of spaces for indenting logical ( LK ) :: compact_real = . true . !! to use the \"compact\" form of real !! numbers for output character ( kind = CDK , len = :), allocatable :: real_fmt !! the format string to use !! for converting real numbers to strings. !! It can be set in [[json_initialize]], !! and used in [[json_value_print]] !! If not set, then `default_real_fmt` !! is used instead. logical ( LK ) :: is_verbose = . false . !! if true, all exceptions are !! immediately printed to console. logical ( LK ) :: stop_on_error = . false . !! if true, then the program is !! stopped immediately when an !! exception is raised. logical ( LK ) :: exception_thrown = . false . !! The error flag. Will be set to true !! when an error is thrown in the class. !! Many of the methods will check this !! and return immediately if it is true. character ( kind = CK , len = :), allocatable :: err_message !! the error message integer ( IK ) :: char_count = 0 !! character position in the current line integer ( IK ) :: line_count = 1 !! lines read counter integer ( IK ) :: pushed_index = 0 !! used when parsing lines in file character ( kind = CK , len = pushed_char_size ) :: pushed_char = CK_ '' !! used when parsing !! lines in file integer ( IK ) :: ipos = 1 !! for allocatable strings: next character to read logical ( LK ) :: strict_type_checking = . false . !! if true, then no type conversions are done !! in the `get` routines if the actual variable !! type is different from the return type (for !! example, integer to double). logical ( LK ) :: trailing_spaces_significant = . false . !! for name and path comparisons, if trailing !! space is to be considered significant. logical ( LK ) :: case_sensitive_keys = . true . !! if name and path comparisons !! are case sensitive. logical ( LK ) :: no_whitespace = . false . !! when printing a JSON string, don't include !! non-significant spaces or line breaks. !! If true, the entire structure will be !! printed on one line. logical ( LK ) :: unescaped_strings = . true . !! If false, then the escaped !! string is returned from [[json_get_string]] !! and similar routines. If true [default], !! then the string is returned unescaped. logical ( LK ) :: allow_comments = . true . !! if true, any comments will be ignored when !! parsing a file. The comment token is defined !! by the `comment_char` character variable. character ( kind = CK , len = 1 ) :: comment_char = CK_ '!' !! comment token when !! `allow_comments` is true. !! Examples: '`!`' or '`#`'. integer ( IK ) :: path_mode = 1_IK !! How the path strings are interpreted in the !! `get_by_path` routines: !! !! * 1 -- Default mode (see [[json_get_by_path_default]]) !! * 2 -- as RFC 6901 \"JSON Pointer\" paths !!   (see [[json_get_by_path_rfc6901]]) !! * 3 -- JSONPath \"bracket-notation\" !!   see [[json_get_by_path_jsonpath_bracket]]) character ( kind = CK , len = 1 ) :: path_separator = dot !! The `path` separator to use !! in the \"default\" mode for !! the paths in the various !! `get_by_path` routines. !! Note: if `path_mode/=1` !! then this is ignored. logical ( LK ) :: compress_vectors = . false . !! If true, then arrays of integers, !! nulls, doubles, & logicals are !! printed all on one line. !! [Note: `no_whitespace` will !! override this option if necessary] logical ( LK ) :: allow_duplicate_keys = . true . !! If False, then after parsing, if any !! duplicate keys are found, an error is !! thrown. A call to [[json_value_validate]] !! will also check for duplicates. If True !! [default] then no special checks are done logical ( LK ) :: escape_solidus = . false . !! If True then the solidus \"`/`\" is always escaped !! (\"`\\/`\") when serializing JSON. !! If False [default], then it is not escaped. !! Note that this option does not affect parsing !! (both escaped and unescaped versions are still !! valid in all cases). contains private !> !  Return a child of a [[json_value]] structure. generic , public :: get_child => json_value_get_child_by_index , & json_value_get_child ,& MAYBEWRAP ( json_value_get_child_by_name ) procedure , private :: json_value_get_child_by_index procedure , private :: MAYBEWRAP ( json_value_get_child_by_name ) procedure , private :: json_value_get_child !> !  Add objects to a linked list of [[json_value]]s. ! !@note It might make more sense to call this `add_child`. generic , public :: add => json_value_add_member , & MAYBEWRAP ( json_value_add_null ), & MAYBEWRAP ( json_value_add_integer ), & MAYBEWRAP ( json_value_add_integer_vec ), & MAYBEWRAP ( json_value_add_double ), & MAYBEWRAP ( json_value_add_double_vec ), & MAYBEWRAP ( json_value_add_logical ), & MAYBEWRAP ( json_value_add_logical_vec ), & MAYBEWRAP ( json_value_add_string ), & MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_value_add_string_name_ascii , & json_value_add_string_val_ascii , & json_value_add_string_vec_name_ascii , & json_value_add_string_vec_val_ascii #endif procedure , private :: json_value_add_member procedure , private :: MAYBEWRAP ( json_value_add_integer ) procedure , private :: MAYBEWRAP ( json_value_add_null ) procedure , private :: MAYBEWRAP ( json_value_add_integer_vec ) procedure , private :: MAYBEWRAP ( json_value_add_double ) procedure , private :: MAYBEWRAP ( json_value_add_double_vec ) procedure , private :: MAYBEWRAP ( json_value_add_logical ) procedure , private :: MAYBEWRAP ( json_value_add_logical_vec ) procedure , private :: MAYBEWRAP ( json_value_add_string ) procedure , private :: MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 procedure , private :: json_value_add_string_name_ascii procedure , private :: json_value_add_string_val_ascii procedure , private :: json_value_add_string_vec_name_ascii procedure , private :: json_value_add_string_vec_val_ascii #endif !> !  These are like the `add` methods, except if a variable with the !  same path is already present, then its value is simply updated. !  Note that currently, these only work for scalar variables. !  These routines can also change the variable's type (but an error will be !  thrown if the existing variable is not a scalar). ! !### See also !  * [[json_core(type):add_by_path]] - this one can be used to change !    arrays and objects to scalars if so desired. ! !@note Unlike some routines, the `found` output is not optional, !      so it doesn't present exceptions from being thrown. ! !@note These have been mostly supplanted by the [[json_core(type):add_by_path]] !      methods, which do a similar thing (and can be used for !      scalars and vectors, etc.) generic , public :: update => MAYBEWRAP ( json_update_logical ),& MAYBEWRAP ( json_update_double ),& MAYBEWRAP ( json_update_integer ),& MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 generic , public :: update => json_update_string_name_ascii ,& json_update_string_val_ascii #endif procedure , private :: MAYBEWRAP ( json_update_logical ) procedure , private :: MAYBEWRAP ( json_update_double ) procedure , private :: MAYBEWRAP ( json_update_integer ) procedure , private :: MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 procedure , private :: json_update_string_name_ascii procedure , private :: json_update_string_val_ascii #endif !> !  Add variables to a [[json_value]] linked list !  by specifying their paths. ! !### Example ! !````fortran !    use, intrinsic :: iso_fortran_env, only: output_unit, wp=>real64 !    use json_module !    type(json_core) :: json !    type(json_value) :: p !    call json%create_object(p,'root') ! create the root !    ! now add some variables using the paths: !    call json%add_by_path(p,'inputs.t',    0.0_wp  ) !    call json%add_by_path(p,'inputs.x(1)', 100.0_wp) !    call json%add_by_path(p,'inputs.x(2)', 200.0_wp) !    call json%print(p,output_unit)  ! now print to console !```` ! !### Notes !  * This uses [[json_create_by_path]] ! !### See also !  * The `json_core%update` methods. !  * [[json_create_by_path]] generic , public :: add_by_path => MAYBEWRAP ( json_add_member_by_path ),& MAYBEWRAP ( json_add_integer_by_path ),& MAYBEWRAP ( json_add_double_by_path ),& MAYBEWRAP ( json_add_logical_by_path ),& MAYBEWRAP ( json_add_string_by_path ),& MAYBEWRAP ( json_add_integer_vec_by_path ),& MAYBEWRAP ( json_add_double_vec_by_path ),& MAYBEWRAP ( json_add_logical_vec_by_path ),& MAYBEWRAP ( json_add_string_vec_by_path ) #ifdef USE_UCS4 generic , public :: add_by_path => json_add_string_by_path_value_ascii ,& json_add_string_by_path_path_ascii ,& json_add_string_vec_by_path_value_ascii ,& json_add_string_vec_by_path_path_ascii #endif procedure :: MAYBEWRAP ( json_add_member_by_path ) procedure :: MAYBEWRAP ( json_add_integer_by_path ) procedure :: MAYBEWRAP ( json_add_double_by_path ) procedure :: MAYBEWRAP ( json_add_logical_by_path ) procedure :: MAYBEWRAP ( json_add_string_by_path ) procedure :: MAYBEWRAP ( json_add_integer_vec_by_path ) procedure :: MAYBEWRAP ( json_add_double_vec_by_path ) procedure :: MAYBEWRAP ( json_add_logical_vec_by_path ) procedure :: MAYBEWRAP ( json_add_string_vec_by_path ) #ifdef USE_UCS4 procedure :: json_add_string_by_path_value_ascii procedure :: json_add_string_by_path_path_ascii procedure :: json_add_string_vec_by_path_value_ascii procedure :: json_add_string_vec_by_path_path_ascii #endif !> !  Create a [[json_value]] linked list using the !  path to the variables. Optionally return a !  pointer to the variable. ! !  (This will create a `null` variable) ! !### See also !  * [[json_core(type):add_by_path]] generic , public :: create => MAYBEWRAP ( json_create_by_path ) procedure :: MAYBEWRAP ( json_create_by_path ) !> !  Get data from a [[json_value]] linked list. ! !@note There are two versions (e.g. [[json_get_integer]] and [[json_get_integer_by_path]]). !      The first one gets the value from the [[json_value]] passed into the routine, !      while the second one gets the value from the [[json_value]] found by parsing the !      path.  The path version is split up into unicode and non-unicode versions. generic , public :: get => & MAYBEWRAP ( json_get_by_path ), & json_get_integer , MAYBEWRAP ( json_get_integer_by_path ), & json_get_integer_vec , MAYBEWRAP ( json_get_integer_vec_by_path ), & json_get_double , MAYBEWRAP ( json_get_double_by_path ), & json_get_double_vec , MAYBEWRAP ( json_get_double_vec_by_path ), & json_get_logical , MAYBEWRAP ( json_get_logical_by_path ), & json_get_logical_vec , MAYBEWRAP ( json_get_logical_vec_by_path ), & json_get_string , MAYBEWRAP ( json_get_string_by_path ), & json_get_string_vec , MAYBEWRAP ( json_get_string_vec_by_path ), & json_get_alloc_string_vec , MAYBEWRAP ( json_get_alloc_string_vec_by_path ),& json_get_array , MAYBEWRAP ( json_get_array_by_path ) procedure , private :: json_get_integer procedure , private :: json_get_integer_vec procedure , private :: json_get_double procedure , private :: json_get_double_vec procedure , private :: json_get_logical procedure , private :: json_get_logical_vec procedure , private :: json_get_string procedure , private :: json_get_string_vec procedure , private :: json_get_alloc_string_vec procedure , private :: json_get_array procedure , private :: MAYBEWRAP ( json_get_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_double_by_path ) procedure , private :: MAYBEWRAP ( json_get_double_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_logical_by_path ) procedure , private :: MAYBEWRAP ( json_get_logical_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_string_by_path ) procedure , private :: MAYBEWRAP ( json_get_string_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_array_by_path ) procedure , private :: MAYBEWRAP ( json_get_alloc_string_vec_by_path ) procedure , private :: json_get_by_path_default procedure , private :: json_get_by_path_rfc6901 procedure , private :: json_get_by_path_jsonpath_bracket procedure , public :: print_to_string => json_value_to_string !! Print the [[json_value]] !! structure to an allocatable !! string !> !  Print the [[json_value]] to a file. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value) :: p !    !... !    call json%print(p,'test.json')  !this is [[json_print_2]] !```` generic , public :: print => json_print_1 , json_print_2 procedure :: json_print_1 procedure :: json_print_2 !> !  Destructor routine for a [[json_value]] pointer. !  This must be called explicitly if it is no longer needed, !  before it goes out of scope.  Otherwise, a memory leak will result. ! !### Example ! !  Destroy the [[json_value]] pointer before the variable goes out of scope: !````fortran !     subroutine example1() !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%print(p) !     call json%destroy(p) !     end subroutine example1 !```` ! !  Note: it should NOT be called for a [[json_value]] pointer than has already been !  added to another [[json_value]] structure, since doing so may render the !  other structure invalid.  Consider the following example: !````fortran !     subroutine example2(p) !     type(json_core) :: json !     type(json_value),pointer,intent(out) :: p !     type(json_value),pointer :: q !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%create_object(q,'q') !     call json%add(q,'val',1) !     call json%add(p, q)  !add q to p structure !     ! do NOT call json%destroy(q) here, because q is !     ! now part of the output structure p.  p should be destroyed !     ! somewhere upstream by the caller of this routine. !     nullify(q) !OK, but not strictly necessary !     end subroutine example2 !```` generic , public :: destroy => json_value_destroy , destroy_json_core procedure :: json_value_destroy procedure :: destroy_json_core !> !  If the child variable is present, then remove it. generic , public :: remove_if_present => MAYBEWRAP ( json_value_remove_if_present ) procedure :: MAYBEWRAP ( json_value_remove_if_present ) !> !  Allocate a [[json_value]] pointer and make it a double variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_double(p,'value',1.0_RK) !```` generic , public :: create_double => MAYBEWRAP ( json_value_create_double ) procedure :: MAYBEWRAP ( json_value_create_double ) !> !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_array(p,'arrayname') !```` generic , public :: create_array => MAYBEWRAP ( json_value_create_array ) procedure :: MAYBEWRAP ( json_value_create_array ) !> !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. generic , public :: create_object => MAYBEWRAP ( json_value_create_object ) procedure :: MAYBEWRAP ( json_value_create_object ) !> !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_null(p,'value') !```` generic , public :: create_null => MAYBEWRAP ( json_value_create_null ) procedure :: MAYBEWRAP ( json_value_create_null ) !> !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_string(p,'value','foobar') !```` generic , public :: create_string => MAYBEWRAP ( json_value_create_string ) procedure :: MAYBEWRAP ( json_value_create_string ) !> !  Allocate a json_value pointer and make it an integer variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_integer(p,42,'value') !```` generic , public :: create_integer => MAYBEWRAP ( json_value_create_integer ) procedure :: MAYBEWRAP ( json_value_create_integer ) !> !  Allocate a json_value pointer and make it a logical variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_logical(p,'value',.true.) !```` generic , public :: create_logical => MAYBEWRAP ( json_value_create_logical ) procedure :: MAYBEWRAP ( json_value_create_logical ) !> !  Parse the JSON file and populate the [[json_value]] tree. generic , public :: parse => json_parse_file , MAYBEWRAP ( json_parse_string ) procedure :: json_parse_file procedure :: MAYBEWRAP ( json_parse_string ) !> !  Throw an exception. generic , public :: throw_exception => MAYBEWRAP ( json_throw_exception ) procedure :: MAYBEWRAP ( json_throw_exception ) !> !  Rename a [[json_value]] variable. generic , public :: rename => MAYBEWRAP ( json_value_rename ),& MAYBEWRAP ( json_rename_by_path ) procedure :: MAYBEWRAP ( json_value_rename ) procedure :: MAYBEWRAP ( json_rename_by_path ) #ifdef USE_UCS4 generic , public :: rename => json_rename_by_path_name_ascii ,& json_rename_by_path_path_ascii procedure :: json_rename_by_path_name_ascii procedure :: json_rename_by_path_path_ascii #endif !> !  get info about a [[json_value]] generic , public :: info => json_info , MAYBEWRAP ( json_info_by_path ) procedure :: json_info procedure :: MAYBEWRAP ( json_info_by_path ) !> !  get string info about a [[json_value]] generic , public :: string_info => json_string_info procedure :: json_string_info !> !  get matrix info about a [[json_value]] generic , public :: matrix_info => json_matrix_info , MAYBEWRAP ( json_matrix_info_by_path ) procedure :: json_matrix_info procedure :: MAYBEWRAP ( json_matrix_info_by_path ) !> !  insert a new element after an existing one, !  updating the JSON structure accordingly generic , public :: insert_after => json_value_insert_after , & json_value_insert_after_child_by_index procedure :: json_value_insert_after procedure :: json_value_insert_after_child_by_index !> !  get the path to a JSON variable in a structure: generic , public :: get_path => MAYBEWRAP ( json_get_path ) procedure :: MAYBEWRAP ( json_get_path ) !> !  verify if a path is valid !  (i.e., a variable with this path exists in the file). generic , public :: valid_path => MAYBEWRAP ( json_valid_path ) procedure :: MAYBEWRAP ( json_valid_path ) procedure , public :: remove => json_value_remove !! Remove a [[json_value]] from a !! linked-list structure. procedure , public :: replace => json_value_replace !! Replace a [[json_value]] in a !! linked-list structure. procedure , public :: reverse => json_value_reverse !! Reverse the order of the children !! of an array of object. procedure , public :: check_for_errors => json_check_for_errors !! check for error and get error message procedure , public :: clear_exceptions => json_clear_exceptions !! clear exceptions procedure , public :: count => json_count !! count the number of children procedure , public :: clone => json_clone !! clone a JSON structure (deep copy) procedure , public :: failed => json_failed !! check for error procedure , public :: get_parent => json_get_parent !! get pointer to json_value parent procedure , public :: get_next => json_get_next !! get pointer to json_value next procedure , public :: get_previous => json_get_previous !! get pointer to json_value previous procedure , public :: get_tail => json_get_tail !! get pointer to json_value tail procedure , public :: initialize => json_initialize !! to initialize some parsing parameters procedure , public :: traverse => json_traverse !! to traverse all elements of a JSON !! structure procedure , public :: print_error_message => json_print_error_message !! simply routine to print error !! messages procedure , public :: swap => json_value_swap !! Swap two [[json_value]] pointers !! in a structure (or two different !! structures). procedure , public :: is_child_of => json_value_is_child_of !! Check if a [[json_value]] is a !! descendant of another. procedure , public :: validate => json_value_validate !! Check that a [[json_value]] linked !! list is valid (i.e., is properly !! constructed). This may be useful !! if it has been constructed externally. procedure , public :: check_for_duplicate_keys & => json_check_all_for_duplicate_keys !! Check entire JSON structure !! for duplicate keys (recursively) procedure , public :: check_children_for_duplicate_keys & => json_check_children_for_duplicate_keys !! Check a `json_value` object's !! children for duplicate keys !other private routines: procedure :: name_equal procedure :: name_strings_equal procedure :: json_value_print procedure :: string_to_int procedure :: string_to_dble procedure :: parse_value procedure :: parse_number procedure :: parse_string procedure :: parse_for_chars procedure :: parse_object procedure :: parse_array procedure :: annotate_invalid_json procedure :: pop_char procedure :: push_char procedure :: get_current_line_from_file_stream procedure :: get_current_line_from_file_sequential procedure :: convert procedure :: to_string procedure :: to_logical procedure :: to_integer procedure :: to_double procedure :: to_null procedure :: to_object procedure :: to_array end type json_core !********************************************************* !********************************************************* !> !  Structure constructor to initialize a !  [[json_core(type)]] object ! !### Example ! !```fortran ! type(json_file)  :: json_core ! json_core = json_core() !``` interface json_core module procedure initialize_json_core end interface !********************************************************* !************************************************************************************* abstract interface subroutine json_array_callback_func ( json , element , i , count ) !! Array element callback function.  Used by [[json_get_array]] import :: json_value , json_core , IK implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array end subroutine json_array_callback_func subroutine json_traverse_callback_func ( json , p , finished ) !! Callback function used by [[json_traverse]] import :: json_value , json_core , LK implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished !! set true to stop traversing end subroutine json_traverse_callback_func end interface public :: json_array_callback_func public :: json_traverse_callback_func !************************************************************************************* contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/17/2016 ! !  Destructor for the [[json_core(type)]] type. subroutine destroy_json_core ( me ) implicit none class ( json_core ), intent ( out ) :: me end subroutine destroy_json_core !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Function constructor for a [[json_core(type)]]. !  This is just a wrapper for [[json_initialize]]. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. function initialize_json_core ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) result ( json_core_object ) implicit none type ( json_core ) :: json_core_object #include \"json_initialize_arguments.inc\" call json_core_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) end function initialize_json_core !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Initialize the [[json_core(type)]] instance. ! !  The routine may be called before any of the [[json_core(type)]] methods are used in !  order to specify certain parameters. If it is not called, then the defaults !  are used. This routine is also called internally by various routines. !  It can also be called to clear exceptions, or to reset some !  of the variables (note that only the arguments present are changed). ! !### Modified !  * Izaak Beekman : 02/24/2015 ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. subroutine json_initialize ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) implicit none class ( json_core ), intent ( inout ) :: me #include \"json_initialize_arguments.inc\" character ( kind = CDK , len = 10 ) :: w !! max string length character ( kind = CDK , len = 10 ) :: d !! real precision digits character ( kind = CDK , len = 10 ) :: e !! real exponent digits character ( kind = CDK , len = 2 ) :: sgn !! sign flag: `ss` or `sp` character ( kind = CDK , len = 2 ) :: rl_edit_desc !! `G`, `E`, `EN`, or `ES` integer ( IK ) :: istat !! `iostat` flag for !! write statements logical ( LK ) :: sgn_prnt !! print sign flag !reset exception to false: call me % clear_exceptions () !Just in case, clear these global variables also: me % pushed_index = 0 me % pushed_char = CK_ '' me % char_count = 0 me % line_count = 1 me % ipos = 1 #ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) #endif !various optional inputs: if ( present ( spaces_per_tab )) & me % spaces_per_tab = spaces_per_tab if ( present ( stop_on_error )) & me % stop_on_error = stop_on_error if ( present ( verbose )) & me % is_verbose = verbose if ( present ( strict_type_checking )) & me % strict_type_checking = strict_type_checking if ( present ( trailing_spaces_significant )) & me % trailing_spaces_significant = trailing_spaces_significant if ( present ( case_sensitive_keys )) & me % case_sensitive_keys = case_sensitive_keys if ( present ( no_whitespace )) & me % no_whitespace = no_whitespace if ( present ( unescape_strings )) & me % unescaped_strings = unescape_strings if ( present ( path_mode )) then if ( path_mode == 1_IK . or . path_mode == 2_IK . or . path_mode == 3_IK ) then me % path_mode = path_mode else me % path_mode = 1_IK ! just to have a valid value call me % throw_exception ( 'Invalid path_mode.' ) end if end if ! if we are allowing comments in the file: ! [an empty string disables comments] if ( present ( comment_char )) then me % allow_comments = comment_char /= CK_ '' me % comment_char = comment_char end if ! path separator: if ( present ( path_separator )) then me % path_separator = path_separator end if ! printing vectors in compressed form: if ( present ( compress_vectors )) then me % compress_vectors = compress_vectors end if ! checking for duplicate keys: if ( present ( allow_duplicate_keys )) then me % allow_duplicate_keys = allow_duplicate_keys end if ! if escaping the forward slash: if ( present ( escape_solidus )) then me % escape_solidus = escape_solidus end if !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( me % real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then !allow the special case where real format is '*': ! [this overrides the other options] if ( present ( real_format )) then if ( real_format == star ) then if ( present ( compact_reals )) then ! we will also allow for compact reals with ! '*' format, if both arguments are present. me % compact_real = compact_reals else me % compact_real = . false . end if me % real_fmt = star return end if end if if ( present ( compact_reals )) me % compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call me % throw_exception ( 'Invalid real format, \"' // & trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then me % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else me % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & '27.17E4)' !just use this one (should never happen) end if end if end subroutine json_initialize !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns true if `name` is equal to `p%name`, using the specified !  settings for case sensitivity and trailing whitespace. ! !### History !  * 4/30/2016 : original version !  * 8/25/2017 : now just a wrapper for [[name_strings_equal]] function name_equal ( json , p , name ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), intent ( in ) :: p !! the json object character ( kind = CK , len =* ), intent ( in ) :: name !! the name to check for logical ( LK ) :: is_equal !! true if the string are !! lexically equal if ( allocated ( p % name )) then ! call the low-level routines for the name strings: is_equal = json % name_strings_equal ( p % name , name ) else is_equal = name == CK_ '' ! check a blank name end if end function name_equal !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/25/2017 ! !  Returns true if the name strings `name1` is equal to `name2`, using !  the specified settings for case sensitivity and trailing whitespace. function name_strings_equal ( json , name1 , name2 ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: name1 !! the name to check character ( kind = CK , len =* ), intent ( in ) :: name2 !! the name to check logical ( LK ) :: is_equal !! true if the string are !! lexically equal !must be the same length if we are treating !trailing spaces as significant, so do a !quick test of this first: if ( json % trailing_spaces_significant ) then is_equal = len ( name1 ) == len ( name2 ) if (. not . is_equal ) return end if if ( json % case_sensitive_keys ) then is_equal = name1 == name2 else is_equal = lowercase_string ( name1 ) == lowercase_string ( name2 ) end if end function name_strings_equal !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Create a deep copy of a [[json_value]] linked-list structure. ! !### Example ! !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json !     type(json_value),pointer :: j1, j2 !     call json%parse('../files/inputs/test1.json',j1) !     call json%clone(j1,j2) !now have two independent copies !     call json%destroy(j1)  !destroys j1, but j2 remains !     call json%print(j2,'j2.json') !     call json%destroy(j2) !    end program test !```` subroutine json_clone ( json , from , to ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) !call the main function: ! [note: this is not part of json_core class] call json_value_clone_func ( from , to ) end subroutine json_clone !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Recursive deep copy function called by [[json_clone]]. ! !@note If new data is added to the [[json_value]] type, !      then this would need to be updated. recursive subroutine json_value_clone_func ( from , to , parent , previous , next , children , tail ) implicit none type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here (it !! must not already be associated) type ( json_value ), pointer , optional :: parent !! to%parent type ( json_value ), pointer , optional :: previous !! to%previous type ( json_value ), pointer , optional :: next !! to%next type ( json_value ), pointer , optional :: children !! to%children logical , optional :: tail !! if \"to\" is the tail of !! its parent's children nullify ( to ) if ( associated ( from )) then allocate ( to ) !copy over the data variables: ! [note: the allocate() statements don't work here for the !  deferred-length characters in gfortran-4.9] if ( allocated ( from % name )) to % name = from % name if ( allocated ( from % dbl_value )) allocate ( to % dbl_value , source = from % dbl_value ) if ( allocated ( from % log_value )) allocate ( to % log_value , source = from % log_value ) if ( allocated ( from % str_value )) to % str_value = from % str_value if ( allocated ( from % int_value )) allocate ( to % int_value , source = from % int_value ) to % var_type = from % var_type to % n_children = from % n_children !allocate and associate the pointers as necessary: if ( present ( parent )) to % parent => parent if ( present ( previous )) to % previous => previous if ( present ( next )) to % next => next if ( present ( children )) to % children => children if ( present ( tail )) then if ( tail ) to % parent % tail => to end if if ( associated ( from % next )) then allocate ( to % next ) call json_value_clone_func ( from % next ,& to % next ,& previous = to ,& parent = to % parent ,& tail = (. not . associated ( from % next % next ))) end if if ( associated ( from % children )) then allocate ( to % children ) call json_value_clone_func ( from % children ,& to % children ,& parent = to ,& tail = (. not . associated ( from % children % next ))) end if end if end subroutine json_value_clone_func !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the data within a [[json_value]], and reset type to `json_unknown`. subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/13/2014 ! !  Returns information about a [[json_value]]. subroutine json_info ( json , p , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json % count ( p ) if ( present ( name )) then if ( allocated ( p % name )) then name = p % name else name = CK_ '' end if end if end subroutine json_info !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/18/2016 ! !  Returns information about character strings returned from a [[json_value]]. subroutine json_string_info ( json , p , ilen , max_str_len , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), dimension (:), allocatable , intent ( out ), optional :: ilen !! if `p` is an array, this !! is the actual length !! of each character !! string in the array. !! if not an array, this !! is returned unallocated. integer ( IK ), intent ( out ), optional :: max_str_len !! The maximum length required to !! hold the string representation returned !! by a call to a `get` routine. If a scalar, !! this is just the length of the scalar. If !! a vector, this is the maximum length of !! any element. logical ( LK ), intent ( out ), optional :: found !! true if there were no errors. !! if not present, an error will !! throw an exception character ( kind = CK , len = :), allocatable :: cval !! for getting values as strings. logical ( LK ) :: initialized !! if the output array has been sized logical ( LK ) :: get_max_len !! if we are returning the `max_str_len` logical ( LK ) :: get_ilen !! if we are returning the `ilen` array integer ( IK ) :: var_type !! variable type get_max_len = present ( max_str_len ) get_ilen = present ( ilen ) if (. not . json % exception_thrown ) then if ( present ( found )) found = . true . initialized = . false . if ( get_max_len ) max_str_len = 0 select case ( p % var_type ) case ( json_array ) ! it's an array ! call routine for each element call json % get ( p , array_callback = get_string_lengths ) case default ! not an array if ( json % strict_type_checking ) then ! only allowing strings to be returned ! as strings, so we can check size directly call json % info ( p , var_type = var_type ) if ( var_type == json_string ) then if ( allocated ( p % str_value ) . and . get_max_len ) & max_str_len = len ( p % str_value ) else ! it isn't a string, so there is no length call json % throw_exception ( 'Error in json_string_info: ' // & 'When strict_type_checking is true ' // & 'the variable must be a character string.' ) end if else ! in this case, we have to get the value ! as a string to know what size it is. call json % get ( p , value = cval ) if (. not . json % exception_thrown ) then if ( allocated ( cval ) . and . get_max_len ) & max_str_len = len ( cval ) end if end if end select end if if ( json % exception_thrown ) then if ( present ( found )) then call json % clear_exceptions () found = . false . end if if ( get_max_len ) max_str_len = 0 if ( get_ilen ) then if ( allocated ( ilen )) deallocate ( ilen ) end if end if contains subroutine get_string_lengths ( json , element , i , count ) !! callback function to call for each element in the array. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval integer ( IK ) :: var_type if ( json % exception_thrown ) return if (. not . initialized ) then if ( get_ilen ) allocate ( ilen ( count )) initialized = . true . end if if ( json % strict_type_checking ) then ! only allowing strings to be returned ! as strings, so we can check size directly call json % info ( element , var_type = var_type ) if ( var_type == json_string ) then if ( allocated ( element % str_value )) then if ( get_max_len ) then if ( len ( element % str_value ) > max_str_len ) & max_str_len = len ( element % str_value ) end if if ( get_ilen ) ilen ( i ) = len ( element % str_value ) else if ( get_ilen ) ilen ( i ) = 0 end if else ! it isn't a string, so there is no length call json % throw_exception ( 'Error in json_string_info: ' // & 'When strict_type_checking is true ' // & 'the array must contain only ' // & 'character strings.' ) end if else ! in this case, we have to get the value ! as a string to know what size it is. call json % get ( element , value = cval ) if ( json % exception_thrown ) return if ( allocated ( cval )) then if ( get_max_len ) then if ( len ( cval ) > max_str_len ) max_str_len = len ( cval ) end if if ( get_ilen ) ilen ( i ) = len ( cval ) else if ( get_ilen ) ilen ( i ) = 0 end if end if end subroutine get_string_lengths end subroutine json_string_info !***************************************************************************************** !***************************************************************************************** ! !  Returns information about a [[json_value]], given the path. ! !### See also !  * [[json_info]] ! !@note If `found` is present, no exceptions will be thrown if an !      error occurs. Otherwise, an exception will be thrown if the !      variable is not found. subroutine json_info_by_path ( json , p , path , found , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name type ( json_value ), pointer :: p_var !! temporary pointer logical ( LK ) :: ok !! if the variable was found #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: p_name !! temporary variable for getting name #endif call json % get ( p , path , p_var , found ) !check if it was found: if ( present ( found )) then ok = found else ok = . not . json % exception_thrown end if if (. not . ok ) then if ( present ( var_type )) var_type = json_unknown if ( present ( n_children )) n_children = 0 if ( present ( name )) name = CK_ '' else !get info: #if defined __GFORTRAN__ call json % info ( p_var , var_type , n_children ) if ( present ( name )) then !workaround for gfortran bug if ( allocated ( p_var % name )) then p_name = p_var % name name = p_name else name = CK_ '' end if end if #else call json % info ( p_var , var_type , n_children , name ) #endif end if end subroutine json_info_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_info_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_info_by_path ( json , p , path , found , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call json % info ( p , to_unicode ( path ), found , var_type , n_children , name ) end subroutine wrap_json_info_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/16/2015 ! !  Alternate version of [[json_info]] that returns matrix !  information about a [[json_value]]. ! !  A [[json_value]] is a valid rank 2 matrix if all of the following are true: ! !  * The var_type is *json_array* !  * Each child is also a *json_array*, each of which has the same number of elements !  * Each individual element has the same variable type (integer, logical, etc.) ! !  The idea here is that if it is a valid matrix, it can be interoperable with !  a Fortran rank 2 array of the same type. ! !### Example ! !  The following example is an array with `var_type=json_integer`, !  `n_sets=3`, and `set_size=4` ! !```json !    { !        \"matrix\": [ !            [1,2,3,4], !            [5,6,7,8], !            [9,10,11,12] !        ] !    } !``` subroutine json_matrix_info ( json , p , is_matrix , var_type , n_sets , set_size , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON linked list logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in the matrix !! (if all elements have the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name type ( json_value ), pointer :: p_row !! for getting a set type ( json_value ), pointer :: p_element !! for getting an element in a set integer ( IK ) :: vartype !! json variable type of `p` integer ( IK ) :: row_vartype !! json variable type of a row integer ( IK ) :: element_vartype !! json variable type of an element in a row integer ( IK ) :: nr !! number of children of `p` integer ( IK ) :: nc !! number of elements in first child of `p` integer ( IK ) :: icount !! number of elements in a set integer :: i !! counter integer :: j !! counter #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: p_name !! temporary variable for getting name #endif !get info about the variable: #if defined __GFORTRAN__ call json % info ( p , vartype , nr ) if ( present ( name )) then !workaround for gfortran bug if ( allocated ( p % name )) then p_name = p % name name = p_name else name = CK_ '' end if end if #else call json % info ( p , vartype , nr , name ) #endif is_matrix = ( vartype == json_array ) if ( is_matrix ) then main : do i = 1 , nr nullify ( p_row ) call json % get_child ( p , i , p_row ) if (. not . associated ( p_row )) then is_matrix = . false . call json % throw_exception ( 'Error in json_matrix_info: ' // & 'Malformed JSON linked list' ) exit main end if call json % info ( p_row , var_type = row_vartype , n_children = icount ) if ( row_vartype == json_array ) then if ( i == 1 ) nc = icount !number of columns in first row if ( icount == nc ) then !make sure each row has the same number of columns !see if all the variables in this row are the same type: do j = 1 , icount nullify ( p_element ) call json % get_child ( p_row , j , p_element ) if (. not . associated ( p_element )) then is_matrix = . false . call json % throw_exception ( 'Error in json_matrix_info: ' // & 'Malformed JSON linked list' ) exit main end if call json % info ( p_element , var_type = element_vartype ) if ( i == 1 . and . j == 1 ) vartype = element_vartype !type of first element !in the row if ( vartype /= element_vartype ) then !not all variables are the same time is_matrix = . false . exit main end if end do else is_matrix = . false . exit main end if else is_matrix = . false . exit main end if end do main end if if ( is_matrix ) then if ( present ( var_type )) var_type = vartype if ( present ( n_sets )) n_sets = nr if ( present ( set_size )) set_size = nc else if ( present ( var_type )) var_type = json_unknown if ( present ( n_sets )) n_sets = 0 if ( present ( set_size )) set_size = 0 end if end subroutine json_matrix_info !***************************************************************************************** !***************************************************************************************** !> !  Returns matrix information about a [[json_value]], given the path. ! !### See also !  * [[json_matrix_info]] ! !@note If `found` is present, no exceptions will be thrown if an !      error occurs. Otherwise, an exception will be thrown if the !      variable is not found. subroutine json_matrix_info_by_path ( json , p , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name type ( json_value ), pointer :: p_var logical ( LK ) :: ok #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: p_name !! temporary variable for getting name #endif call json % get ( p , path , p_var , found ) !check if it was found: if ( present ( found )) then ok = found else ok = . not . json % exception_thrown end if if (. not . ok ) then if ( present ( var_type )) var_type = json_unknown if ( present ( n_sets )) n_sets = 0 if ( present ( set_size )) set_size = 0 if ( present ( name )) name = CK_ '' else !get info about the variable: #if defined __GFORTRAN__ call json % matrix_info ( p_var , is_matrix , var_type , n_sets , set_size ) if ( present ( name )) then !workaround for gfortran bug if ( allocated ( p_var % name )) then p_name = p_var % name name = p_name else name = CK_ '' end if end if #else call json % matrix_info ( p_var , is_matrix , var_type , n_sets , set_size , name ) #endif if ( json % exception_thrown . and . present ( found )) then found = . false . call json % clear_exceptions () end if end if end subroutine json_matrix_info_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_matrix_info_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_matrix_info_by_path ( json , p , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call json % matrix_info ( p , to_unicode ( path ), is_matrix , found , var_type , n_sets , set_size , name ) end subroutine wrap_json_matrix_info_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! !  Rename a [[json_value]]. subroutine json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! new variable name if ( json % trailing_spaces_significant ) then p % name = name else p % name = trim ( name ) end if end subroutine json_value_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! !  Alternate version of [[json_value_rename]], where `name` is kind=CDK. subroutine wrap_json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! new variable name call json % rename ( p , to_unicode ( name )) end subroutine wrap_json_value_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Clear exceptions in the [[json_core(type)]]. pure subroutine json_clear_exceptions ( json ) implicit none class ( json_core ), intent ( inout ) :: json !clear the flag and message: json % exception_thrown = . false . json % err_message = CK_ '' end subroutine json_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Throw an exception in the [[json_core(type)]]. !  This routine sets the error flag, and prevents any subsequent routine !  from doing anything, until [[json_clear_exceptions]] is called. ! !@note If `is_verbose` is true, this will also print a !      traceback if the Intel compiler is used. ! !@note If `stop_on_error` is true, then the program is stopped. subroutine json_throw_exception ( json , msg ) #ifdef __INTEL_COMPILER use ifcore , only : tracebackqq #endif implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: msg !! the error message json % exception_thrown = . true . json % err_message = trim ( msg ) if ( json % stop_on_error ) then #ifdef __INTEL_COMPILER ! for Intel, we raise a traceback and quit call tracebackqq ( string = trim ( msg ), user_exit_code = 0 ) #else write ( error_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) error stop 1 #endif elseif ( json % is_verbose ) then write ( output_unit , '(A)' ) '***********************' write ( output_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) !#if defined __GFORTRAN__ !        call backtrace()  ! (have to compile with -fbacktrace -fall-intrinsics flags) !#endif #ifdef __INTEL_COMPILER call tracebackqq ( user_exit_code =- 1 ) ! print a traceback and return #endif write ( output_unit , '(A)' ) '***********************' end if end subroutine json_throw_exception !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_throw_exception]], where `msg` is kind=CDK. subroutine wrap_json_throw_exception ( json , msg ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: msg !! the error message call json % throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Retrieve error code from the [[json_core(type)]]. !  This should be called after `parse` to check for errors. !  If an error is thrown, before using the class again, [[json_initialize]] !  should be called to clean up before it is used again. ! !### Example ! !````fortran !     type(json_file) :: json !     logical :: status_ok !     character(kind=CK,len=:),allocatable :: error_msg !     call json%load_file(filename='myfile.json') !     call json%check_for_errors(status_ok, error_msg) !     if (.not. status_ok) then !         write(*,*) 'Error: '//error_msg !         call json%clear_exceptions() !         call json%destroy() !     end if !```` ! !### See also !  * [[json_failed]] subroutine json_check_for_errors ( json , status_ok , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . json % exception_thrown if (. not . status_ok ) then if ( allocated ( json % err_message )) then error_msg = json % err_message else error_msg = 'Unknown error.' end if else error_msg = CK_ '' end if end subroutine json_check_for_errors !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2013 ! !  Logical function to indicate if an exception has been thrown in a [[json_core(type)]]. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call json%parse(filename='myfile.json',p) !    if (json%failed()) then !        call json%check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call json%clear_exceptions() !        call json%destroy(p) !    end if !```` ! !  Note that [[json_file]] contains a wrapper for this routine, which is used like: !````fortran !    type(json_file) :: f !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call f%load_file(filename='myfile.json') !    if (f%failed()) then !        call f%check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call f%clear_exceptions() !        call f%destroy() !    end if !```` ! !### See also !  * [[json_check_for_errors]] pure function json_failed ( json ) result ( failed ) implicit none class ( json_core ), intent ( in ) :: json logical ( LK ) :: failed !! will be true if an exception !! has been thrown. failed = json % exception_thrown end function json_failed !***************************************************************************************** !***************************************************************************************** !> !  Allocate a [[json_value]] pointer variable. !  This should be called before adding data to it. ! !### Example ! !````fortran !    type(json_value),pointer :: var !    call json_value_create(var) !    call json%to_double(var,1.0_RK) !```` ! !### Notes !  1. This routine does not check for exceptions. !  2. The pointer should not already be allocated, or a memory leak will occur. subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/22/2014 ! !  Destroy a [[json_value]] linked-list structure. ! !@note The original FSON version of this !      routine was not properly freeing the memory. !      It was rewritten. recursive subroutine json_value_destroy ( json , p , destroy_next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! variable to destroy logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then `p%next` !! is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: child if ( associated ( p )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( p % name )) deallocate ( p % name ) call destroy_json_data ( p ) if ( associated ( p % children )) then do while ( p % n_children > 0 ) child => p % children if ( associated ( child )) then p % children => p % children % next p % n_children = p % n_children - 1 call json % destroy ( child ,. false .) else call json % throw_exception ( 'Error in json_value_destroy: ' // & 'Malformed JSON linked list' ) exit end if end do nullify ( p % children ) nullify ( child ) end if if ( associated ( p % next ) . and . des_next ) call json % destroy ( p % next ) if ( associated ( p % previous )) nullify ( p % previous ) if ( associated ( p % parent )) nullify ( p % parent ) if ( associated ( p % tail )) nullify ( p % tail ) deallocate ( p ) nullify ( p ) end if end subroutine json_value_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/9/2014 ! !  Remove a [[json_value]] (and all its children) !  from a linked-list structure, preserving the rest of the structure. ! !### Examples ! !  To extract an object from one JSON structure, and add it to another: !````fortran !     type(json_core) :: json !     type(json_value),pointer :: json1,json2,p !     logical :: found !     !create and populate json1 and json2 !     call json%get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json%remove(p,destroy=.false.)  ! remove it from json1 (don't destroy) !     call json%add(json2,p)               ! add it to json2 !```` ! !  To remove an object from a JSON structure (and destroy it): !````fortran !     type(json_core) :: json !     type(json_value),pointer :: json1,p !     logical :: found !     !create and populate json1 !     call json%get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json%remove(p)                  ! remove and destroy it !```` ! !### History !  * Jacob Williams : 12/28/2014 : added destroy optional argument. subroutine json_value_remove ( json , p , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( p )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( p % parent )) then parent => p % parent if ( associated ( p % next )) then !there are later items in the list: next => p % next nullify ( p % next ) if ( associated ( p % previous )) then !there are earlier items in the list previous => p % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( p % previous )) then !there are earlier items in the list: previous => p % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json % destroy ( p ) end if end subroutine json_value_remove !***************************************************************************************** !***************************************************************************************** !> !  Replace `p1` with `p2` in a JSON structure. ! !@note The replacement is done using an insert and remove !      See [[json_value_insert_after]] and [[json_value_remove]] !      for details. subroutine json_value_replace ( json , p1 , p2 , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 !! the item to replace type ( json_value ), pointer :: p2 !! item to take the place of `p1` logical ( LK ), intent ( in ), optional :: destroy !! Should `p1` also be destroyed !! (default is True). Normally, !! this should be true to avoid !! a memory leak. logical ( LK ) :: destroy_p1 !! if `p1` is to be destroyed if ( present ( destroy )) then destroy_p1 = destroy else destroy_p1 = . true . ! default end if call json % insert_after ( p1 , p2 ) call json % remove ( p1 , destroy_p1 ) end subroutine json_value_replace !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/11/2017 ! !  Reverse the order of the children of an array or object. subroutine json_value_reverse ( json , p ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp !! temp variable for traversing the list type ( json_value ), pointer :: current !! temp variable for traversing the list integer ( IK ) :: var_type !! for getting the variable type if ( associated ( p )) then call json % info ( p , var_type = var_type ) ! can only reverse objects or arrays if ( var_type == json_object . or . var_type == json_array ) then nullify ( tmp ) current => p % children p % tail => current ! Swap next and previous for all nodes: do if (. not . associated ( current )) exit tmp => current % previous current % previous => current % next current % next => tmp current => current % previous end do if ( associated ( tmp )) then p % children => tmp % previous end if end if end if end subroutine json_value_reverse !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Swap two elements in a JSON structure. !  All of the children are carried along as well. ! !@note If both are not associated, then an error is thrown. ! !@note The assumption here is that both variables are part of a valid !      [[json_value]] linked list (so the normal `parent`, `previous`, !      `next`, etc. pointers are properly associated if necessary). ! !@warning This cannot be used to swap a parent/child pair, since that !         could lead to a circular linkage. An exception is thrown if !         this is tried. ! !@warning There are also other situations where using this routine may !         produce a malformed JSON structure, such as moving an array !         element outside of an array. This is not checked for. ! !@note If `p1` and `p2` have a common parent, it is always safe to swap them. subroutine json_value_swap ( json , p1 , p2 ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical :: same_parent , first_last , adjacent type ( json_value ), pointer :: a , b if ( json % exception_thrown ) return !both have to be associated: if ( associated ( p1 ) . and . associated ( p2 )) then !simple check to make sure that they both !aren't pointing to the same thing: if (. not . associated ( p1 , p2 )) then !we will not allow swapping an item with one of its descendants: if ( json % is_child_of ( p1 , p2 ) . or . json % is_child_of ( p2 , p1 )) then call json % throw_exception ( 'Error in json_value_swap: ' // & 'cannot swap an item with one of its descendants' ) else same_parent = ( associated ( p1 % parent ) . and . & associated ( p2 % parent ) . and . & associated ( p1 % parent , p2 % parent ) ) if ( same_parent ) then !if p1,p2 are the first,last or last,first !children of a common parent first_last = ( associated ( p1 % parent % children , p1 ) . and . & associated ( p2 % parent % tail , p2 )) . or . & ( associated ( p1 % parent % tail , p1 ) . and . & associated ( p2 % parent % children , p2 )) else first_last = . false . end if !first, we fix children,tail pointers: if ( same_parent . and . first_last ) then !this is all we have to do for the parent in this case: call swap_pointers ( p1 % parent % children , p2 % parent % tail ) else if ( same_parent . and . . not . first_last ) then if ( associated ( p1 % parent % children , p1 )) then p1 % parent % children => p2 ! p1 is the first child of the parent else if ( associated ( p1 % parent % children , p2 )) then p1 % parent % children => p1 ! p2 is the first child of the parent end if if ( associated ( p1 % parent % tail , p1 )) then p1 % parent % tail => p2 ! p1 is the last child of the parent else if ( associated ( p1 % parent % tail , p2 )) then p1 % parent % tail => p1 ! p2 is the last child of the parent end if else ! general case: different parents if ( associated ( p1 % parent )) then if ( associated ( p1 % parent % children , p1 )) p1 % parent % children => p2 if ( associated ( p1 % parent % tail , p1 )) p1 % parent % tail => p2 end if if ( associated ( p2 % parent )) then if ( associated ( p2 % parent % children , p2 )) p2 % parent % children => p1 if ( associated ( p2 % parent % tail , p2 )) p2 % parent % tail => p1 end if call swap_pointers ( p1 % parent , p2 % parent ) end if !now, have to fix previous,next pointers: !first, see if they are adjacent: adjacent = associated ( p1 % next , p2 ) . or . & associated ( p2 % next , p1 ) if ( associated ( p2 % next , p1 )) then !p2,p1 a => p2 b => p1 else !p1,p2 (or not adjacent) a => p1 b => p2 end if if ( associated ( a % previous )) a % previous % next => b if ( associated ( b % next )) b % next % previous => a if ( adjacent ) then !a comes before b in the original list b % previous => a % previous a % next => b % next a % previous => b b % next => a else if ( associated ( a % next )) a % next % previous => b if ( associated ( b % previous )) b % previous % next => a call swap_pointers ( a % previous , b % previous ) call swap_pointers ( a % next , b % next ) end if end if else call json % throw_exception ( 'Error in json_value_swap: ' // & 'both pointers must be associated' ) end if end if contains pure subroutine swap_pointers ( s1 , s2 ) implicit none type ( json_value ), pointer , intent ( inout ) :: s1 type ( json_value ), pointer , intent ( inout ) :: s2 type ( json_value ), pointer :: tmp !! temporary pointer if (. not . associated ( s1 , s2 )) then tmp => s1 s1 => s2 s2 => tmp end if end subroutine swap_pointers end subroutine json_value_swap !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/28/2016 ! !  Returns True if `p2` is a descendant of `p1` !  (i.e, a child, or a child of child, etc.) function json_value_is_child_of ( json , p1 , p2 ) result ( is_child_of ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical ( LK ) :: is_child_of is_child_of = . false . if ( json % exception_thrown ) return if ( associated ( p1 ) . and . associated ( p2 )) then if ( associated ( p1 % children )) then call json % traverse ( p1 % children , is_child_of_callback ) end if end if contains subroutine is_child_of_callback ( json , p , finished ) !! Traverse until `p` is `p2`. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished is_child_of = associated ( p , p2 ) finished = is_child_of ! stop searching if found end subroutine is_child_of_callback end function json_value_is_child_of !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/2/2016 ! !  Validate a [[json_value]] linked list by checking to make sure !  all the pointers are properly associated, arrays and objects !  have the correct number of children, and the correct data is !  allocated for the variable types. ! !  It recursively traverses the entire structure and checks every element. ! !### History !  * Jacob Williams, 8/26/2017 : added duplicate key check. ! !@note It will return on the first error it encounters. ! !@note This routine does not check or throw any exceptions. !      If `json` is currently in a state of exception, it will !      remain so after calling this routine. subroutine json_value_validate ( json , p , is_valid , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: is_valid !! True if the structure is valid. character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! if not valid, this will contain !! a description of the problem logical ( LK ) :: has_duplicate !! to check for duplicate keys character ( kind = CK , len = :), allocatable :: path !! path to duplicate key logical ( LK ) :: status_ok !! to check for existing exception character ( kind = CK , len = :), allocatable :: exception_msg !! error message for an existing exception character ( kind = CK , len = :), allocatable :: exception_msg2 !! error message for a new exception if ( associated ( p )) then is_valid = . true . call check_if_valid ( p , require_parent = associated ( p % parent )) if ( is_valid . and . . not . json % allow_duplicate_keys ) then ! if no errors so far, also check the ! entire structure for duplicate keys: ! note: check_for_duplicate_keys does call routines ! that check and throw exceptions, so let's clear any ! first. (save message for later) call json % check_for_errors ( status_ok , exception_msg ) call json % clear_exceptions () call json % check_for_duplicate_keys ( p , has_duplicate , path = path ) if ( json % failed ()) then ! if an exception was thrown during this call, ! then clear it but make that the error message ! returned by this routine. Normally this should ! never actually occur since we have already ! validated the structure. call json % check_for_errors ( is_valid , exception_msg2 ) error_msg = exception_msg2 call json % clear_exceptions () is_valid = . false . else if ( has_duplicate ) then error_msg = 'duplicate key found: ' // path is_valid = . false . end if end if if (. not . status_ok ) then ! restore any existing exception if necessary call json % throw_exception ( exception_msg ) end if ! cleanup: if ( allocated ( path )) deallocate ( path ) if ( allocated ( exception_msg )) deallocate ( exception_msg ) if ( allocated ( exception_msg2 )) deallocate ( exception_msg2 ) end if else error_msg = 'The pointer is not associated' is_valid = . false . end if contains recursive subroutine check_if_valid ( p , require_parent ) implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( in ) :: require_parent !! the first one may be a root (so no parent), !! but all descendants must have a parent. integer :: i !! counter type ( json_value ), pointer :: element type ( json_value ), pointer :: previous if ( is_valid . and . associated ( p )) then ! data type: select case ( p % var_type ) case ( json_null , json_object , json_array ) if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for ' // & 'json_null, json_object, or json_array variable type' is_valid = . false . return end if case ( json_logical ) if (. not . allocated ( p % log_value )) then error_msg = 'log_value should be allocated for json_logical variable type' is_valid = . false . return else if ( allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_logical variable type' is_valid = . false . return end if case ( json_integer ) if (. not . allocated ( p % int_value )) then error_msg = 'int_value should be allocated for json_integer variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_integer variable type' is_valid = . false . return end if case ( json_double ) if (. not . allocated ( p % dbl_value )) then error_msg = 'dbl_value should be allocated for json_double variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_double variable type' is_valid = . false . return end if case ( json_string ) if (. not . allocated ( p % str_value )) then error_msg = 'str_value should be allocated for json_string variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value )) then error_msg = 'incorrect data allocated for json_string variable type' is_valid = . false . return end if case default error_msg = 'invalid JSON variable type' is_valid = . false . return end select if ( require_parent . and . . not . associated ( p % parent )) then error_msg = 'parent pointer is not associated' is_valid = . false . return end if if (. not . allocated ( p % name )) then if ( associated ( p % parent )) then if ( p % parent % var_type /= json_array ) then error_msg = 'JSON variable must have a name if not an ' // & 'array element or the root' is_valid = . false . return end if end if end if if ( associated ( p % children ) . neqv . associated ( p % tail )) then error_msg = 'both children and tail pointers must be associated' is_valid = . false . return end if ! now, check next one: if ( associated ( p % next )) then call check_if_valid ( p % next , require_parent = require_parent ) end if if ( associated ( p % children )) then if ( p % var_type /= json_array . and . p % var_type /= json_object ) then error_msg = 'only arrays and objects can have children' is_valid = . false . return end if ! first validate children pointers: previous => null () element => p % children do i = 1 , p % n_children if (. not . associated ( element % parent , p )) then error_msg = 'child''s parent pointer not properly associated' is_valid = . false . return end if if ( i == 1 . and . associated ( element % previous )) then error_msg = 'first child shouldn''t have a previous' is_valid = . false . return end if if ( i < p % n_children . and . . not . associated ( element % next )) then error_msg = 'not enough children' is_valid = . false . return end if if ( i == p % n_children . and . associated ( element % next )) then error_msg = 'too many children' is_valid = . false . return end if if ( i > 1 ) then if (. not . associated ( previous , element % previous )) then error_msg = 'previous pointer not properly associated' is_valid = . false . return end if end if if ( i == p % n_children . and . & . not . associated ( element % parent % tail , element )) then error_msg = 'parent''s tail pointer not properly associated' is_valid = . false . return end if if ( i < p % n_children ) then !setup next case: previous => element element => element % next end if end do !now check all the children: call check_if_valid ( p % children , require_parent = . true .) end if end if end subroutine check_if_valid end subroutine json_value_validate !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, remove the variable from !  the [[json_value]] structure, if it exists. subroutine json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json % get ( p , name , p_var , found ) if ( found ) call json % remove ( p_var ) end subroutine json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_remove_if_present]], where `name` is kind=CDK. subroutine wrap_json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_logical ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_logical ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_logical]], where `path` is kind=CDK. subroutine wrap_json_update_logical ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( path ), val , found ) end subroutine wrap_json_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_double ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_double ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_double]], where `path` is kind=CDK. subroutine wrap_json_update_double ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( path ), val , found ) end subroutine wrap_json_update_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_integer ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_integer ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_integer]], where `path` is kind=CDK. subroutine wrap_json_update_integer ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( path ), val , found ) end subroutine wrap_json_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_string ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_string ( p_var , val , trim_str = trim_str , adjustl_str = adjustl_str ) ! update the value case default found = . false . call json % throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `path` and `value` are kind=CDK. subroutine wrap_json_update_string ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) call json % update ( p , to_unicode ( path ), to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine wrap_json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `path` is kind=CDK. subroutine json_update_string_name_ascii ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) call json % update ( p , to_unicode ( path ), val , found , trim_str , adjustl_str ) end subroutine json_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `val` is kind=CDK. subroutine json_update_string_val_ascii ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) call json % update ( p , path , to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine json_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Adds `member` as a child of `p`. subroutine json_value_add_member ( json , p , member ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: member !! the child member !! to add to `p` if (. not . json % exception_thrown ) then ! associate the parent member % parent => p ! add to linked list if ( associated ( p % children )) then p % tail % next => member member % previous => p % tail else p % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list p % tail => member p % n_children = p % n_children + 1 end if end subroutine json_value_add_member !***************************************************************************************** !***************************************************************************************** !> !  Inserts `element` after `p`, and updates the JSON structure accordingly. ! !### Example ! !````fortran !  program test !   use json_module !   implicit none !   logical(json_LK) :: found !   type(json_core) :: json !   type(json_value),pointer :: p,new,element !   call json%parse(file='myfile.json', p=p) !   call json%get(p,'x(3)',element,found) ! get pointer to an array element in the file !   call json%create_integer(new,1,'')    ! create a new element !   call json%insert_after(element,new)   ! insert new element after x(3) !   call json%print(p,'myfile2.json')     ! write it to a file !   call json%destroy(p)                  ! cleanup !  end program test !```` ! !### Details ! !  * This routine can be used to insert a new element (or set of elements) !    into an array or object at a specific index. !    See [[json_value_insert_after_child_by_index]] !  * Children and subsequent elements of `element` are carried along. !  * If the inserted elements are part of an existing list, then !    they are removed from that list. ! !```` !              p !       [1] - [2] - [3] - [4] !                 | !                [5] - [6] - [7]        n=3 elements inserted !              element       last ! !  Result is: ! !       [1] - [2] - [5] - [6] - [7] - [3] - [4] ! !```` subroutine json_value_insert_after ( json , p , element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a value from a JSON structure !! (presumably, this is a child of !! an object or array). type ( json_value ), pointer :: element !! the element to insert after `p` type ( json_value ), pointer :: parent !! the parent of `p` type ( json_value ), pointer :: next !! temp pointer for traversing structure type ( json_value ), pointer :: last !! the last of the items being inserted integer :: n !! number of items being inserted if (. not . json % exception_thrown ) then parent => p % parent ! set first parent of inserted list: element % parent => parent ! Count the number of inserted elements. ! and set their parents. n = 1 ! initialize counter next => element % next last => element do if (. not . associated ( next )) exit n = n + 1 next % parent => parent last => next next => next % next end do if ( associated ( parent )) then ! update parent's child counter: parent % n_children = parent % n_children + n ! if p is last of parents children then ! also have to update parent tail pointer: if ( associated ( parent % tail , p )) then parent % tail => last end if end if if ( associated ( element % previous )) then ! element is apparently part of an existing list, ! so have to update that as well. if ( associated ( element % previous % parent )) then element % previous % parent % n_children = & element % previous % parent % n_children - n element % previous % parent % tail => & element % previous ! now the last one in the list else ! this would be a memory leak if the previous entries ! are not otherwise being pointed too ! [throw an error in this case???] end if !remove element from the other list: element % previous % next => null () end if element % previous => p if ( associated ( p % next )) then ! if there are any in the list after p: last % next => p % next last % next % previous => element else last % next => null () end if p % next => element end if end subroutine json_value_insert_after !***************************************************************************************** !***************************************************************************************** !> !  Inserts `element` after the `idx`-th child of `p`, !  and updates the JSON structure accordingly. This is just !  a wrapper for [[json_value_insert_after]]. subroutine json_value_insert_after_child_by_index ( json , p , idx , element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON object or array. integer ( IK ), intent ( in ) :: idx !! the index of the child of `p` to !! insert the new element after !! (this is a 1-based Fortran !! style array index) type ( json_value ), pointer :: element !! the element to insert type ( json_value ), pointer :: tmp !! for getting the `idx`-th child of `p` if (. not . json % exception_thrown ) then ! get the idx-th child of p: call json % get_child ( p , idx , tmp ) ! call json_value_insert_after: if (. not . json % exception_thrown ) call json % insert_after ( tmp , element ) end if end subroutine json_value_insert_after_child_by_index !***************************************************************************************** !***************************************************************************************** !> !  Add a new member (`json_value` pointer) to a JSON structure, given the path. ! !@warning If the path points to an existing variable in the structure, !         then this routine will destroy it and replace it with the !         new value. subroutine json_add_member_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! name of the variable if ( . not . json % exception_thrown ) then if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_member_by_path:' // & ' Input pointer p is not associated.' ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if if ( present ( was_created ) ) was_created = . false . else ! return a pointer to the path (possibly creating it) call json % create ( me , path , tmp , found , was_created ) if (. not . associated ( tmp )) then call json % throw_exception ( 'Error in json_add_member_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else call json % info ( tmp , name = name ) ! replace it with the new one: call json % replace ( tmp , p , destroy = . true .) call json % rename ( p , name ) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_member_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_member_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_add_member_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_member_by_path ( me , to_unicode ( path ), p , found , was_created ) end subroutine wrap_json_add_member_by_path !***************************************************************************************** !***************************************************************************************** !> !  Add an integer value to a [[json_value]], given the path. ! !@warning If the path points to an existing variable in the structure, !         then this routine will destroy it and replace it with the !         new value. subroutine json_add_integer_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_integer_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_integer ) then p % int_value = value else call json % info ( p , name = name ) call json % create_integer ( tmp , value , name ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_integer_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_integer_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_add_integer_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_integer_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_integer_by_path !***************************************************************************************** !***************************************************************************************** !> !  Add an double value to a [[json_value]], given the path. ! !@warning If the path points to an existing variable in the structure, !         then this routine will destroy it and replace it with the !         new value. subroutine json_add_double_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_double_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_double ) then p % dbl_value = value else call json % info ( p , name = name ) call json % create_double ( tmp , value , name ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_double_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_double_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_add_double_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_double_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_double_by_path !***************************************************************************************** !***************************************************************************************** !> !  Add a logical value to a [[json_value]], given the path. ! !@warning If the path points to an existing variable in the structure, !         then this routine will destroy it and replace it with the !         new value. subroutine json_add_logical_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_logical_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_logical ) then p % log_value = value else call json % info ( p , name = name ) call json % create_logical ( tmp , value , name ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_logical_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_logical_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_add_logical_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_logical_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_logical_by_path !***************************************************************************************** !***************************************************************************************** !> !  Add a string value to a [[json_value]], given the path. ! !@warning If the path points to an existing variable in the structure, !         then this routine will destroy it and replace it with the !         new value. subroutine json_add_string_by_path ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_string_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_string ) then p % str_value = value else call json % info ( p , name = name ) call json % create_string ( tmp , value , name , trim_str , adjustl_str ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_string_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_string_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_add_string_by_path ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_by_path ( me , to_unicode ( path ), to_unicode ( value ),& found , was_created , trim_str , adjustl_str ) end subroutine wrap_json_add_string_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_string_by_path]] where \"path\" is kind=CDK. subroutine json_add_string_by_path_path_ascii ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine json_add_string_by_path_path_ascii !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_string_by_path]] where \"value\" is kind=CDK. subroutine json_add_string_by_path_value_ascii ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_by_path ( me , path , to_unicode ( value ), found , was_created ) end subroutine json_add_string_by_path_value_ascii !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_integer_by_path]] for adding an integer vector by path. subroutine json_add_integer_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) call json % add ( var , CK_ '' , value ( i )) end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_integer_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_integer_vec_by_path]] where \"path\" is kind=CDK). subroutine wrap_json_add_integer_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_integer_vec_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_integer_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_logical_by_path]] for adding a logical vector by path. subroutine json_add_logical_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) call json % add ( var , CK_ '' , value ( i )) end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_logical_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_logical_vec_by_path]] where \"path\" is kind=CDK). subroutine wrap_json_add_logical_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_logical_vec_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_logical_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_double_by_path]] for adding a double vector by path. subroutine json_add_double_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) call json % add ( var , CK_ '' , value ( i )) end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_double_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_double_vec_by_path]] where \"path\" is kind=CDK). subroutine wrap_json_add_double_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_double_vec_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_double_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper to [[json_add_string_by_path]] for adding a string vector by path. ! !@note The `ilen` input can be used to specify the actual lengths of the !      the strings in the array. They must all be `<= len(value)`. subroutine json_add_string_vec_by_path ( json , me , path , value , found , was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then ! validate ilen array if present: if ( present ( ilen )) then if ( size ( ilen ) /= size ( value )) then call json % throw_exception ( 'Error in json_add_string_vec_by_path: ' // & 'Invalid size of ilen input vector.' ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if if ( present ( was_created )) was_created = . false . return else ! also have to validate the specified lengths. ! (must not be greater than input string length) do i = 1 , size ( value ) if ( ilen ( i ) > len ( value )) then call json % throw_exception ( 'Error in json_add_string_vec_by_path: ' // & 'Invalid ilen element.' ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if if ( present ( was_created )) was_created = . false . return end if end do end if end if !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) if ( present ( ilen )) then call json % add ( var , CK_ '' , value ( i )( 1 : ilen ( i )), & trim_str = trim_str , adjustl_str = adjustl_str ) else call json % add ( var , CK_ '' , value ( i ), & trim_str = trim_str , adjustl_str = adjustl_str ) end if end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_string_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_string_vec_by_path]] where \"path\" and \"value\" are kind=CDK). subroutine wrap_json_add_string_vec_by_path ( json , me , path , value ,& found , was_created , ilen ,& trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_vec_by_path ( me , to_unicode ( path ), to_unicode ( value ),& found , was_created , ilen , trim_str , adjustl_str ) end subroutine wrap_json_add_string_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_string_vec_by_path]] where \"value\" is kind=CDK). subroutine json_add_string_vec_by_path_value_ascii ( json , me , path , value ,& found , was_created , ilen ,& trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_vec_by_path ( me , path , to_unicode ( value ),& found , was_created , ilen , trim_str , adjustl_str ) end subroutine json_add_string_vec_by_path_value_ascii !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_add_string_vec_by_path]] where \"path\" is kind=CDK). subroutine json_add_string_vec_by_path_path_ascii ( json , me , path , value ,& found , was_created , ilen ,& trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_vec_by_path ( me , to_unicode ( path ), value ,& found , was_created , ilen ) end subroutine json_add_string_vec_by_path_path_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a real value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json % create_double ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double]] where `name` is kind=CDK. subroutine wrap_json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a real vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Add a NULL value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: var !create the variable: call json % create_null ( var , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_null !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_null]] where `name` is kind=CDK. subroutine wrap_json_value_add_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable call json % add ( p , to_unicode ( name )) end subroutine wrap_json_value_add_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json % create_integer ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer]] where `name` is kind=CDK. subroutine wrap_json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create a variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json % create_logical ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical]] where `name` is kind=CDK. subroutine wrap_json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a character string child to the [[json_value]] variable. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` type ( json_value ), pointer :: var !create the variable: call json % create_string ( var , val , name , trim_str , adjustl_str ) !add it: call json % add ( p , var ) end subroutine json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `name` and `val` are kind=CDK. subroutine wrap_json_value_add_string ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `name` is kind=CDK. subroutine json_value_add_string_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `val` is kind=CDK. subroutine json_value_add_string_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add an array of character strings to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i ), trim_str , adjustl_str ) end do !add it: call json % add ( p , var ) end subroutine json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `name` and `val` are kind=CDK. subroutine wrap_json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `name` is kind=CDK. subroutine json_value_add_string_vec_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `val` is kind=CDK. subroutine json_value_add_string_vec_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Count the number of children. ! !### History !  * JW : 1/4/2014 : Original routine removed. !    Now using `n_children` variable. !    Renamed from `json_value_count`. function json_count ( json , p ) result ( count ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ) :: count !! number of children if ( associated ( p )) then count = p % n_children else call json % throw_exception ( 'Error in json_count: ' // & 'pointer is not associated.' ) end if end function json_count !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/16/2015 ! !  Returns a pointer to the parent of a [[json_value]]. !  If there is no parent, then a `null()` pointer is returned. subroutine json_get_parent ( json , p , parent ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: parent !! pointer to `parent` if ( associated ( p )) then parent => p % parent else nullify ( parent ) call json % throw_exception ( 'Error in json_get_parent: ' // & 'pointer is not associated.' ) end if end subroutine json_get_parent !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the next of a [[json_value]]. !  If there is no next, then a `null()` pointer is returned. subroutine json_get_next ( json , p , next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: next !! pointer to `next` if ( associated ( p )) then next => p % next else nullify ( next ) call json % throw_exception ( 'Error in json_get_next: ' // & 'pointer is not associated.' ) end if end subroutine json_get_next !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the previous of a [[json_value]]. !  If there is no previous, then a `null()` pointer is returned. subroutine json_get_previous ( json , p , previous ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: previous !! pointer to `previous` if ( associated ( p )) then previous => p % previous else nullify ( previous ) call json % throw_exception ( 'Error in json_get_previous: ' // & 'pointer is not associated.' ) end if end subroutine json_get_previous !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the tail of a [[json_value]] !  (the last child of an array of object). !  If there is no tail, then a `null()` pointer is returned. subroutine json_get_tail ( json , p , tail ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: tail !! pointer to `tail` if ( associated ( p )) then tail => p % tail else nullify ( tail ) call json % throw_exception ( 'Error in json_get_tail: ' // & 'pointer is not associated.' ) end if end subroutine json_get_tail !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the index. subroutine json_value_get_child_by_index ( json , p , idx , child , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child !! (this is a 1-based Fortran !! style array index). type ( json_value ), pointer :: child !! pointer to the child logical ( LK ), intent ( out ), optional :: found !! true if the value was found !! (if not present, an exception !! will be thrown if it was not !! found.  If present and not !! found, no exception will be !! thrown). integer ( IK ) :: i !! counter nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p % children )) then child => p % children do i = 1 , idx - 1 if ( associated ( child % next )) then child => child % next else call json % throw_exception ( 'Error in json_value_get_child_by_index:' // & ' child%next is not associated.' ) nullify ( child ) exit end if end do else call json % throw_exception ( 'Error in json_value_get_child_by_index:' // & ' p%children is not associated.' ) end if ! found output: if ( json % exception_thrown ) then if ( present ( found )) then call json % clear_exceptions () found = . false . end if else if ( present ( found )) found = . true . end if else if ( present ( found )) found = . false . end if end subroutine json_value_get_child_by_index !***************************************************************************************** !***************************************************************************************** !> !  Returns pointer to the first child of the object !  (or `null()` if it is not associated). subroutine json_value_get_child ( json , p , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data type ( json_value ), pointer :: child !! pointer to the child if ( associated ( p )) then child => p % children else nullify ( child ) call json % throw_exception ( 'Error in json_value_get_child: ' // & 'pointer is not associated.' ) end if end subroutine json_value_get_child !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the name string. ! !  The name search can be case-sensitive or not, and can have significant trailing !  whitespace or not, depending on the settings in the [[json_core(type)]] class. ! !@note The `name` input is not a path, and is not parsed like it is in [[json_get_by_path]]. subroutine json_value_get_child_by_name ( json , p , name , child , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of `p` type ( json_value ), pointer :: child !! pointer to the child logical ( LK ), intent ( out ), optional :: found !! true if the value was found !! (if not present, an exception !! will be thrown if it was not !! found.  If present and not !! found, no exception will be !! thrown). integer ( IK ) :: i , n_children logical :: error nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p )) then error = . true . ! will be false if it is found if ( p % var_type == json_object ) then n_children = json % count ( p ) child => p % children !start with first one do i = 1 , n_children if (. not . associated ( child )) then call json % throw_exception (& 'Error in json_value_get_child_by_name: ' // & 'Malformed JSON linked list' ) exit end if if ( allocated ( child % name )) then !name string matching routine: if ( json % name_equal ( child , name )) then error = . false . exit end if end if child => child % next end do end if if ( error ) then !did not find anything: call json % throw_exception (& 'Error in json_value_get_child_by_name: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( child ) end if else call json % throw_exception (& 'Error in json_value_get_child_by_name: ' // & 'pointer is not associated.' ) end if ! found output: if ( json % exception_thrown ) then if ( present ( found )) then call json % clear_exceptions () found = . false . end if else if ( present ( found )) found = . true . end if else if ( present ( found )) found = . false . end if end subroutine json_value_get_child_by_name !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/25/2017 ! !  Checks a JSON object for duplicate child names. ! !  It uses the specified settings for name matching (see [[name_strings_equal]]). ! !@note This will only check for one duplicate, !      it will return the first one that it finds. subroutine json_check_children_for_duplicate_keys ( json , p , has_duplicate , name , path ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! the object to search. If `p` is !! not a `json_object`, then `has_duplicate` !! will be false. logical ( LK ), intent ( out ) :: has_duplicate !! true if there is at least !! two children have duplicate !! `name` values. character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! the duplicate name !! (unallocated if no !! duplicate was found) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: path !! the full path to the !! duplicate name !! (unallocated if no !! duplicate was found) integer ( IK ) :: i !! counter integer ( IK ) :: j !! counter type ( json_value ), pointer :: child !! pointer to a child of `p` integer ( IK ) :: n_children !! number of children of `p` logical ( LK ) :: found !! flag for `get_child` type :: alloc_str !! so we can have an array of allocatable strings character ( kind = CK , len = :), allocatable :: str !! name string end type alloc_str type ( alloc_str ), dimension (:), allocatable :: names !! array of all the !! child name strings ! initialize: has_duplicate = . false . if (. not . json % exception_thrown ) then if ( associated ( p )) then if ( p % var_type == json_object ) then ! number of items to check: n_children = json % count ( p ) allocate ( names ( n_children )) ! first get a list of all the name keys: do i = 1 , n_children call json % get_child ( p , i , child , found ) ! get by index if (. not . found ) then call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Malformed JSON linked list' ) exit end if if ( allocated ( child % name )) then names ( i )% str = child % name else call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Object child name is not allocated' ) exit end if end do if (. not . json % exception_thrown ) then ! now check the list for duplicates: main : do i = 1 , n_children do j = 1 , i - 1 if ( json % name_strings_equal ( names ( i )% str , names ( j )% str )) then has_duplicate = . true . if ( present ( name )) then name = names ( i )% str end if if ( present ( path )) then call json % get_child ( p , names ( i )% str , child , found ) ! get by name if ( found ) then call json % get_path ( child , path , found ) if (. not . found ) then ! should never happen since we know it is there call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Could not get path' ) end if else ! should never happen since we know it is there call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Could not get child: ' // trim ( names ( i )% str )) end if end if exit main end if end do end do main end if ! cleanup do i = 1 , n_children if ( allocated ( names ( i )% str )) deallocate ( names ( i )% str ) end do if ( allocated ( names )) deallocate ( names ) end if end if end if end subroutine json_check_children_for_duplicate_keys !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/25/2017 ! !  Checks a JSON structure for duplicate child names. !  This one recursively traverses the entire structure !  (calling [[json_check_children_for_duplicate_keys]] !  recursively for each element). ! !@note This will only check for one duplicate, !      it will return the first one that it finds. subroutine json_check_all_for_duplicate_keys ( json , p , has_duplicate , name , path ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! the object to search. If `p` is !! not a `json_object`, then `has_duplicate` !! will be false. logical ( LK ), intent ( out ) :: has_duplicate !! true if there is at least !! one duplicate `name` key anywhere !! in the structure. character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! the duplicate name !! (unallocated if no !! duplicates were found) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: path !! the full path to the !! duplicate name !! (unallocated if no !! duplicate was found) has_duplicate = . false . if (. not . json % exception_thrown ) then call json % traverse ( p , duplicate_key_func ) end if contains subroutine duplicate_key_func ( json , p , finished ) !! Callback function to check each element !! for duplicate child names. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished #if defined __GFORTRAN__ ! this is a workaround for a gfortran bug (6 and 7), character ( kind = CK , len = :), allocatable :: tmp_name !! temp variable for `name` string character ( kind = CK , len = :), allocatable :: tmp_path !! temp variable for `path` string if ( present ( name ) . and . present ( path )) then call json % check_children_for_duplicate_keys ( p , has_duplicate , name = tmp_name , path = tmp_path ) else if ( present ( name ) . and . . not . present ( path )) then call json % check_children_for_duplicate_keys ( p , has_duplicate , name = tmp_name ) else if (. not . present ( name ) . and . present ( path )) then call json % check_children_for_duplicate_keys ( p , has_duplicate , path = tmp_path ) else call json % check_children_for_duplicate_keys ( p , has_duplicate ) end if if ( has_duplicate ) then if ( present ( name )) name = tmp_name if ( present ( path )) path = tmp_path end if #else call json % check_children_for_duplicate_keys ( p , has_duplicate , name , path ) #endif finished = has_duplicate . or . json % exception_thrown end subroutine duplicate_key_func end subroutine json_check_all_for_duplicate_keys !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_get_child_by_name]] where `name` is kind=CDK. subroutine wrap_json_value_get_child_by_name ( json , p , name , child , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: child logical ( LK ), intent ( out ), optional :: found call json % get ( p , to_unicode ( name ), child , found ) end subroutine wrap_json_value_get_child_by_name !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/12/2014 ! !  Print the [[json_value]] structure to an allocatable string. subroutine json_value_to_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = CK_ '' call json % json_value_print ( p , iunit = unit2str , str = str , indent = 1_IK , colon = . true .) end subroutine json_value_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/20/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_1 ( json , p , iunit ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must !! already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json % json_value_print ( p , iunit , str = dummy , indent = 1_IK , colon = . true .) else call json % throw_exception ( 'Error in json_print_1: iunit must not be -1.' ) end if end subroutine json_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/23/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_2 ( json , p , filename ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to !! (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json % print ( p , iunit ) close ( iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2 !***************************************************************************************** !***************************************************************************************** !> !  Print the JSON structure to a string or a file. ! !### Notes !  * This is an internal routine called by the various wrapper routines. !  * The reason the `str` argument is non-optional is because of a !    bug in v4.9 of the gfortran compiler. recursive subroutine json_value_print ( json , p , iunit , str , indent ,& need_comma , colon , is_array_element ,& is_compressed_vector ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. logical ( LK ), intent ( in ), optional :: is_compressed_vector !! if True, this is an element !! from an array being printed !! on one line [default is False] character ( kind = CK , len = max_numeric_str_len ) :: tmp !! for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array integer ( IK ) :: var_type , var_type_prev logical ( LK ) :: is_vector !! if all elements of a vector !! are scalars of the same type character ( kind = CK , len = :), allocatable :: str_escaped !! escaped version of !! `name` or `str_value` if (. not . json % exception_thrown ) then if ( present ( is_compressed_vector )) then is_vector = is_compressed_vector else is_vector = . false . end if !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent ) . and . . not . json % no_whitespace ) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * json % spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = CK_ '' else s = repeat ( space , spaces ) end if select case ( p % var_type ) case ( json_object ) count = json % count ( p ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then if ( . not . json % no_whitespace ) tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! print the name if ( allocated ( element % name )) then call escape_string ( element % name , str_escaped , json % escape_solidus ) if ( json % no_whitespace ) then !compact printing - no extra space call write_it ( repeat ( space , spaces ) // quotation_mark // & str_escaped // quotation_mark // colon_char ,& advance = . false .) else call write_it ( repeat ( space , spaces ) // quotation_mark // & str_escaped // quotation_mark // colon_char // space ,& advance = . false .) end if else call json % throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json % count ( p ) if ( json % compress_vectors ) then ! check to see if every child is the same type, ! and a scalar: is_vector = . true . var_type_prev = - 1 ! an invalid value nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! check variable type of all the children. ! They must all be the same, and a scalar. call json % info ( element , var_type = var_type ) if ( var_type == json_object . or . & var_type == json_array . or . & ( i > 1 . and . var_type /= var_type_prev )) then is_vector = . false . exit end if var_type_prev = var_type ! get the next child the list: element => element % next end do else is_vector = . false . end if if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( s // start_array , advance = (. not . is_vector ) ) !if an array is in an array, there is an extra tab: if ( is_array ) then if ( . not . json % no_whitespace ) tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! recursive print of the element if ( is_vector ) then call json % json_value_print ( element , iunit = iunit , indent = 0 ,& need_comma = i < count , is_array_element = . false ., str = str ,& is_compressed_vector = . true .) else call json % json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) end if ! get the next child the list: element => element % next end do !indent the closing array character: if ( is_vector ) then call write_it ( end_array , comma = print_comma ) else call write_it ( repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) // end_array ,& comma = print_comma ) end if nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) case ( json_string ) if ( allocated ( p % str_value )) then ! have to escape the string for printing: call escape_string ( p % str_value , str_escaped , json % escape_solidus ) call write_it ( s // quotation_mark // & str_escaped // quotation_mark , & comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) else call json % throw_exception ( 'Error in json_value_print:' // & ' p%value_string not allocated' ) return end if case ( json_logical ) if ( p % log_value ) then call write_it ( s // true_str , comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) else call write_it ( s // false_str , comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) end if case ( json_integer ) call integer_to_string ( p % int_value , int_fmt , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) case ( json_double ) if ( allocated ( json % real_fmt )) then call real_to_string ( p % dbl_value , json % real_fmt , json % compact_real , tmp ) else !use the default format (user has not called initialize() or specified one): call real_to_string ( p % dbl_value , default_real_fmt , json % compact_real , tmp ) end if call write_it ( s // trim ( tmp ), comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) case default call json % throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains subroutine write_it ( s , advance , comma , space_after_comma ) !! write the string to the file (or the output string) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !! string to print logical ( LK ), intent ( in ), optional :: advance !! to add line break or not logical ( LK ), intent ( in ), optional :: comma !! print comma after the string logical ( LK ), intent ( in ), optional :: space_after_comma !! print a space after the comma logical ( LK ) :: add_comma !! if a delimiter is to be added after string logical ( LK ) :: add_line_break !! if a line break is to be added after string logical ( LK ) :: add_space !! if a space is to be added after the comma character ( kind = CK , len = :), allocatable :: s2 !! temporary string if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( json % no_whitespace ) then add_space = . false . else if ( present ( space_after_comma )) then add_space = space_after_comma else add_space = . false . !default is not to add space end if end if if ( present ( advance )) then if ( json % no_whitespace ) then ! overrides input value: add_line_break = . false . else add_line_break = advance end if else add_line_break = . not . json % no_whitespace ! default is to advance if ! we are printing whitespace end if !string to print: s2 = s if ( add_comma ) then s2 = s2 // delimiter if ( add_space ) s2 = s2 // space end if if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print !***************************************************************************************** !***************************************************************************************** !> !  Returns true if the `path` is present in the `p` JSON structure. ! !@note Just a wrapper for [[json_get_by_path]], so it uses the !      specified `path_mode` and other settings. function json_valid_path ( json , p , path ) result ( found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ) :: found !! true if it was found type ( json_value ), pointer :: tmp !! pointer to the variable specified by `path` call json % get ( p , path , tmp , found ) end function json_valid_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_valid_path]] where \"path\" is kind=CDK. function wrap_json_valid_path ( json , p , path ) result ( found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ) :: found !! true if it was found found = json % valid_path ( p , to_unicode ( path )) end function wrap_json_valid_path !***************************************************************************************** !***************************************************************************************** !> !  Returns the [[json_value]] pointer given the path string. ! !  It uses either of two methods: ! !  * The original JSON-Fortran defaults !  * [RFC 6901](https://tools.ietf.org/html/rfc6901) ! !@warning if `found` is present, we should clear any exceptions that are thrown !         to be consistent with other routines. This is not currently being done. subroutine json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specified by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found character ( kind = CK , len = max_integer_str_len ), allocatable :: path_mode_str !! string version !! of `json%path_mode` nullify ( p ) if (. not . json % exception_thrown ) then ! note: it can only be 1 or 2 (3 not currently enabled) select case ( json % path_mode ) case ( 1_IK ) call json % json_get_by_path_default ( me , path , p , found ) case ( 2_IK ) call json % json_get_by_path_rfc6901 ( me , path , p , found ) case ( 3_IK ) call json % json_get_by_path_jsonpath_bracket ( me , path , p , found ) case default call integer_to_string ( json % path_mode , int_fmt , path_mode_str ) call json % throw_exception ( 'Error in json_get_by_path: Unsupported path_mode: ' // & trim ( path_mode_str )) if ( present ( found )) found = . false . end select else if ( present ( found )) found = . false . end if end subroutine json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Returns the [[json_value]] pointer given the path string, !  If necessary, by creating the variables as needed. ! !  By default, the leaf node and any empty array elements !  are created as `json_null` values. ! !  It only works for `path_mode=1` or `path_mode=3`. !  An error will be thrown for `path_mode=2` (RFC 6901). ! !### See also !  * [[json_get_by_path]] subroutine json_create_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ), optional :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if there were no errors !! (variable found or created) logical ( LK ), intent ( out ), optional :: was_created !! true if it was actually created !! (as opposed to already being there) type ( json_value ), pointer :: tmp character ( kind = CK , len = max_integer_str_len ) :: path_mode_str !! string version !! of `json%path_mode` if ( present ( p )) nullify ( p ) if (. not . json % exception_thrown ) then select case ( json % path_mode ) case ( 1_IK ) call json % json_get_by_path_default ( me , path , tmp , found ,& create_it = . true .,& was_created = was_created ) if ( present ( p )) p => tmp case ( 3_IK ) call json % json_get_by_path_jsonpath_bracket ( me , path , tmp , found ,& create_it = . true .,& was_created = was_created ) if ( present ( p )) p => tmp case default if ( json % path_mode == 2_IK ) then ! the problem here is there isn't really a way to disambiguate ! the array elements, so '/a/0' could be 'a(1)' or 'a.0'. call json % throw_exception ( 'Error in json_create_by_path: ' // & 'Create by path not supported in RFC 6901 path mode.' ) else call integer_to_string ( json % path_mode , int_fmt , path_mode_str ) call json % throw_exception ( 'Error in json_create_by_path: Unsupported path_mode: ' // & trim ( path_mode_str )) end if if ( present ( found )) then call json % clear_exceptions () found = . false . end if if ( present ( was_created )) was_created = . false . end select else if ( present ( was_created )) was_created = . false . if ( present ( found )) found = . false . end if end subroutine json_create_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_create_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_create_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ), optional :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if there were no errors !! (variable found or created) logical ( LK ), intent ( out ), optional :: was_created !! true if it was actually created !! (as opposed to already being there) call json % create ( me , to_unicode ( path ), p , found , was_created ) end subroutine wrap_json_create_by_path !***************************************************************************************** !***************************************************************************************** !> !  Rename a [[json_value]], given the path. subroutine json_rename_by_path ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_rename_by_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % rename ( p , name ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_rename_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_rename_by_path]], where \"path\" and \"name\" are kind=CDK subroutine wrap_json_rename_by_path ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( out ), optional :: found call json % rename ( me , to_unicode ( path ), to_unicode ( name ), found ) end subroutine wrap_json_rename_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_rename_by_path]], where \"name\" is kind=CDK subroutine json_rename_by_path_name_ascii ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( out ), optional :: found call json % rename ( me , path , to_unicode ( name ), found ) end subroutine json_rename_by_path_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_rename_by_path]], where \"path\" is kind=CDK subroutine json_rename_by_path_path_ascii ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( out ), optional :: found call json % rename ( me , to_unicode ( path ), name , found ) end subroutine json_rename_by_path_path_ascii !***************************************************************************************** !***************************************************************************************** !> !  Returns the [[json_value]] pointer given the path string. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: dat,p !    logical :: found !    !... !    call json%initialize(path_mode=1) ! this is the default so not strictly necessary. !    call json%get(dat,'data(2).version',p,found) !```` ! !### Notes !  The syntax used here is a subset of the !  [http://goessner.net/articles/JsonPath/](JSONPath) \"dot–notation\". !  The following special characters are used to denote paths: ! !  * `$`           - root !  * `@`           - this !  * `.`           - child object member (note this can be changed using `json%path_separator`) !  * `[]` or `()`  - child array element (note that indices are 1-based) ! !  Thus, if any of these characters are present in the name key, !  this routine cannot be used to get the value. !  In that case, the `get_child` methods would need to be used. !  Or, the alternate [[json_get_by_path_rfc6901]] could be used. ! !### See also !  * [[json_get_by_path_rfc6901]] !  * [[json_get_by_path_jsonpath_bracket]] ! !@note The syntax is inherited from FSON, and is basically a subset !      of JSONPath \"dot-notation\", with the additional allowance of !      () for array elements. ! !@note JSON `null` values are used here for unknown variables when `create_it` is True. !      So, it is possible that an existing null variable can be converted to another !      type (object or array) if a child is specified in the path. Doing it this way !      to avoid having to use another type (say `json_unknown`) that would have to be !      converted to null once all the variables have been created (user would have !      had to do this). ! !@warning See (**) in code. I think we need to protect for memory leaks when !         changing the type of a variable that already exists. subroutine json_get_by_path_default ( json , me , path , p , found , create_it , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found logical ( LK ), intent ( in ), optional :: create_it !! if a variable is not present !! in the path, then it is created. !! the leaf node is returned as !! a `null` json type and can be !! changed by the caller. logical ( LK ), intent ( out ), optional :: was_created !! if `create_it` is true, this !! will be true if the variable !! was actually created. Otherwise !! it will be false. integer ( IK ) :: i !! counter of characters in `path` integer ( IK ) :: length !! significant length of `path` integer ( IK ) :: child_i !! index for getting children character ( kind = CK , len = 1 ) :: c !! a character in the `path` logical ( LK ) :: array !! flag when searching for array index in `path` type ( json_value ), pointer :: tmp !! temp variables for getting child objects logical ( LK ) :: child_found !! if the child value was found logical ( LK ) :: create !! if the object is to be created logical ( LK ) :: created !! if `create` is true, then this will be !! true if the leaf object had to be created integer ( IK ) :: j !! counter of children when creating object nullify ( p ) if (. not . json % exception_thrown ) then if ( present ( create_it )) then create = create_it else create = . false . end if ! default to assuming relative to me p => me child_i = 1 array = . false . created = . false . !keep trailing space or not: if ( json % trailing_spaces_significant ) then length = len ( path ) else length = len_trim ( path ) end if do i = 1 , length c = path ( i : i ) select case ( c ) case ( root ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 if ( create ) created = . false . ! should always exist case ( this ) ! this p => me child_i = i + 1 if ( create ) created = . false . ! should always exist case ( start_array , start_array_alt ) ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) if ( create ) then ! Example: !    'aaa.bbb(1)' !     -> and aaa is a null, need to make it an object ! !  What about the case: aaa.bbb(1)(3) ? !  Is that already handled? if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an object here: p % var_type = json_object end if ! don't want to throw exceptions in this case call json % get_child ( p , path ( child_i : i - 1 ), tmp , child_found ) if (. not . child_found ) then ! have to create this child ! [make it an array] call json_value_create ( tmp ) call json % to_array ( tmp , path ( child_i : i - 1 )) call json % add ( p , tmp ) created = . true . else created = . false . end if else ! call the normal way call json % get_child ( p , path ( child_i : i - 1 ), tmp ) end if p => tmp else child_i = i + 1 ! say, '@(' cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path_default:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call json % throw_exception ( 'Error in json_get_by_path_default: Unexpected ' // c ) exit end if array = . false . child_i = json % string_to_int ( path ( child_i : i - 1 )) nullify ( tmp ) if ( create ) then ! don't want to throw exceptions in this case call json % get_child ( p , child_i , tmp , child_found ) if (. not . child_found ) then if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an array here: p % var_type = json_array end if ! have to create this element ! [make it a null] ! (and any missing ones before it) do j = 1 , child_i nullify ( tmp ) call json % get_child ( p , j , tmp , child_found ) if (. not . child_found ) then call json_value_create ( tmp ) call json % to_null ( tmp ) ! array element doesn't need a name call json % add ( p , tmp ) if ( j == child_i ) created = . true . else if ( j == child_i ) created = . false . end if end do else created = . false . end if else ! call the normal way: call json % get_child ( p , child_i , tmp ) end if p => tmp child_i = i + 1 case default if ( c == json % path_separator ) then ! get child member from p if ( child_i < i ) then nullify ( tmp ) if ( create ) then if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an object here: p % var_type = json_object end if ! don't want to throw exceptions in this case call json % get_child ( p , path ( child_i : i - 1 ), tmp , child_found ) if (. not . child_found ) then ! have to create this child ! [make it an object] call json_value_create ( tmp ) call json % to_object ( tmp , path ( child_i : i - 1 )) call json % add ( p , tmp ) created = . true . else created = . false . end if else ! call the normal way call json % get_child ( p , path ( child_i : i - 1 ), tmp ) end if p => tmp else child_i = i + 1 ! say '$.', '@.', or ').' cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path_default:' // & ' Error getting child member.' ) exit end if child_i = i + 1 end if end select end do if ( json % exception_thrown ) then if ( present ( found )) then nullify ( p ) ! just in case found = . false . call json % clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) if ( create ) then if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an object here: p % var_type = json_object end if call json % get_child ( p , path ( child_i : i - 1 ), tmp , child_found ) if (. not . child_found ) then ! have to create this child ! (make it a null since it is the leaf) call json_value_create ( tmp ) call json % to_null ( tmp , path ( child_i : i - 1 )) call json % add ( p , tmp ) created = . true . else created = . false . end if else ! call the normal way call json % get_child ( p , path ( child_i : i - 1 ), tmp ) end if p => tmp else ! we already have p if ( create . and . created ) then ! make leaf p a null, but only ! if it wasn't there call json % to_null ( p ) end if end if ! error checking if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call json % throw_exception ( 'Error in json_get_by_path_default:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if end if ! if it had to be created: if ( present ( was_created )) was_created = created else if ( present ( found )) found = . false . if ( present ( was_created )) was_created = . false . end if end subroutine json_get_by_path_default !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/4/2017 ! !  Returns the [[json_value]] pointer given the path string, !  using the \"JSON Pointer\" path specification defined by RFC 6901. ! !  Note that trailing whitespace significance and case sensitivity !  are user-specified. To fully conform to the RFC 6901 standard, !  should probably set (via `initialize`): ! !  * `trailing_spaces_significant` = .true. [this is not the default setting] !  * `case_sensitive_keys` = .true.         [this is the default setting] ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: dat,p !    logical :: found !    !... !    call json%initialize(path_mode=2) !    call json%get(dat,'/data/2/version',p,found) !```` ! !### See also !  * [[json_get_by_path_default]] !  * [[json_get_by_path_jsonpath_bracket]] ! !### Reference !  * [JavaScript Object Notation (JSON) Pointer](https://tools.ietf.org/html/rfc6901) ! !@note Not doing anything special about the `-` character to index an array. !      This is considered a normal error. ! !@note Unlike in the default path mode, the array indices here are 0-based !      (in accordance with the RFC 6901 standard) ! !@warning Not checking if the member that is referenced is unique. !         (according to the standard, evaluation of non-unique references !         should fail). Like [[json_get_by_path_default]], this one will just return !         the first instance it encounters. This might be changed in the future. ! !@warning I think the standard indicates that the input paths should use !         escaped JSON strings (currently we are assuming they are not escaped). subroutine json_get_by_path_rfc6901 ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable !! (an RFC 6901 \"JSON Pointer\") type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found character ( kind = CK , len = :), allocatable :: token !! a token in the path (between the `/` characters) integer ( IK ) :: i !! counter integer ( IK ) :: islash_curr !! location of current '/' character in the path integer ( IK ) :: islash_next !! location of next '/' character in the path integer ( IK ) :: ilen !! length of `path` string type ( json_value ), pointer :: tmp !! temporary variable for traversing the structure integer ( IK ) :: ival !! integer array index value (0-based) logical ( LK ) :: status_ok !! error flag logical ( LK ) :: child_found !! for getting child values nullify ( p ) if (. not . json % exception_thrown ) then p => me ! initialize if ( path /= CK_ '' ) then if ( path ( 1 : 1 ) == slash ) then ! the first character must be a slash islash_curr = 1 ! initialize current slash index !keep trailing space or not: if ( json % trailing_spaces_significant ) then ilen = len ( path ) else ilen = len_trim ( path ) end if do ! get the next token by finding the slashes ! !  1   2 3 !  /abc/d/efg if ( islash_curr == ilen ) then !the last token is an empty string token = CK_ '' islash_next = 0 ! will signal to stop else !      . ! '/123/567/' ! index in remaining string: islash_next = index ( path ( islash_curr + 1 : ilen ), slash ) if ( islash_next <= 0 ) then !last token: token = path ( islash_curr + 1 : ilen ) else ! convert to actual index in path: islash_next = islash_curr + index ( path ( islash_curr + 1 : ilen ), slash ) if ( islash_next > islash_curr + 1 ) then token = path ( islash_curr + 1 : islash_next - 1 ) else !empty token: token = CK_ '' end if end if end if ! remove trailing spaces in the token here if necessary: if (. not . json % trailing_spaces_significant ) & token = trim ( token ) ! decode the token: token = decode_rfc6901 ( token ) ! now, parse the token: ! first see if there is a child with this name call json % get_child ( p , token , tmp , child_found ) if ( child_found ) then ! it was found p => tmp else ! No key with this name. ! Is it an integer? If so, ! it might be an array index. status_ok = ( len ( token ) > 0 ) if ( status_ok ) then do i = 1 , len ( token ) ! It must only contain (0..9) characters ! (it must be unsigned) if ( scan ( token ( i : i ), CK_ '0123456789' ) < 1 ) then status_ok = . false . exit end if end do if ( status_ok ) then if ( len ( token ) > 1 . and . token ( 1 : 1 ) == CK_ '0' ) then ! leading zeros not allowed for some reason status_ok = . false . end if end if if ( status_ok ) then ! if we make it this far, it should be ! convertable to an integer, so do it. call string_to_integer ( token , ival , status_ok ) end if end if if ( status_ok ) then ! ival is an array index (0-based) call json % get_child ( p , ival + 1 , tmp , child_found ) if ( child_found ) then p => tmp else ! not found status_ok = . false . end if end if if (. not . status_ok ) then call json % throw_exception ( 'Error in json_get_by_path_rfc6901: ' // & 'invalid path specification: ' // trim ( path )) exit end if end if if ( islash_next <= 0 ) exit ! finished ! set up for next token: islash_curr = islash_next end do else call json % throw_exception ( 'Error in json_get_by_path_rfc6901: ' // & 'invalid path specification: ' // trim ( path )) end if end if if ( json % exception_thrown ) then nullify ( p ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path_rfc6901 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/2/2017 ! !  Returns the [[json_value]] pointer given the path string, !  using the \"JSON Pointer\" path specification defined by the !  JSONPath \"bracket-notation\". ! !  The first character `$` is optional, and signifies the root !  of the structure. If it is not present, then the first key !  is taken to be in the `me` object. ! !  Single or double quotes may be used. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: dat,p !    logical :: found !    !... !    call json%initialize(path_mode=3) !    call json%get(dat,\"$['store']['book'][1]['title']\",p,found) !```` ! !### See also !  * [[json_get_by_path_default]] !  * [[json_get_by_path_rfc6901]] ! !### Reference !  * [JSONPath](http://goessner.net/articles/JsonPath/) ! !@note Uses 1-based array indices (same as [[json_get_by_path_default]], !      but unlike [[json_get_by_path_rfc6901]] which uses 0-based indices). ! !@note When `create_it=True`, if the variable already exists and is a type !      that is not compatible with the usage in the `path`, then it is !      destroyed and replaced with what is specified in the `path`. Note that !      this applies the all variables in the path as it is created. Currently, !      this behavior is different from [[json_get_by_path_default]]. ! !@note JSON `null` values are used here for unknown variables !      when `create_it` is True. ! !@warning Note that if using single quotes, this routine cannot parse !         a key containing `']`. If using double quotes, this routine !         cannot parse a key containing `\"]`. If the key contains both !         `']` and `\"]`, there is no way to parse it using this routine. subroutine json_get_by_path_jsonpath_bracket ( json , me , path , p , found , create_it , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable !! (using JSONPath !! \"bracket-notation\") type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found logical ( LK ), intent ( in ), optional :: create_it !! if a variable is not present !! in the path, then it is created. !! the leaf node is returned as !! a `null` json type and can be !! changed by the caller. logical ( LK ), intent ( out ), optional :: was_created !! if `create_it` is true, this !! will be true if the variable !! was actually created. Otherwise !! it will be false. character ( kind = CK , len = :), allocatable :: token !! a token in the path !! (between the `['']` or !! `[]` characters) integer ( IK ) :: istart !! location of current '[' !! character in the path integer ( IK ) :: iend !! location of current ']' !! character in the path integer ( IK ) :: ival !! integer array index value logical ( LK ) :: status_ok !! error flag type ( json_value ), pointer :: tmp !! temporary variable for !! traversing the structure integer ( IK ) :: i !! counter integer ( IK ) :: ilen !! length of `path` string logical ( LK ) :: double_quotes !! if the keys are enclosed in `\"`, !! rather than `'` tokens. logical ( LK ) :: create !! if the object is to be created logical ( LK ) :: created !! if `create` is true, then this will be !! true if the leaf object had to be created integer ( IK ) :: j !! counter of children when creating object !TODO instead of reallocating `token` all the time, just !     allocate a big size and keep track of the length, !     then just reallocate only if necessary. !     [would probably be inefficient if there was a very large token, !     and then a bunch of small ones... but for similarly-sized ones !     it should be way more efficient since it would avoid most !     reallocations.] nullify ( p ) if (. not . json % exception_thrown ) then if ( present ( create_it )) then create = create_it else create = . false . end if p => me ! initialize created = . false . if ( path == CK_ '' ) then call json % throw_exception ( 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path specification: ' // trim ( path )) else if ( path ( 1 : 1 ) == root . or . path ( 1 : 1 ) == start_array ) then ! the first character must be ! a `$` (root) or a `[` ! (element of `me`) if ( path ( 1 : 1 ) == root ) then ! go to the root do while ( associated ( p % parent )) p => p % parent end do if ( create ) created = . false . ! should always exist end if !path length (don't need trailing spaces:) ilen = len_trim ( path ) if ( ilen > 1 ) then istart = 2 ! initialize first '[' location index do if ( istart > ilen ) exit ! finished ! must be the next start bracket: if ( path ( istart : istart ) /= start_array ) then call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'expecting \"[\", found: \"' // trim ( path ( istart : istart )) // & '\" in path: ' // trim ( path )) exit end if ! get the next token by checking: ! ! * [''] -- is the token after istart a quote? !           if so, then search for the next `']` ! ! * [1] -- if not, then maybe it is a number, !          so search for the next `]` ! verify length of remaining string if ( istart + 2 <= ilen ) then double_quotes = path ( istart + 1 : istart + 1 ) == quotation_mark ! [\" if ( double_quotes . or . path ( istart + 1 : istart + 1 ) == single_quote ) then ! [' ! it might be a key value: ['abc'] istart = istart + 1 ! move counter to ' index if ( double_quotes ) then iend = istart + index ( path ( istart + 1 : ilen ),& quotation_mark // end_array ) ! \"] else iend = istart + index ( path ( istart + 1 : ilen ),& single_quote // end_array ) ! '] end if if ( iend > istart ) then !     istart  iend !       |       | ! ['p']['abcdefg'] if ( iend > istart + 1 ) then token = path ( istart + 1 : iend - 1 ) else token = CK_ '' ! blank string end if ! remove trailing spaces in ! the token here if necessary: if (. not . json % trailing_spaces_significant ) & token = trim ( token ) if ( create ) then ! have a token, create it if necessary ! we need to convert it into an object here ! (e.g., if p was also just created) ! and destroy its data to prevent a memory leak call json % convert ( p , json_object ) ! don't want to throw exceptions in this case call json % get_child ( p , token , tmp , status_ok ) if (. not . status_ok ) then ! have to create this child ! [make it a null since we don't ! know what it is yet] call json_value_create ( tmp ) call json % to_null ( tmp , token ) call json % add ( p , tmp ) status_ok = . true . created = . true . else ! it was already there. created = . false . end if else ! have a token, see if it is valid: call json % get_child ( p , token , tmp , status_ok ) end if if ( status_ok ) then ! it was found p => tmp else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid token found: \"' // token // & '\" in path: ' // trim ( path )) exit end if iend = iend + 1 ! move counter to ] index else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path: ' // trim ( path )) exit end if else ! it might be an integer value: [123] iend = istart + index ( path ( istart + 1 : ilen ), end_array ) ! ] if ( iend > istart + 1 ) then ! this should be an integer: token = path ( istart + 1 : iend - 1 ) ! verify that there are no spaces or other ! characters in the string: do i = 1 , len ( token ) ! It must only contain (0..9) characters ! (it must be unsigned) if ( scan ( token ( i : i ), CK_ '0123456789' ) < 1 ) then status_ok = . false . exit end if end do if ( status_ok ) then call string_to_integer ( token , ival , status_ok ) if ( status_ok ) status_ok = ival > 0 ! assuming 1-based array indices end if if ( status_ok ) then ! have a valid integer to use as an index ! see if this element is really there: call json % get_child ( p , ival , tmp , status_ok ) if ( create . and . . not . status_ok ) then ! have to create it: if (. not .( p % var_type == json_object . or . p % var_type == json_array )) then ! we need to convert it into an array here ! (e.g., if p was also just created) ! and destroy its data to prevent a memory leak call json % convert ( p , json_array ) end if ! have to create this element ! [make it a null] ! (and any missing ones before it) do j = 1 , ival nullify ( tmp ) call json % get_child ( p , j , tmp , status_ok ) if (. not . status_ok ) then call json_value_create ( tmp ) call json % to_null ( tmp ) ! array element doesn't need a name call json % add ( p , tmp ) if ( j == ival ) created = . true . else if ( j == ival ) created = . false . end if end do status_ok = . true . else created = . false . end if if ( status_ok ) then ! found it p => tmp else ! not found call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid array index found: \"' // token // & '\" in path: ' // trim ( path )) exit end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid token: \"' // token // & '\" in path: ' // trim ( path )) exit end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path: ' // trim ( path )) exit end if end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path: ' // trim ( path )) exit end if ! set up for next token: istart = iend + 1 end do end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'expecting \"' // root // '\", found: \"' // path ( 1 : 1 ) // & '\" in path: ' // trim ( path )) end if end if if ( json % exception_thrown ) then nullify ( p ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if ! if it had to be created: if ( present ( was_created )) was_created = created else if ( present ( found )) found = . false . if ( present ( was_created )) was_created = . false . end if end subroutine json_get_by_path_jsonpath_bracket !***************************************************************************************** !***************************************************************************************** !> !  Convert an existing JSON variable `p` to a different variable type. !  The existing variable (and its children) is destroyed. It is replaced !  in the structure by a new variable of type `var_type` !  (which can be a `json_null`, `json_object` or `json_array`). ! !@note This is an internal routine used when creating variables by path. subroutine convert ( json , p , var_type ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! the variable to convert integer ( IK ), intent ( in ) :: var_type !! the variable type to convert `p` to type ( json_value ), pointer :: tmp !! temporary variable character ( kind = CK , len = :), allocatable :: name !! the name of a JSON variable logical :: convert_it !! if `p` needs to be converted convert_it = p % var_type /= var_type if ( convert_it ) then call json % info ( p , name = name ) ! get existing name select case ( var_type ) case ( json_object ) call json % create_object ( tmp , name ) case ( json_array ) call json % create_array ( tmp , name ) case ( json_null ) call json % create_null ( tmp , name ) case default call json % throw_exception ( 'Error in convert: invalid var_type value.' ) return end select call json % replace ( p , tmp , destroy = . true .) p => tmp nullify ( tmp ) end if end subroutine convert !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Returns the path to a JSON object that is part !  of a linked list structure. ! !  The path returned would be suitable for input to !  [[json_get_by_path]] and related routines. ! !@note If an error occurs (which in this case means a malformed !      JSON structure) then an exception will be thrown, unless !      `found` is present, which will be set to `false`. `path` !      will be a blank string. ! !@note If `json%path_mode/=1`, then the `use_alt_array_tokens` !      and `path_sep` inputs are ignored if present. ! !@note [http://goessner.net/articles/JsonPath/](JSONPath) (`path_mode=3`) !      does not specify whether or not the keys should be escaped (this routine !      assumes not, as does http://jsonpath.com). !      Also, we are using Fortran-style 1-based array indices, !      not 0-based, to agree with the assumption in `path_mode=1` subroutine json_get_path ( json , p , path , found , use_alt_array_tokens , path_sep ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list object character ( kind = CK , len = :), allocatable , intent ( out ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if there were no problems logical ( LK ), intent ( in ), optional :: use_alt_array_tokens !! if true, then '()' are used for array elements !! otherwise, '[]' are used [default] !! (only used if `path_mode=1`) character ( kind = CK , len = 1 ), intent ( in ), optional :: path_sep !! character to use for path separator !! (otherwise use `json%path_separator`) !! (only used if `path_mode=1`) type ( json_value ), pointer :: tmp !! for traversing the structure type ( json_value ), pointer :: element !! for traversing the structure integer ( IK ) :: var_type !! JSON variable type flag character ( kind = CK , len = :), allocatable :: name !! variable name character ( kind = CK , len = :), allocatable :: parent_name !! variable's parent name character ( kind = CK , len = max_integer_str_len ) :: istr !! for integer to string conversion !! (array indices) integer ( IK ) :: i !! counter integer ( IK ) :: n_children !! number of children for parent logical ( LK ) :: use_brackets !! to use '[]' characters for arrays logical ( LK ) :: parent_is_root !! if the parent is the root !optional input: if ( present ( use_alt_array_tokens )) then use_brackets = . not . use_alt_array_tokens else use_brackets = . true . end if if ( associated ( p )) then !traverse the structure via parents up to the root tmp => p do if (. not . associated ( tmp )) exit !finished !get info about the current variable: call json % info ( tmp , name = name ) if ( json % path_mode == 2_IK ) then name = encode_rfc6901 ( name ) end if ! if tmp a child of an object, or an element of an array if ( associated ( tmp % parent )) then !get info about the parent: call json % info ( tmp % parent , var_type = var_type ,& n_children = n_children , name = parent_name ) if ( json % path_mode == 2_IK ) then parent_name = encode_rfc6901 ( parent_name ) end if select case ( var_type ) case ( json_array ) !get array index of this element: element => tmp % parent % children do i = 1 , n_children if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_path: ' // & 'malformed JSON structure. ' ) exit end if if ( associated ( element , tmp )) then exit else element => element % next end if if ( i == n_children ) then ! it wasn't found (should never happen) call json % throw_exception ( 'Error in json_get_path: ' // & 'malformed JSON structure. ' ) exit end if end do select case ( json % path_mode ) case ( 3_IK ) ! JSONPath \"bracket-notation\" ! example: `$['key'][1]` ! [note: this uses 1-based indices] call integer_to_string ( i , int_fmt , istr ) call add_to_path ( start_array // single_quote // parent_name // & single_quote // end_array // & start_array // trim ( adjustl ( istr )) // end_array , CK_ '' ) case ( 2_IK ) ! rfc6901 call integer_to_string ( i - 1 , int_fmt , istr ) ! 0-based index call add_to_path ( parent_name // slash // trim ( adjustl ( istr ))) case ( 1_IK ) ! default call integer_to_string ( i , int_fmt , istr ) if ( use_brackets ) then call add_to_path ( parent_name // start_array // & trim ( adjustl ( istr )) // end_array , path_sep ) else call add_to_path ( parent_name // start_array_alt // & trim ( adjustl ( istr )) // end_array_alt , path_sep ) end if end select tmp => tmp % parent ! already added parent name case ( json_object ) !process parent on the next pass select case ( json % path_mode ) case ( 3_IK ) call add_to_path ( start_array // single_quote // name // & single_quote // end_array , CK_ '' ) case default call add_to_path ( name , path_sep ) end select case default call json % throw_exception ( 'Error in json_get_path: ' // & 'malformed JSON structure. ' // & 'A variable that is not an object ' // & 'or array should not have a child.' ) exit end select else !the last one: select case ( json % path_mode ) case ( 3_IK ) call add_to_path ( start_array // single_quote // name // & single_quote // end_array , CK_ '' ) case default call add_to_path ( name , path_sep ) end select end if if ( associated ( tmp % parent )) then !check if the parent is the root: parent_is_root = (. not . associated ( tmp % parent % parent )) if ( parent_is_root ) exit end if !go to parent: tmp => tmp % parent end do else call json % throw_exception ( 'Error in json_get_path: ' // & 'input pointer is not associated' ) end if !for errors, return blank string: if ( json % exception_thrown . or . . not . allocated ( path )) then path = CK_ '' else select case ( json % path_mode ) case ( 3_IK ) ! add the outer level object identifier: path = root // path case ( 2_IK ) ! add the root slash: path = slash // path end select end if !optional output: if ( present ( found )) then if ( json % exception_thrown ) then found = . false . call json % clear_exceptions () else found = . true . end if end if contains subroutine add_to_path ( str , path_sep ) !! prepend the string to the path implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! string to prepend to `path` character ( kind = CK , len =* ), intent ( in ), optional :: path_sep !! path separator (default is '.'). !! (ignored if `json%path_mode/=1`) select case ( json % path_mode ) case ( 3_IK ) ! in this case, the options are ignored if (. not . allocated ( path )) then path = str else path = str // path end if case ( 2_IK ) ! in this case, the options are ignored if (. not . allocated ( path )) then path = str else path = str // slash // path end if case ( 1_IK ) ! default path format if (. not . allocated ( path )) then path = str else if ( present ( path_sep )) then ! use user specified: path = str // path_sep // path else ! use the default: path = str // json % path_separator // path end if end if end select end subroutine add_to_path end subroutine json_get_path !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for [[json_get_path]] where \"path\" and \"path_sep\" are kind=CDK. subroutine wrap_json_get_path ( json , p , path , found , use_alt_array_tokens , path_sep ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list object character ( kind = CDK , len = :), allocatable , intent ( out ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if there were no problems logical ( LK ), intent ( in ), optional :: use_alt_array_tokens !! if true, then '()' are used for array elements !! otherwise, '[]' are used [default] character ( kind = CDK , len = 1 ), intent ( in ), optional :: path_sep !! character to use for path separator !! (default is '.') character ( kind = CK , len = :), allocatable :: ck_path !! path to the variable character ( kind = CK , len = 1 ) :: sep ! from unicode: sep = path_sep ! call the main routine: call json_get_path ( json , p , ck_path , found , use_alt_array_tokens , sep ) ! from unicode: path = ck_path end subroutine wrap_json_get_path !***************************************************************************************** !***************************************************************************************** !> !  Convert a string into an integer. ! !@note Replacement for the `parse_integer` function in the original code. function string_to_int ( json , str ) result ( ival ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival logical ( LK ) :: status_ok !! error flag if (. not . json % exception_thrown ) then ! call the core routine: call string_to_integer ( str , ival , status_ok ) if (. not . status_ok ) then ival = 0 call json % throw_exception ( 'Error in string_to_int: ' // & 'string cannot be converted to an integer: ' // & trim ( str )) end if else ival = 0 end if end function string_to_int !***************************************************************************************** !***************************************************************************************** !> !  Convert a string into a double. function string_to_dble ( json , str ) result ( rval ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ) :: rval logical ( LK ) :: status_ok !! error flag if (. not . json % exception_thrown ) then call string_to_real ( str , rval , status_ok ) if (. not . status_ok ) then !if there was an error rval = 0.0_RK call json % throw_exception ( 'Error in string_to_dble: ' // & 'string cannot be converted to a double: ' // & trim ( str )) end if else rval = 0.0_RK end if end function string_to_dble !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]]. subroutine json_get_integer ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( json % exception_thrown ) return if ( me % var_type == json_integer ) then value = me % int_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end if end if end subroutine json_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]], given the path string. subroutine json_get_integer_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_by_path]], where \"path\" is kind=CDK. subroutine wrap_json_get_integer_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get an integer vector from a [[json_value]]. subroutine json_get_integer_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_int_from_array ) contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Get an integer vector from a [[json_value]], given the path string. subroutine json_get_integer_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_integer_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_vec_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_integer_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]]. subroutine json_get_double ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( json % exception_thrown ) return if ( me % var_type == json_double ) then value = me % dbl_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end if end if end subroutine json_get_double !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]], given the path. subroutine json_get_double_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a double vector from a [[json_value]]. subroutine json_get_double_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_double_from_array ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a double vector from a [[json_value]], given the path. subroutine json_get_double_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_double_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_vec_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]]. subroutine json_get_logical ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), intent ( out ) :: value value = . false . if ( json % exception_thrown ) return if ( me % var_type == json_logical ) then value = me % log_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case default call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) end select end if end if end subroutine json_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]], given the path. subroutine json_get_logical_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a logical vector from [[json_value]]. subroutine json_get_logical_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_logical_from_array ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a logical vector from a [[json_value]], given the path. subroutine json_get_logical_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_logical_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_vec_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]]. subroutine json_get_string ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value value = CK_ '' if (. not . json % exception_thrown ) then if ( me % var_type == json_string ) then if ( allocated ( me % str_value )) then if ( json % unescaped_strings ) then ! default: it is stored already unescaped: value = me % str_value else ! return the escaped version: call escape_string ( me % str_value , value , json % escape_solidus ) end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%str_value not allocated' ) end if else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_string:' // & ' Unable to resolve value to string: ' // me % name ) else select case ( me % var_type ) case ( json_integer ) if ( allocated ( me % int_value )) then value = repeat ( ' ' , max_integer_str_len ) call integer_to_string ( me % int_value , int_fmt , value ) value = trim ( value ) else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%int_value not allocated' ) end if case ( json_double ) if ( allocated ( me % dbl_value )) then value = repeat ( ' ' , max_numeric_str_len ) call real_to_string ( me % dbl_value , json % real_fmt ,& json % compact_real , value ) value = trim ( value ) else call json % throw_exception ( 'Error in dbl_value: ' // & 'me%int_value not allocated' ) end if case ( json_logical ) if ( allocated ( me % log_value )) then if ( me % log_value ) then value = true_str else value = false_str end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%log_value not allocated' ) end if case ( json_null ) value = null_str case default call json % throw_exception ( 'Error in json_get_string: ' // & 'Unable to resolve value to characters: ' // & me % name ) end select end if end if end if end subroutine json_get_string !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]], given the path. subroutine json_get_string_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = CK_ '' if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_string_by_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . json % exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a string vector from a [[json_value(type)]]. subroutine json_get_string_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_chars_from_array ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = CK_ '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a string vector from a [[json_value(type)]], given the path. subroutine json_get_string_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_string_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_vec_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_by_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/16/2016 ! !  Get a string vector from a [[json_value(type)]]. This is an alternate !  version of [[json_get_string_vec]]. This one returns an allocatable !  length character (where the string length is the maximum length of !  any element in the array). It also returns an integer array of the !  actual sizes of the strings in the JSON structure. ! !@note This is somewhat inefficient since it does !      cycle through the array twice. ! !@warning The allocation of `vec` doesn't work with !         gfortran 4.9 or 5 due to compiler bugs subroutine json_get_alloc_string_vec ( json , me , vec , ilen ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ) :: initialized !! if the output array has been sized integer ( IK ) :: max_len !! the length of the longest string in the array ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( character ( kind = CK , len = 0 ) :: vec ( 0 )) allocate ( ilen ( 0 )) return end if end select initialized = . false . call json % string_info ( me , ilen = ilen , max_str_len = max_len ) if (. not . json % exception_thrown ) then ! now get each string using the callback function: call json % get ( me , array_callback = get_chars_from_array ) end if contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !! for getting string !size the output array: if (. not . initialized ) then ! string length long enough to hold the longest one ! Note that this doesn't work with gfortran 4.9 or 5. allocate ( character ( kind = CK , len = max_len ) :: vec ( count ) ) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval ilen ( i ) = len ( cval ) ! return the actual length deallocate ( cval ) else vec ( i ) = CK_ '' ilen ( i ) = 0 end if end subroutine get_chars_from_array end subroutine json_get_alloc_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_alloc_string_vec]] where input is the path. ! !  This is an alternate version of [[json_get_string_vec_by_path]]. !  This one returns an allocatable length character (where the string !  length is the maximum length of any element in the array). It also !  returns an integer array of the actual sizes of the strings in the !  JSON structure. ! !@note An alternative to using this routine is to use [[json_get_array]] with !      a callback function that gets the string from each element and populates !      a user-defined string type. subroutine json_get_alloc_string_vec_by_path ( json , me , path , vec , ilen , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec , ilen ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_alloc_string_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_alloc_string_vec_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_alloc_string_vec_by_path ( json , me , path , vec , ilen , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , ilen , found ) end subroutine wrap_json_get_alloc_string_vec_by_path !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied [[json_array_callback_func]] !  subroutine for each element in the array. ! !@note For integer, double, logical, and character arrays, !      higher-level routines are provided (see `get` methods), so !      this routine does not have to be used for those cases. subroutine json_get_array ( json , me , array_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me procedure ( json_array_callback_func ) :: array_callback type ( json_value ), pointer :: element !! temp variable for getting elements integer ( IK ) :: i !! counter integer ( IK ) :: count !! number of elements in the array if ( json % exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json % count ( me ) element => me % children do i = 1 , count ! callback for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_array: ' // & 'Malformed JSON linked list' ) return end if call array_callback ( json , element , i , count ) if ( json % exception_thrown ) exit element => element % next end do case default call json % throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/28/2016 ! !  Traverse a JSON structure. !  This routine calls the user-specified [[json_traverse_callback_func]] !  for each element of the structure. subroutine json_traverse ( json , p , traverse_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p procedure ( json_traverse_callback_func ) :: traverse_callback logical ( LK ) :: finished !! can be used to stop the process if (. not . json % exception_thrown ) call traverse ( p ) contains recursive subroutine traverse ( p ) !! recursive [[json_value]] traversal. implicit none type ( json_value ), pointer , intent ( in ) :: p type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children if ( json % exception_thrown ) return call traverse_callback ( json , p , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( p % var_type == json_array . or . p % var_type == json_object ) then icount = json % count ( p ) ! number of children if ( icount > 0 ) then element => p % children ! first one do i = 1 , icount ! call for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_traverse: ' // & 'Malformed JSON linked list' ) return end if call traverse ( element ) if ( finished . or . json % exception_thrown ) exit element => element % next end do end if nullify ( element ) end if end subroutine traverse end subroutine json_traverse !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied array_callback subroutine !  for each element in the array (specified by the path). subroutine json_get_array_by_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_array_by_path]], where \"path\" is kind=CDK subroutine wrap_json_get_array_by_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_by_path !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON file and populate the [[json_value]] tree. ! !### Inputs ! !  The inputs can be: ! !  * `file` & `unit` : the specified unit is used to read JSON from file. !                      [note if unit is already open, then the filename is ignored] !  * `file`          : JSON is read from file using internal unit number ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%parse(file='myfile.json', p=p) !```` ! !### History !  * Jacob Williams : 01/13/2015 : added read from string option. !  * Izaak Beekman  : 03/08/2015 : moved read from string to separate !    subroutine, and error annotation to separate subroutine. ! !@note When calling this routine, any exceptions thrown from previous !      calls will automatically be cleared. subroutine json_parse_file ( json , file , p , unit ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit !! file unit actually used integer ( IK ) :: istat !! iostat flag logical ( LK ) :: is_open !! if the file is already open logical ( LK ) :: has_duplicate !! if checking for duplicate keys character ( kind = CK , len = :), allocatable :: path !! path to any duplicate key !clear any exceptions and initialize: call json % initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call json % throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call json % parse_value ( unit = iunit , str = CK_ '' , value = p ) ! close the file if necessary close ( unit = iunit , iostat = istat ) ! check for errors: if ( json % exception_thrown ) then call json % annotate_invalid_json ( iunit , CK_ '' ) else if (. not . json % allow_duplicate_keys ) then call json % check_for_duplicate_keys ( p , has_duplicate , path = path ) if (. not . json % exception_thrown ) then if ( has_duplicate ) then call json % throw_exception ( 'Error in json_parse_file: ' // & 'Duplicate key found: ' // path ) end if end if end if end if else call json % throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON string and populate the [[json_value]] tree. ! !### See also !  * [[json_parse_file]] subroutine json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !! indicates that json data will be read from buffer logical ( LK ) :: has_duplicate !! if checking for duplicate keys character ( kind = CK , len = :), allocatable :: path !! path to any duplicate key !clear any exceptions and initialize: call json % initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = CK_ '' ! parse as a value call json % parse_value ( unit = iunit , str = str , value = p ) if ( json % exception_thrown ) then call json % annotate_invalid_json ( iunit , str ) else if (. not . json % allow_duplicate_keys ) then call json % check_for_duplicate_keys ( p , has_duplicate , path = path ) if (. not . json % exception_thrown ) then if ( has_duplicate ) then call json % throw_exception ( 'Error in json_parse_string: ' // & 'Duplicate key found: ' // path ) end if end if end if end if end subroutine json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_parse_string]], where `str` is kind=CDK. subroutine wrap_json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json % parse ( p , to_unicode ( str )) end subroutine wrap_json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Generate a warning message if there was an error parsing a JSON !  file or string. subroutine annotate_invalid_json ( json , iunit , str ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl !  If there was an error reading the file, then !   print the line where the error occurred: if ( json % exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( json % line_count , int_fmt , line_str ) call integer_to_string ( json % char_count , int_fmt , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , json % char_count - 1 ) ) // '&#94;' if ( json % line_count > 0 . and . json % char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call json % get_current_line_from_file_stream ( iunit , line ) else call json % get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , json % line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = CK_ '' end if !create the error message: json % err_message = json % err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the SEQUENTIAL version (see also [[get_current_line_from_file_stream]]). subroutine get_current_line_from_file_sequential ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line character ( kind = CK , len = seq_chunk_size ) :: chunk !! for reading line in chunks integer ( IK ) :: istat !! iostat flag integer ( IK ) :: isize !! number of characters read in read statement !initialize: line = CK_ '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = '(A)' , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= seq_chunk_size ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the STREAM version (see also [[get_current_line_from_file_sequential]]). subroutine get_current_line_from_file_stream ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c istart = json % ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = json % ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_value ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof !! end-of-file flag character ( kind = CK , len = 1 ) :: c !! character read from file (or string) #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call json % throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call json % to_object ( value ) !allocate class call json % parse_object ( unit , str , value ) case ( start_array ) ! start array call json % to_array ( value ) !allocate class call json % parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call json % push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call json % to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) #if defined __GFORTRAN__ ! write to a tmp variable because of ! a bug in 4.9 gfortran compiler. call json % parse_string ( unit , str , tmp ) value % str_value = tmp if ( allocated ( tmp )) deallocate ( tmp ) #else call json % parse_string ( unit , str , value % str_value ) #endif end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call json % parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call json % to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call json % parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call json % to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call json % parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . json % exception_thrown ) call json % to_null ( value ) ! allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call json % push_char ( c ) call json % parse_number ( unit , str , value ) case default call json % throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a logical(LK) variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_logical(p,'value',.true.) !```` subroutine json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ) :: val !! variable value character ( kind = CK , len =* ), intent ( in ) :: name !! variable name call json_value_create ( p ) call json % to_logical ( p , val , name ) end subroutine json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrapper for [[json_value_create_logical]] so `create_logical` method can !  be called with name of character kind 'DEFAULT' or 'ISO_10646' subroutine wrap_json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_logical ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an integer(IK) variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_integer(p,'value',1) !```` subroutine json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( in ) :: val character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_integer ( p , val , name ) end subroutine json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper procedure for [[json_value_create_integer]] so that `create_integer` !  method may be called with either a 'DEFAULT' or 'ISO_10646' character kind !  `name` actual argument. subroutine wrap_json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_integer ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a real(RK) variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_double(p,'value',1.0_RK) !```` subroutine json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p real ( RK ), intent ( in ) :: val character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_double ( p , val , name ) end subroutine json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_double]] so that `create_double` method !  may be called with an actual argument corresponding to the dummy argument, !  `name` that may be of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p real ( RK ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_double ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_string(p,'value','hello') !```` subroutine json_value_create_string ( json , p , val , name , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: val character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json_value_create ( p ) call json % to_string ( p , val , name , trim_str , adjustl_str ) end subroutine json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_string]] so that `create_string` method may be called !  with actual character string arguments for `name` and `val` that are BOTH of !  'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_string ( json , p , val , name , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % create_string ( p , to_unicode ( val ), to_unicode ( name ), trim_str , adjustl_str ) end subroutine wrap_json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_null(p,'value') !```` subroutine json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_null ( p , name ) end subroutine json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_null]] so that `create_null` method may be called with !  an actual argument corresponding to the dummy argument `name` that is either !  of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_null ( p , to_unicode ( name )) end subroutine wrap_json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. subroutine json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_object ( p , name ) end subroutine json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_object]] so that `create_object` method may be called !  with an actual argument corresponding to the dummy argument `name` that is of !  either 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_object ( p , to_unicode ( name )) end subroutine wrap_json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !### Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_array(p,'arrayname') !```` subroutine json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_array ( p , name ) end subroutine json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_array]] so that `create_array` method may be !  called with an actual argument, corresponding to the dummy argument `name`, !  that is either of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_array ( p , to_unicode ( name )) end subroutine wrap_json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a logical. subroutine to_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_logical allocate ( p % log_value ) if ( present ( val )) then p % log_value = val else p % log_value = . false . !default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an integer. subroutine to_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_integer allocate ( p % int_value ) if ( present ( val )) then p % int_value = val else p % int_value = 0 !default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a double. subroutine to_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p real ( RK ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_double allocate ( p % dbl_value ) if ( present ( val )) then p % dbl_value = val else p % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a string. ! !### Modified !  * Izaak Beekman : 02/24/2015 subroutine to_string ( json , p , val , name , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) character ( kind = CK , len = :), allocatable :: str !! temp string for `trim()` and/or `adjustl()` logical :: trim_string !! if the string is to be trimmed logical :: adjustl_string !! if the string is to be adjusted left !set type and value: call destroy_json_data ( p ) p % var_type = json_string if ( present ( val )) then if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if if ( trim_string . or . adjustl_string ) then str = val if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) p % str_value = str else p % str_value = val end if else p % str_value = CK_ '' ! default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a null. subroutine to_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_null !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an object. subroutine to_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_object !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an array. subroutine to_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_array !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_array !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_object ( json , unit , str , parent ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call json % throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) #else call json % parse_string ( unit , str , pair % name ) #endif if ( json % exception_thrown ) then call json % destroy ( pair ) return end if else call json % throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call json % parse_value ( unit , str , pair ) if ( json % exception_thrown ) then call json % destroy ( pair ) return else call json % add ( parent , pair ) end if else call json % throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call json % parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call json % throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_array ( json , unit , str , array ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( json % exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call json % parse_value ( unit , str , element ) if ( json % exception_thrown ) then if ( associated ( element )) call json % destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json % add ( array , element ) ! popped the next character call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then ! The file ended before array was finished: call json % throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call json % throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array !***************************************************************************************** !***************************************************************************************** !> !  Parses a string while reading a JSON file. ! !### History !  * Jacob Williams : 6/16/2014 : Added hex validation. !  * Jacob Williams : 12/3/2015 : Fixed some bugs. !  * Jacob Williams : 8/23/2015 : `string` is now returned unescaped. subroutine parse_string ( json , unit , str , string ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string !! the string (unescaped if necessary) logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. character ( kind = CK , len = :), allocatable :: string_unescaped !! temp variable character ( kind = CK , len = :), allocatable :: error_message !! for string unescaping !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . json % exception_thrown ) then !initialize: ip = 1 is_hex = . false . escape = . false . i = 0 do !get the next character from the file: call json % pop_char ( unit , str = str , eof = eof , skip_ws = . false ., popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . . not . escape ) then !end of string if ( is_hex ) call json % throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = CK_ '' is_hex = . false . else call json % throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = CK_ '' else string = string ( 1 : ip - 1 ) end if end if !string is returned unescaped: call unescape_string ( string , string_unescaped , error_message ) if ( allocated ( error_message )) then call json % throw_exception ( error_message ) else string = string_unescaped end if !cleanup: if ( allocated ( error_message )) deallocate ( error_message ) if ( allocated ( string_unescaped )) deallocate ( string_unescaped ) end if end subroutine parse_string !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. ! !  This is used to verify the strings `true`, `false`, and `null` during parsing. subroutine parse_for_chars ( json , unit , str , chars ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . json % exception_thrown ) then length = len_trim ( chars ) do i = 1 , length call json % pop_char ( unit , str = str , eof = eof , skip_ws = . false ., popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing.' ) return else if ( c /= chars ( i : i )) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character: \"' // c // '\" (expecting \"' // & chars ( i : i ) // '\")' ) return end if end do end if end subroutine parse_for_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Read a numerical value from the file (or string). !  The routine will determine if it is an integer or a double, and !  allocate the type accordingly. ! !@note Complete rewrite of the original FSON routine, which had some problems. subroutine parse_number ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer integer ( IK ) :: ip !! index to put next character !! [to speed up by reducing the number !! of character string reallocations] if (. not . json % exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call json % push_char ( c ) !string to value: if ( is_integer ) then ival = json % string_to_int ( tmp ) call json % to_integer ( value , ival ) else rval = json % string_to_dble ( tmp ) call json % to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number !***************************************************************************************** !***************************************************************************************** !> !  Get the next character from the file (or string). ! !### See also !  * [[push_char]] ! !@note This routine ignores non-printing ASCII characters !      (iachar<=31) that are in strings. recursive subroutine pop_char ( json , unit , str , skip_ws , skip_comments , eof , popped ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing !! from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a !! string) -- only used if unit=0 logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace [default False] logical ( LK ), intent ( in ), optional :: skip_comments !! to ignore comment lines [default False] logical ( LK ), intent ( out ) :: eof !! true if the end of the file has !! been reached. character ( kind = CK , len = 1 ), intent ( out ) :: popped !! the popped character returned integer ( IK ) :: ios !! `iostat` flag integer ( IK ) :: str_len !! length of `str` character ( kind = CK , len = 1 ) :: c !! a character read from the file (or string) logical ( LK ) :: ignore !! if whitespace is to be ignored logical ( LK ) :: ignore_comments !! if comment lines are to be ignored logical ( LK ) :: parsing_comment !! if we are in the process !! of parsing a comment line if (. not . json % exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if parsing_comment = . false . if (. not . present ( skip_comments )) then ignore_comments = . false . else ignore_comments = skip_comments end if do if ( json % pushed_index > 0 ) then ! there is a character pushed back on, most likely ! from the number parsing. Note: this can only occur if ! reading from a file when use_unformatted_stream=.false. c = json % pushed_char ( json % pushed_index : json % pushed_index ) json % pushed_index = json % pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = json % ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if json % ipos = json % ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( json % ipos <= str_len ) then c = str ( json % ipos : json % ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if json % ipos = json % ipos + 1 end if json % char_count = json % char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file ! no character to return json % char_count = 0 eof = . true . popped = space ! just to set a value exit else if ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record json % char_count = 0 json % line_count = json % line_count + 1 if ( ignore_comments ) parsing_comment = . false . ! done parsing this comment line cycle end if end if if ( ignore_comments . and . ( parsing_comment . or . c == json % comment_char ) ) then ! skipping the comment parsing_comment = . true . cycle else if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then ! ignoring whitespace cycle else ! return the character popped = c exit end if end do end if end subroutine pop_char !***************************************************************************************** !***************************************************************************************** !> !  Core routine. ! !### See also !  * [[pop_char]] ! !### History !  * Jacob Williams : 5/3/2015 : replaced original version of this routine. subroutine push_char ( json , c ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ), intent ( in ) :: c !! to character to push character ( kind = CK , len = max_numeric_str_len ) :: istr !! for error printing if (. not . json % exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: json % ipos = json % ipos - 1 else json % pushed_index = json % pushed_index + 1 if ( json % pushed_index > 0 . and . json % pushed_index <= len ( json % pushed_char )) then json % pushed_char ( json % pushed_index : json % pushed_index ) = c else call integer_to_string ( json % pushed_index , int_fmt , istr ) call json % throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if !character count in the current line json % char_count = json % char_count - 1 end if end subroutine push_char !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Print any error message, and then clear the exceptions. ! !@note This routine is used by the unit tests. !      It was originally in json_example.f90, and was !      moved here 2/26/2015 by Izaak Beekman. subroutine json_print_error_message ( json , io_unit ) implicit none class ( json_core ), intent ( inout ) :: json integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg !! error message logical :: status_ok !! false if there were any errors thrown !get error message: call json % check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( output_unit , '(A)' ) error_msg end if deallocate ( error_msg ) call json % clear_exceptions () end if end subroutine json_print_error_message !***************************************************************************************** !***************************************************************************************** end module json_value_module !*****************************************************************************************","title":"json_value_module.F90 – JSON-Fortran","tags":"","loc":"sourcefile/json_value_module.f90.html"},{"text":"type, public :: json_file type~~json_file~~InheritsGraph type~json_file json_file type~json_value json_value type~json_value->type~json_file p type~json_value->type~json_value children, next, parent, previous, tail type~json_core json_core type~json_core->type~json_file core Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. The json_file is the main public class that is\n  used to open a file and get data from it. A json_file contains only two items: an instance of a json_core ,\n  which use used for all data manipulation, and a json_value ,\n  which is used to construct the linked-list data structure.\n  Note that most methods in the json_file class are simply wrappers\n  to the lower-level routines in the json_value_module . Example program test use json_module implicit none type ( json_file ) :: json integer :: ival real ( real64 ) :: rval character ( len = :), allocatable :: cval logical :: found call json % initialize ( compact_reals = . true .) call json % load_file ( filename = 'myfile.json' ) call json % print_file () !print to the console call json % get ( 'var.i' , ival , found ) call json % get ( 'var.r(3)' , rval , found ) call json % get ( 'var.c' , cval , found ) call json % destroy () end program test Variables core p Constructor json_file Type-Bound Procedures add check_for_errors clear_exceptions destroy failed get get_core info initialize initialize_json_core_in_file json_file_add_double json_file_add_double_vec json_file_add_integer json_file_add_integer_vec json_file_add_logical json_file_add_logical_vec json_file_add_object json_file_add_string json_file_add_string_vec json_file_get_alloc_string_vec json_file_get_double json_file_get_double_vec json_file_get_integer json_file_get_integer_vec json_file_get_logical json_file_get_logical_vec json_file_get_object json_file_get_root json_file_get_string json_file_get_string_vec json_file_load_from_string json_file_print_1 json_file_print_2 json_file_print_to_console json_file_rename json_file_update_integer json_file_update_logical json_file_update_real json_file_update_string json_file_valid_path json_file_valid_path_op json_file_variable_info json_file_variable_matrix_info load_file load_from_string matrix_info move operator(.in.) print_error_message print_file print_to_string rename set_json_core_in_file traverse update valid_path Source Code json_file Components Type Visibility Attributes Name Initial type( json_core ), private :: core The instance of the json_core factory used for this file. type( json_value ), private, pointer :: p => null() the JSON structure read from the file Constructor public interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(file_object) Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_file ) private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Type-Bound Procedures generic, public :: add => json_file_add_object , json_file_add_integer , json_file_add_double , json_file_add_logical , json_file_add_string , json_file_add_integer_vec , json_file_add_double_vec , json_file_add_logical_vec , json_file_add_string_vec Add a variable to a json_file , by specifying the path. Example program test use json_module , rk => json_rk , ik => json_ik implicit none type ( json_file ) :: f call f % initialize () ! specify whatever init options you want. call f % add ( 'inputs.t' , 0.0_rk ) call f % add ( 'inputs.x' , [ 1.0_rk , 2.0_rk , 3.0_rk ]) call f % add ( 'inputs.flag' , . true .) call f % print_file () end program test private subroutine json_file_add_object (me, path, p, found, was_created) Author Jacob Williams Add a json_value pointer to an object to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p pointer to the variable to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_integer (me, path, val, found, was_created) Author Jacob Williams Add an integer value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_double (me, path, val, found, was_created) Author Jacob Williams Add a real(RK) variable value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_logical (me, path, val, found, was_created) Author Jacob Williams Add a logical(LK) value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_string (me, path, val, found, was_created, trim_str, adjustl_str) Author Jacob Williams Add a character string to a json file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_add_integer_vec (me, path, vec, found, was_created) Author Jacob Williams Add an integer vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_double_vec (me, path, vec, found, was_created) Author Jacob Williams Add a real(RK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_logical_vec (me, path, vec, found, was_created) Author Jacob Williams Add a logical(LK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_string_vec (me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Author Jacob Williams Add a string vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) procedure, public :: check_for_errors => json_file_check_for_errors private subroutine json_file_check_for_errors (me, status_ok, error_msg) Retrieve error status and message from the class. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) procedure, public :: clear_exceptions => json_file_clear_exceptions private pure subroutine json_file_clear_exceptions (me) Clear exceptions in the class. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure, public :: destroy => json_file_destroy private subroutine json_file_destroy (me, destroy_core) Author Jacob Williams Destroy the json_value data in a json_file .\n  This must be done when the variable is no longer needed,\n  or will be reused to open a different file.\n  Otherwise a memory leak will occur. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. procedure, public :: failed => json_file_failed private pure function json_file_failed (me) result(failed) Check error status in the file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. generic, public :: get => json_file_get_object , json_file_get_integer , json_file_get_double , json_file_get_logical , json_file_get_string , json_file_get_integer_vec , json_file_get_double_vec , json_file_get_logical_vec , json_file_get_string_vec , json_file_get_alloc_string_vec , json_file_get_root Get a variable from a json_file , by specifying the path. private subroutine json_file_get_object (me, path, p, found) Author Jacob Williams Date 2/3/2014 Get a json_value pointer to an object from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_integer (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get an integer value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_double (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a real(RK) variable value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_logical (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a logical(LK) value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_string (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a character string from a json file.\n  The output val is an allocatable character string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), allocatable :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_integer_vec (me, path, vec, found) Author Jacob Williams Date 1/20/2014 Get an integer vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_double_vec (me, path, vec, found) Author Jacob Williams Date 1/19/2014 Get a real(RK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_logical_vec (me, path, vec, found) Author Jacob Williams Date 1/20/2014 Get a logical(LK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_string_vec (me, path, vec, found) Author Jacob Williams Date 1/19/2014 Get a string vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_alloc_string_vec (me, path, vec, ilen, found) Author Jacob Williams Date 12/17/2016 Get an (allocatable length) string vector from a JSON file.\n  This is just a wrapper for json_get_alloc_string_vec_by_path . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec value vector integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_root (me, p) Author Izaak Beekman Date 7/23/2015 Get a json_value pointer to the JSON file root. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable procedure, public :: get_core => get_json_core_in_file private subroutine get_json_core_in_file (me, core) Get a copy of the json_core in this json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me type( json_core ), intent(out) :: core generic, public :: info => json_file_variable_info private subroutine json_file_variable_info (me, path, found, var_type, n_children, name) Author Jacob Williams Date 2/3/2014 Returns information about a variable in a json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found the variable exists in the structure integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name generic, public :: initialize => initialize_json_core_in_file , set_json_core_in_file private subroutine initialize_json_core_in_file (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). private subroutine set_json_core_in_file (me, core) Set the json_core for this json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core procedure, public :: initialize_json_core_in_file private subroutine initialize_json_core_in_file (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). procedure, public :: json_file_add_double private subroutine json_file_add_double (me, path, val, found, was_created) Author Jacob Williams Add a real(RK) variable value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_double_vec private subroutine json_file_add_double_vec (me, path, vec, found, was_created) Author Jacob Williams Add a real(RK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_integer private subroutine json_file_add_integer (me, path, val, found, was_created) Author Jacob Williams Add an integer value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_integer_vec private subroutine json_file_add_integer_vec (me, path, vec, found, was_created) Author Jacob Williams Add an integer vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_logical private subroutine json_file_add_logical (me, path, val, found, was_created) Author Jacob Williams Add a logical(LK) value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_logical_vec private subroutine json_file_add_logical_vec (me, path, vec, found, was_created) Author Jacob Williams Add a logical(LK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_object private subroutine json_file_add_object (me, path, p, found, was_created) Author Jacob Williams Add a json_value pointer to an object to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p pointer to the variable to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, public :: json_file_add_string private subroutine json_file_add_string (me, path, val, found, was_created, trim_str, adjustl_str) Author Jacob Williams Add a character string to a json file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) procedure, public :: json_file_add_string_vec private subroutine json_file_add_string_vec (me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Author Jacob Williams Add a string vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) procedure, public :: json_file_get_alloc_string_vec private subroutine json_file_get_alloc_string_vec (me, path, vec, ilen, found) Author Jacob Williams Date 12/17/2016 Get an (allocatable length) string vector from a JSON file.\n  This is just a wrapper for json_get_alloc_string_vec_by_path . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec value vector integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_double private subroutine json_file_get_double (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a real(RK) variable value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_double_vec private subroutine json_file_get_double_vec (me, path, vec, found) Author Jacob Williams Date 1/19/2014 Get a real(RK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_integer private subroutine json_file_get_integer (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get an integer value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_integer_vec private subroutine json_file_get_integer_vec (me, path, vec, found) Author Jacob Williams Date 1/20/2014 Get an integer vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_logical private subroutine json_file_get_logical (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a logical(LK) value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_logical_vec private subroutine json_file_get_logical_vec (me, path, vec, found) Author Jacob Williams Date 1/20/2014 Get a logical(LK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_object private subroutine json_file_get_object (me, path, p, found) Author Jacob Williams Date 2/3/2014 Get a json_value pointer to an object from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_root private subroutine json_file_get_root (me, p) Author Izaak Beekman Date 7/23/2015 Get a json_value pointer to the JSON file root. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable procedure, public :: json_file_get_string private subroutine json_file_get_string (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a character string from a json file.\n  The output val is an allocatable character string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), allocatable :: val value logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_string_vec private subroutine json_file_get_string_vec (me, path, vec, found) Author Jacob Williams Date 1/19/2014 Get a string vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec value vector logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_load_from_string private subroutine json_file_load_from_string (me, str) Author Jacob Williams Date 1/13/2015 Load the JSON data from a string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from procedure, public :: json_file_print_1 private subroutine json_file_print_1 (me, iunit) Author Jacob Williams Date 12/9/2013 Prints the JSON file to the specified file unit number. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) procedure, public :: json_file_print_2 private subroutine json_file_print_2 (me, filename) Author Jacob Williams Date 1/11/2015 Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to procedure, public :: json_file_print_to_console private subroutine json_file_print_to_console (me) Author Jacob Williams Date 1/11/2015 Print the JSON file to the console. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure, public :: json_file_rename private subroutine json_file_rename (me, path, name, found) Author Jacob Williams Rename a variable in a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found procedure, public :: json_file_update_integer private subroutine json_file_update_integer (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_update_logical private subroutine json_file_update_logical (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_update_real private subroutine json_file_update_real (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_update_string private subroutine json_file_update_string (me, path, val, found, trim_str, adjustl_str) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) procedure, public :: json_file_valid_path private function json_file_valid_path (me, path) result(found) Author Jacob Williams Returns true if the path is present in the JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable Return Value logical(kind=LK) if the variable was found procedure, public, pass(me) :: json_file_valid_path_op private function json_file_valid_path_op (path, me) result(found) Author Jacob Williams A wrapper for json_file_valid_path for the .in. operator Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: path the path to the variable class( json_file ), intent(in) :: me the JSON file Return Value logical(kind=LK) if the variable was found procedure, public :: json_file_variable_info private subroutine json_file_variable_info (me, path, found, var_type, n_children, name) Author Jacob Williams Date 2/3/2014 Returns information about a variable in a json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found the variable exists in the structure integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, public :: json_file_variable_matrix_info private subroutine json_file_variable_matrix_info (me, path, is_matrix, found, var_type, n_sets, set_size, name) Author Jacob Williams Date 6/26/2016 Returns matrix information about a variable in a json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, public :: load_file => json_file_load private subroutine json_file_load (me, filename, unit) Author Jacob Williams Date 12/9/2013 Load the JSON data from a file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use\n (if not present, a newunit\n is used) generic, public :: load_from_string => json_file_load_from_string private subroutine json_file_load_from_string (me, str) Author Jacob Williams Date 1/13/2015 Load the JSON data from a string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from generic, public :: matrix_info => json_file_variable_matrix_info private subroutine json_file_variable_matrix_info (me, path, is_matrix, found, var_type, n_sets, set_size, name) Author Jacob Williams Date 6/26/2016 Returns matrix information about a variable in a json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, public :: move => json_file_move_pointer private subroutine json_file_move_pointer (to, from) Author Jacob Williams Date 12/5/2014 Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from generic, public :: operator(.in.) => json_file_valid_path_op private function json_file_valid_path_op (path, me) result(found) Author Jacob Williams A wrapper for json_file_valid_path for the .in. operator Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: path the path to the variable class( json_file ), intent(in) :: me the JSON file Return Value logical(kind=LK) if the variable was found procedure, public :: print_error_message => json_file_print_error_message private subroutine json_file_print_error_message (me, io_unit) This is a wrapper for json_print_error_message . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit generic, public :: print_file => json_file_print_to_console , json_file_print_1 , json_file_print_2 private subroutine json_file_print_to_console (me) Author Jacob Williams Date 1/11/2015 Print the JSON file to the console. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me private subroutine json_file_print_1 (me, iunit) Author Jacob Williams Date 12/9/2013 Prints the JSON file to the specified file unit number. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) private subroutine json_file_print_2 (me, filename) Author Jacob Williams Date 1/11/2015 Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to procedure, public :: print_to_string => json_file_print_to_string private subroutine json_file_print_to_string (me, str) Author Jacob Williams Date 1/11/2015 Print the JSON file to a string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to generic, public :: rename => json_file_rename Rename a variable, specifying it by path private subroutine json_file_rename (me, path, name, found) Author Jacob Williams Rename a variable in a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found procedure, public :: set_json_core_in_file private subroutine set_json_core_in_file (me, core) Set the json_core for this json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core procedure, public :: traverse => json_file_traverse private subroutine json_file_traverse (me, traverse_callback) Author Jacob Williams Date 6/11/2016 Traverse the JSON structure in the file.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure( json_traverse_callback_func ) :: traverse_callback generic, public :: update => json_file_update_integer , json_file_update_logical , json_file_update_real , json_file_update_string Update a scalar variable in a json_file ,\n  by specifying the path. Note These have been mostly supplanted by the add methods, which do a similar thing (and can be used for\n      scalars and vectors, etc.) private subroutine json_file_update_integer (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_logical (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_real (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_string (me, path, val, found, trim_str, adjustl_str) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) generic, public :: valid_path => json_file_valid_path Verify that a path is valid\n  (i.e., a variable with this path exists in the file). private function json_file_valid_path (me, path) result(found) Author Jacob Williams Returns true if the path is present in the JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable Return Value logical(kind=LK) if the variable was found Source Code type , public :: json_file private type ( json_core ) :: core !! The instance of the [[json_core(type)]] factory used for this file. type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains generic , public :: initialize => initialize_json_core_in_file ,& set_json_core_in_file procedure , public :: get_core => get_json_core_in_file procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) generic , public :: matrix_info => MAYBEWRAP ( json_file_variable_matrix_info ) !error checking: procedure , public :: failed => json_file_failed procedure , public :: print_error_message => json_file_print_error_message procedure , public :: check_for_errors => json_file_check_for_errors procedure , public :: clear_exceptions => json_file_clear_exceptions procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 !> !  Rename a variable, specifying it by path generic , public :: rename => MAYBEWRAP ( json_file_rename ) #ifdef USE_UCS4 generic , public :: rename => json_file_rename_path_ascii , & json_file_rename_name_ascii #endif !> !  Verify that a path is valid !  (i.e., a variable with this path exists in the file). generic , public :: valid_path => MAYBEWRAP ( json_file_valid_path ) !> !  Get a variable from a [[json_file(type)]], by specifying the path. generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & MAYBEWRAP ( json_file_get_alloc_string_vec ), & json_file_get_root !> !  Add a variable to a [[json_file(type)]], by specifying the path. ! !### Example ! !```fortran !  program test !  use json_module, rk=>json_rk, ik=>json_ik !  implicit none !  type(json_file) :: f !  call f%initialize()  ! specify whatever init options you want. !  call f%add('inputs.t', 0.0_rk) !  call f%add('inputs.x', [1.0_rk,2.0_rk,3.0_rk]) !  call f%add('inputs.flag', .true.) !  call f%print_file() !  end program test !``` generic , public :: add => MAYBEWRAP ( json_file_add_object ), & MAYBEWRAP ( json_file_add_integer ), & MAYBEWRAP ( json_file_add_double ), & MAYBEWRAP ( json_file_add_logical ), & MAYBEWRAP ( json_file_add_string ), & MAYBEWRAP ( json_file_add_integer_vec ), & MAYBEWRAP ( json_file_add_double_vec ), & MAYBEWRAP ( json_file_add_logical_vec ), & MAYBEWRAP ( json_file_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_file_add_string_path_ascii , & json_file_add_string_value_ascii ,& json_file_add_string_vec_path_ascii ,& json_file_add_string_vec_vec_ascii #endif !> !  Update a scalar variable in a [[json_file(type)]], !  by specifying the path. ! !@note These have been mostly supplanted by the `add` !      methods, which do a similar thing (and can be used for !      scalars and vectors, etc.) generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #endif !traverse procedure , public :: traverse => json_file_traverse ! *************************************************** ! operators ! *************************************************** generic , public :: operator (. in .) => MAYBEWRAP ( json_file_valid_path_op ) procedure , pass ( me ) :: MAYBEWRAP ( json_file_valid_path_op ) ! *************************************************** ! private routines ! *************************************************** !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !initialize procedure :: initialize_json_core_in_file procedure :: set_json_core_in_file !get info: procedure :: MAYBEWRAP ( json_file_variable_info ) procedure :: MAYBEWRAP ( json_file_variable_matrix_info ) !rename: procedure :: MAYBEWRAP ( json_file_rename ) #ifdef USE_UCS4 procedure :: json_file_rename_path_ascii procedure :: json_file_rename_name_ascii #endif !validate path: procedure :: MAYBEWRAP ( json_file_valid_path ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: MAYBEWRAP ( json_file_get_alloc_string_vec ) procedure :: json_file_get_root !add: procedure :: MAYBEWRAP ( json_file_add_object ) procedure :: MAYBEWRAP ( json_file_add_integer ) procedure :: MAYBEWRAP ( json_file_add_double ) procedure :: MAYBEWRAP ( json_file_add_logical ) procedure :: MAYBEWRAP ( json_file_add_string ) procedure :: MAYBEWRAP ( json_file_add_integer_vec ) procedure :: MAYBEWRAP ( json_file_add_double_vec ) procedure :: MAYBEWRAP ( json_file_add_logical_vec ) procedure :: MAYBEWRAP ( json_file_add_string_vec ) #ifdef USE_UCS4 procedure :: json_file_add_string_path_ascii procedure :: json_file_add_string_value_ascii procedure :: json_file_add_string_vec_path_ascii procedure :: json_file_add_string_vec_vec_ascii #endif !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file","title":"json_file – JSON-Fortran ","tags":"","loc":"type/json_file.html"},{"text":"type, public :: json_core To access the core routines for manipulation\n  of json_value pointer variables. This class allows\n  for thread safe use of the module. Usage program test use json_module implicit none type ( json_core ) :: json !<--have to declare this type ( json_value ), pointer :: p call json % create_object ( p , '' ) !create the root call json % add ( p , 'year' , 1805 ) !add some data call json % add ( p , 'value' , 1.0_RK ) !add some data call json % print ( p , 'test.json' ) !write it to a file call json % destroy ( p ) !cleanup end program test Inherited By type~~json_core~~InheritedByGraph type~json_core json_core type~json_file json_file type~json_core->type~json_file core Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables allow_comments allow_duplicate_keys case_sensitive_keys char_count comment_char compact_real compress_vectors err_message escape_solidus exception_thrown ipos is_verbose line_count no_whitespace path_mode path_separator pushed_char pushed_index real_fmt spaces_per_tab stop_on_error strict_type_checking trailing_spaces_significant unescaped_strings Constructor json_core Type-Bound Procedures add add_by_path annotate_invalid_json check_children_for_duplicate_keys check_for_duplicate_keys check_for_errors clear_exceptions clone convert count create create_array create_double create_integer create_logical create_null create_object create_string destroy destroy_json_core failed get get_child get_current_line_from_file_sequential get_current_line_from_file_stream get_next get_parent get_path get_previous get_tail info initialize insert_after is_child_of json_add_double_by_path json_add_double_vec_by_path json_add_integer_by_path json_add_integer_vec_by_path json_add_logical_by_path json_add_logical_vec_by_path json_add_member_by_path json_add_string_by_path json_add_string_vec_by_path json_create_by_path json_get_alloc_string_vec json_get_alloc_string_vec_by_path json_get_array json_get_array_by_path json_get_by_path json_get_by_path_default json_get_by_path_jsonpath_bracket json_get_by_path_rfc6901 json_get_double json_get_double_by_path json_get_double_vec json_get_double_vec_by_path json_get_integer json_get_integer_by_path json_get_integer_vec json_get_integer_vec_by_path json_get_logical json_get_logical_by_path json_get_logical_vec json_get_logical_vec_by_path json_get_path json_get_string json_get_string_by_path json_get_string_vec json_get_string_vec_by_path json_info json_info_by_path json_matrix_info json_matrix_info_by_path json_parse_file json_parse_string json_print_1 json_print_2 json_rename_by_path json_string_info json_throw_exception json_update_double json_update_integer json_update_logical json_update_string json_valid_path json_value_add_double json_value_add_double_vec json_value_add_integer json_value_add_integer_vec json_value_add_logical json_value_add_logical_vec json_value_add_member json_value_add_null json_value_add_string json_value_add_string_vec json_value_create_array json_value_create_double json_value_create_integer json_value_create_logical json_value_create_null json_value_create_object json_value_create_string json_value_destroy json_value_get_child json_value_get_child_by_index json_value_get_child_by_name json_value_insert_after json_value_insert_after_child_by_index json_value_print json_value_remove_if_present json_value_rename matrix_info name_equal name_strings_equal parse parse_array parse_for_chars parse_number parse_object parse_string parse_value pop_char print print_error_message print_to_string push_char remove remove_if_present rename replace reverse string_info string_to_dble string_to_int swap throw_exception to_array to_double to_integer to_logical to_null to_object to_string traverse update valid_path validate Source Code json_core Components Type Visibility Attributes Name Initial logical(kind=LK), private :: allow_comments = .true. if true, any comments will be ignored when\n parsing a file. The comment token is defined\n by the comment_char character variable. logical(kind=LK), private :: allow_duplicate_keys = .true. If False, then after parsing, if any\n duplicate keys are found, an error is\n thrown. A call to json_value_validate will also check for duplicates. If True\n [default] then no special checks are done logical(kind=LK), private :: case_sensitive_keys = .true. if name and path comparisons\n are case sensitive. integer(kind=IK), private :: char_count = 0 character position in the current line character(kind=CK,len=1), private :: comment_char = CK_'!' comment token when allow_comments is true.\n Examples: ' ! ' or ' # '. logical(kind=LK), private :: compact_real = .true. to use the \"compact\" form of real\n numbers for output logical(kind=LK), private :: compress_vectors = .false. If true, then arrays of integers,\n nulls, doubles, & logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary] character(kind=CK,len=:), private, allocatable :: err_message the error message logical(kind=LK), private :: escape_solidus = .false. If True then the solidus \" / \" is always escaped\n (\" \\/ \") when serializing JSON .\n If False [default], then it is not escaped.\n Note that this option does not affect parsing\n (both escaped and unescaped versions are still\n valid in all cases). logical(kind=LK), private :: exception_thrown = .false. The error flag. Will be set to true\n when an error is thrown in the class.\n Many of the methods will check this\n and return immediately if it is true. integer(kind=IK), private :: ipos = 1 for allocatable strings: next character to read logical(kind=LK), private :: is_verbose = .false. if true, all exceptions are\n immediately printed to console. integer(kind=IK), private :: line_count = 1 lines read counter logical(kind=LK), private :: no_whitespace = .false. when printing a JSON string, don't include\n non-significant spaces or line breaks.\n If true, the entire structure will be\n printed on one line. integer(kind=IK), private :: path_mode = 1_IK How the path strings are interpreted in the get_by_path routines: 1 – Default mode (see json_get_by_path_default ) 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 ) 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), private :: path_separator = dot The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Note: if path_mode/=1 then this is ignored. character(kind=CK,len=pushed_char_size), private :: pushed_char = CK_'' used when parsing\n lines in file integer(kind=IK), private :: pushed_index = 0 used when parsing lines in file character(kind=CDK,len=:), private, allocatable :: real_fmt the format string to use\n for converting real numbers to strings.\n It can be set in json_initialize ,\n and used in json_value_print If not set, then default_real_fmt is used instead. integer(kind=IK), private :: spaces_per_tab = 2 number of spaces for indenting logical(kind=LK), private :: stop_on_error = .false. if true, then the program is\n stopped immediately when an\n exception is raised. logical(kind=LK), private :: strict_type_checking = .false. if true, then no type conversions are done\n in the get routines if the actual variable\n type is different from the return type (for\n example, integer to double). logical(kind=LK), private :: trailing_spaces_significant = .false. for name and path comparisons, if trailing\n space is to be considered significant. logical(kind=LK), private :: unescaped_strings = .true. If false, then the escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. Constructor public interface json_core Structure constructor to initialize a json_core object private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(json_core_object) Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_core ) Type-Bound Procedures generic, public :: add => json_value_add_member , json_value_add_null , json_value_add_integer , json_value_add_integer_vec , json_value_add_double , json_value_add_double_vec , json_value_add_logical , json_value_add_logical_vec , json_value_add_string , json_value_add_string_vec Add objects to a linked list of json_value s. Note It might make more sense to call this add_child . private subroutine json_value_add_member (json, p, member) Adds member as a child of p . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p type( json_value ), pointer :: member the child member\n to add to p private subroutine json_value_add_null (json, p, name) Add a NULL value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name private subroutine json_value_add_integer (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add an integer value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val private subroutine json_value_add_integer_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add an integer vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value private subroutine json_value_add_double (json, p, name, val) Author Jacob Williams Date 1/19/2014 Add a real value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value private subroutine json_value_add_double_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a real vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val private subroutine json_value_add_logical (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a logical value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value private subroutine json_value_add_logical_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a logical vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value private subroutine json_value_add_string (json, p, name, val, trim_str, adjustl_str) Author Jacob Williams Date 1/19/2014 Add a character string child to the json_value variable. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private subroutine json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Author Jacob Williams Date 1/19/2014 Add an array of character strings to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element generic, public :: add_by_path => json_add_member_by_path , json_add_integer_by_path , json_add_double_by_path , json_add_logical_by_path , json_add_string_by_path , json_add_integer_vec_by_path , json_add_double_vec_by_path , json_add_logical_vec_by_path , json_add_string_vec_by_path Add variables to a json_value linked list\n  by specifying their paths. Example use , intrinsic :: iso_fortran_env , only : output_unit , wp => real64 use json_module type ( json_core ) :: json type ( json_value ) :: p call json % create_object ( p , 'root' ) ! create the root ! now add some variables using the paths: call json % add_by_path ( p , 'inputs.t' , 0.0_wp ) call json % add_by_path ( p , 'inputs.x(1)' , 10 0.0_wp ) call json % add_by_path ( p , 'inputs.x(2)' , 20 0.0_wp ) call json % print ( p , output_unit ) ! now print to console Notes This uses json_create_by_path See also The json_core%update methods. json_create_by_path private subroutine json_add_member_by_path (json, me, path, p, found, was_created) Add a new member ( json_value pointer) to a JSON structure, given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_integer_by_path (json, me, path, value, found, was_created) Add an integer value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_double_by_path (json, me, path, value, found, was_created) Add an double value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_logical_by_path (json, me, path, value, found, was_created) Add a logical value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_string_by_path (json, me, path, value, found, was_created, trim_str, adjustl_str) Add a string value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_add_integer_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_integer_by_path for adding an integer vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_double_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_double_by_path for adding a double vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_logical_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_logical_by_path for adding a logical vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_string_vec_by_path (json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper to json_add_string_by_path for adding a string vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element procedure, private :: annotate_invalid_json private subroutine annotate_invalid_json (json, iunit, str) Generate a warning message if there was an error parsing a JSON file or string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data procedure, public :: check_children_for_duplicate_keys => json_check_children_for_duplicate_keys Check a json_value object's\n children for duplicate keys private subroutine json_check_children_for_duplicate_keys (json, p, has_duplicate, name, path) Author Jacob Williams Date 8/25/2017 Checks a JSON object for duplicate child names. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p the object to search. If p is\n not a json_object , then has_duplicate will be false. logical(kind=LK), intent(out) :: has_duplicate true if there is at least\n two children have duplicate name values. character(kind=CK,len=:), intent(out), optional allocatable :: name the duplicate name\n (unallocated if no\n duplicate was found) character(kind=CK,len=:), intent(out), optional allocatable :: path the full path to the\n duplicate name\n (unallocated if no\n duplicate was found) procedure, public :: check_for_duplicate_keys => json_check_all_for_duplicate_keys Check entire JSON structure\n for duplicate keys (recursively) private subroutine json_check_all_for_duplicate_keys (json, p, has_duplicate, name, path) Author Jacob Williams Date 8/25/2017 Checks a JSON structure for duplicate child names.\n  This one recursively traverses the entire structure\n  (calling json_check_children_for_duplicate_keys recursively for each element). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p the object to search. If p is\n not a json_object , then has_duplicate will be false. logical(kind=LK), intent(out) :: has_duplicate true if there is at least\n one duplicate name key anywhere\n in the structure. character(kind=CK,len=:), intent(out), optional allocatable :: name the duplicate name\n (unallocated if no\n duplicates were found) character(kind=CK,len=:), intent(out), optional allocatable :: path the full path to the\n duplicate name\n (unallocated if no\n duplicate was found) procedure, public :: check_for_errors => json_check_for_errors check for error and get error message private subroutine json_check_for_errors (json, status_ok, error_msg) Author Jacob Williams Date 12/4/2013 Retrieve error code from the json_core .\n  This should be called after parse to check for errors.\n  If an error is thrown, before using the class again, json_initialize should be called to clean up before it is used again. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) procedure, public :: clear_exceptions => json_clear_exceptions clear exceptions private pure subroutine json_clear_exceptions (json) Author Jacob Williams Date 12/4/2013 Clear exceptions in the json_core . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json procedure, public :: clone => json_clone clone a JSON structure (deep copy) private subroutine json_clone (json, from, to) Author Jacob Williams Date 10/31/2015 Create a deep copy of a json_value linked-list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: from this is the structure to clone type( json_value ), pointer :: to the clone is put here\n (it must not already be associated) procedure, private :: convert private subroutine convert (json, p, var_type) Convert an existing JSON variable p to a different variable type.\n  The existing variable (and its children) is destroyed. It is replaced\n  in the structure by a new variable of type var_type (which can be a json_null , json_object or json_array ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p the variable to convert integer(kind=IK), intent(in) :: var_type the variable type to convert p to procedure, public :: count => json_count count the number of children private function json_count (json, p) result(count) Count the number of children. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) number of children generic, public :: create => json_create_by_path Create a json_value linked list using the\n  path to the variables. Optionally return a\n  pointer to the variable. (This will create a null variable) See also add_by_path private subroutine json_create_by_path (json, me, path, p, found, was_created) Returns the json_value pointer given the path string,\n  If necessary, by creating the variables as needed. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), optional pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if there were no errors\n (variable found or created) logical(kind=LK), intent(out), optional :: was_created true if it was actually created\n (as opposed to already being there) generic, public :: create_array => json_value_create_array Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_array ( p , 'arrayname' ) private subroutine json_value_create_array (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_double => json_value_create_double Allocate a json_value pointer and make it a double variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_double ( p , 'value' , 1.0_RK ) private subroutine json_value_create_double (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name generic, public :: create_integer => json_value_create_integer Allocate a json_value pointer and make it an integer variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_integer ( p , 42 , 'value' ) private subroutine json_value_create_integer (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name generic, public :: create_logical => json_value_create_logical Allocate a json_value pointer and make it a logical variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_logical ( p , 'value' ,. true .) private subroutine json_value_create_logical (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name generic, public :: create_null => json_value_create_null Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_null ( p , 'value' ) private subroutine json_value_create_null (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_object => json_value_create_object Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_object ( p , 'objectname' ) Note The name is not significant for the root structure or an array element.\n      In those cases, an empty string can be used. private subroutine json_value_create_object (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_string => json_value_create_string Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_string ( p , 'value' , 'foobar' ) private subroutine json_value_create_string (json, p, val, name, trim_str, adjustl_str) Author Jacob Williams Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val generic, public :: destroy => json_value_destroy , destroy_json_core Destructor routine for a json_value pointer.\n  This must be called explicitly if it is no longer needed,\n  before it goes out of scope.  Otherwise, a memory leak will result. Example Destroy the json_value pointer before the variable goes out of scope: subroutine example1 () type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_object ( p , '' ) call json % add ( p , 'year' , 2015 ) call json % print ( p ) call json % destroy ( p ) end subroutine example1 Note: it should NOT be called for a json_value pointer than has already been\n  added to another json_value structure, since doing so may render the\n  other structure invalid.  Consider the following example: subroutine example2 ( p ) type ( json_core ) :: json type ( json_value ), pointer , intent ( out ) :: p type ( json_value ), pointer :: q call json % create_object ( p , '' ) call json % add ( p , 'year' , 2015 ) call json % create_object ( q , 'q' ) call json % add ( q , 'val' , 1 ) call json % add ( p , q ) !add q to p structure ! do NOT call json%destroy(q) here, because q is ! now part of the output structure p.  p should be destroyed ! somewhere upstream by the caller of this routine. nullify ( q ) !OK, but not strictly necessary end subroutine example2 private recursive subroutine json_value_destroy (json, p, destroy_next) Author Jacob Williams Date 1/22/2014 Destroy a json_value linked-list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) private subroutine destroy_json_core (me) Author Jacob Williams Date 4/17/2016 Destructor for the json_core type. Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me procedure, private :: destroy_json_core private subroutine destroy_json_core (me) Author Jacob Williams Date 4/17/2016 Destructor for the json_core type. Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me procedure, public :: failed => json_failed check for error private pure function json_failed (json) result(failed) Author Jacob Williams Date 12/5/2013 Logical function to indicate if an exception has been thrown in a json_core . Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. generic, public :: get => json_get_by_path , json_get_integer , json_get_integer_by_path , json_get_integer_vec , json_get_integer_vec_by_path , json_get_double , json_get_double_by_path , json_get_double_vec , json_get_double_vec_by_path , json_get_logical , json_get_logical_by_path , json_get_logical_vec , json_get_logical_vec_by_path , json_get_string , json_get_string_by_path , json_get_string_vec , json_get_string_vec_by_path , json_get_alloc_string_vec , json_get_alloc_string_vec_by_path , json_get_array , json_get_array_by_path Get data from a json_value linked list. Note There are two versions (e.g. json_get_integer and json_get_integer_by_path ).\n      The first one gets the value from the json_value passed into the routine,\n      while the second one gets the value from the json_value found by parsing the\n      path.  The path version is split up into unicode and non-unicode versions. private subroutine json_get_by_path (json, me, path, p, found) Returns the json_value pointer given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specified by path logical(kind=LK), intent(out), optional :: found true if it was found private subroutine json_get_integer (json, me, value) Get an integer value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value private subroutine json_get_integer_by_path (json, me, path, value, found) Get an integer value from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_integer_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get an integer vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_integer_vec_by_path (json, me, path, vec, found) Get an integer vector from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_double (json, me, value) Get a double value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out) :: value private subroutine json_get_double_by_path (json, me, path, value, found) Get a double value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_double_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a double vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_double_vec_by_path (json, me, path, vec, found) Get a double vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_logical (json, me, value) Get a logical value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out) :: value private subroutine json_get_logical_by_path (json, me, path, value, found) Get a logical value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_logical_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a logical vector from json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_logical_vec_by_path (json, me, path, vec, found) Get a logical vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_string (json, me, value) Get a character string from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value private subroutine json_get_string_by_path (json, me, path, value, found) Get a character string from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_string_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a string vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_get_string_vec_by_path (json, me, path, vec, found) Get a string vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_alloc_string_vec (json, me, vec, ilen) Author Jacob Williams Date 12/16/2016 Get a string vector from a json_value . This is an alternate\n  version of json_get_string_vec . This one returns an allocatable\n  length character (where the string length is the maximum length of\n  any element in the array). It also returns an integer array of the\n  actual sizes of the strings in the JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array private subroutine json_get_alloc_string_vec_by_path (json, me, path, vec, ilen, found) Alternate version of json_get_alloc_string_vec where input is the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found private subroutine json_get_array (json, me, array_callback) This routine calls the user-supplied json_array_callback_func subroutine for each element in the array. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback private subroutine json_get_array_by_path (json, me, path, array_callback, found) This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found generic, public :: get_child => json_value_get_child_by_index , json_value_get_child , json_value_get_child_by_name Return a child of a json_value structure. private subroutine json_value_get_child_by_index (json, p, idx, child, found) Returns a child in the object or array given the index. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child\n (this is a 1-based Fortran\n style array index). type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). private subroutine json_value_get_child (json, p, child) Returns pointer to the first child of the object\n  (or null() if it is not associated). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), pointer :: child pointer to the child private subroutine json_value_get_child_by_name (json, p, name, child, found) Returns a child in the object or array given the name string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). procedure, private :: get_current_line_from_file_sequential private subroutine get_current_line_from_file_sequential (json, iunit, line) Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line procedure, private :: get_current_line_from_file_stream private subroutine get_current_line_from_file_stream (json, iunit, line) Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line procedure, public :: get_next => json_get_next get pointer to json_value next private subroutine json_get_next (json, p, next) Author Jacob Williams Date 10/31/2015 Returns a pointer to the next of a json_value .\n  If there is no next, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next procedure, public :: get_parent => json_get_parent get pointer to json_value parent private subroutine json_get_parent (json, p, parent) Author Jacob Williams Date 10/16/2015 Returns a pointer to the parent of a json_value .\n  If there is no parent, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent generic, public :: get_path => json_get_path get the path to a JSON variable in a structure: private subroutine json_get_path (json, p, path, found, use_alt_array_tokens, path_sep) Returns the path to a JSON object that is part\n  of a linked list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list object character(kind=CK,len=:), intent(out), allocatable :: path path to the variable logical(kind=LK), intent(out), optional :: found true if there were no problems logical(kind=LK), intent(in), optional :: use_alt_array_tokens if true, then '()' are used for array elements\n otherwise, '[]' are used [default]\n (only used if path_mode=1 ) character(kind=CK,len=1), intent(in), optional :: path_sep character to use for path separator\n (otherwise use json%path_separator )\n (only used if path_mode=1 ) procedure, public :: get_previous => json_get_previous get pointer to json_value previous private subroutine json_get_previous (json, p, previous) Author Jacob Williams Date 10/31/2015 Returns a pointer to the previous of a json_value .\n  If there is no previous, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous procedure, public :: get_tail => json_get_tail get pointer to json_value tail private subroutine json_get_tail (json, p, tail) Author Jacob Williams Date 10/31/2015 Returns a pointer to the tail of a json_value (the last child of an array of object).\n  If there is no tail, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail generic, public :: info => json_info , json_info_by_path get info about a json_value private subroutine json_info (json, p, var_type, n_children, name) Author Jacob Williams Date 2/13/2014 Returns information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_info_by_path (json, p, path, found, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, public :: initialize => json_initialize to initialize some parsing parameters private subroutine json_initialize (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Author Jacob Williams Date 12/4/2013 Initialize the json_core instance. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). generic, public :: insert_after => json_value_insert_after , json_value_insert_after_child_by_index insert a new element after an existing one,\n  updating the JSON structure accordingly private subroutine json_value_insert_after (json, p, element) Inserts element after p , and updates the JSON structure accordingly. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a value from a JSON structure\n (presumably, this is a child of\n an object or array). type( json_value ), pointer :: element the element to insert after p private subroutine json_value_insert_after_child_by_index (json, p, idx, element) Inserts element after the idx -th child of p ,\n  and updates the JSON structure accordingly. This is just\n  a wrapper for json_value_insert_after . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON object or array. integer(kind=IK), intent(in) :: idx the index of the child of p to\n insert the new element after\n (this is a 1-based Fortran\n style array index) type( json_value ), pointer :: element the element to insert procedure, public :: is_child_of => json_value_is_child_of Check if a json_value is a\n descendant of another. private function json_value_is_child_of (json, p1, p2) result(is_child_of) Author Jacob Williams Date 4/28/2016 Returns True if p2 is a descendant of p1 (i.e, a child, or a child of child, etc.) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 type( json_value ), pointer :: p2 Return Value logical(kind=LK) procedure, private :: json_add_double_by_path private subroutine json_add_double_by_path (json, me, path, value, found, was_created) Add an double value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_double_vec_by_path private subroutine json_add_double_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_double_by_path for adding a double vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_integer_by_path private subroutine json_add_integer_by_path (json, me, path, value, found, was_created) Add an integer value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_integer_vec_by_path private subroutine json_add_integer_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_integer_by_path for adding an integer vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_logical_by_path private subroutine json_add_logical_by_path (json, me, path, value, found, was_created) Add a logical value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_logical_vec_by_path private subroutine json_add_logical_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_logical_by_path for adding a logical vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_member_by_path private subroutine json_add_member_by_path (json, me, path, p, found, was_created) Add a new member ( json_value pointer) to a JSON structure, given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created procedure, private :: json_add_string_by_path private subroutine json_add_string_by_path (json, me, path, value, found, was_created, trim_str, adjustl_str) Add a string value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element procedure, private :: json_add_string_vec_by_path private subroutine json_add_string_vec_by_path (json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper to json_add_string_by_path for adding a string vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element procedure, private :: json_create_by_path private subroutine json_create_by_path (json, me, path, p, found, was_created) Returns the json_value pointer given the path string,\n  If necessary, by creating the variables as needed. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), optional pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if there were no errors\n (variable found or created) logical(kind=LK), intent(out), optional :: was_created true if it was actually created\n (as opposed to already being there) procedure, private :: json_get_alloc_string_vec private subroutine json_get_alloc_string_vec (json, me, vec, ilen) Author Jacob Williams Date 12/16/2016 Get a string vector from a json_value . This is an alternate\n  version of json_get_string_vec . This one returns an allocatable\n  length character (where the string length is the maximum length of\n  any element in the array). It also returns an integer array of the\n  actual sizes of the strings in the JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array procedure, private :: json_get_alloc_string_vec_by_path private subroutine json_get_alloc_string_vec_by_path (json, me, path, vec, ilen, found) Alternate version of json_get_alloc_string_vec where input is the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_array private subroutine json_get_array (json, me, array_callback) This routine calls the user-supplied json_array_callback_func subroutine for each element in the array. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback procedure, private :: json_get_array_by_path private subroutine json_get_array_by_path (json, me, path, array_callback, found) This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_by_path private subroutine json_get_by_path (json, me, path, p, found) Returns the json_value pointer given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specified by path logical(kind=LK), intent(out), optional :: found true if it was found procedure, private :: json_get_by_path_default private subroutine json_get_by_path_default (json, me, path, p, found, create_it, was_created) Returns the json_value pointer given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found logical(kind=LK), intent(in), optional :: create_it if a variable is not present\n in the path, then it is created.\n the leaf node is returned as\n a null json type and can be\n changed by the caller. logical(kind=LK), intent(out), optional :: was_created if create_it is true, this\n will be true if the variable\n was actually created. Otherwise\n it will be false. procedure, private :: json_get_by_path_jsonpath_bracket private subroutine json_get_by_path_jsonpath_bracket (json, me, path, p, found, create_it, was_created) Author Jacob Williams Date 9/2/2017 Returns the json_value pointer given the path string,\n  using the \" JSON Pointer\" path specification defined by the\n  JSONPath \"bracket-notation\". Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable\n (using JSONPath\n \"bracket-notation\") type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found logical(kind=LK), intent(in), optional :: create_it if a variable is not present\n in the path, then it is created.\n the leaf node is returned as\n a null json type and can be\n changed by the caller. logical(kind=LK), intent(out), optional :: was_created if create_it is true, this\n will be true if the variable\n was actually created. Otherwise\n it will be false. procedure, private :: json_get_by_path_rfc6901 private subroutine json_get_by_path_rfc6901 (json, me, path, p, found) Author Jacob Williams Date 2/4/2017 Returns the json_value pointer given the path string,\n  using the \" JSON Pointer\" path specification defined by RFC 6901. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable\n (an RFC 6901 \" JSON Pointer\") type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found procedure, private :: json_get_double private subroutine json_get_double (json, me, value) Get a double value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out) :: value procedure, private :: json_get_double_by_path private subroutine json_get_double_by_path (json, me, path, value, found) Get a double value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_double_vec private subroutine json_get_double_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a double vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec procedure, private :: json_get_double_vec_by_path private subroutine json_get_double_vec_by_path (json, me, path, vec, found) Get a double vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_integer private subroutine json_get_integer (json, me, value) Get an integer value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value procedure, private :: json_get_integer_by_path private subroutine json_get_integer_by_path (json, me, path, value, found) Get an integer value from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_integer_vec private subroutine json_get_integer_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get an integer vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec procedure, private :: json_get_integer_vec_by_path private subroutine json_get_integer_vec_by_path (json, me, path, vec, found) Get an integer vector from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_logical private subroutine json_get_logical (json, me, value) Get a logical value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out) :: value procedure, private :: json_get_logical_by_path private subroutine json_get_logical_by_path (json, me, path, value, found) Get a logical value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: value logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_logical_vec private subroutine json_get_logical_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a logical vector from json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec procedure, private :: json_get_logical_vec_by_path private subroutine json_get_logical_vec_by_path (json, me, path, vec, found) Get a logical vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_path private subroutine json_get_path (json, p, path, found, use_alt_array_tokens, path_sep) Returns the path to a JSON object that is part\n  of a linked list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list object character(kind=CK,len=:), intent(out), allocatable :: path path to the variable logical(kind=LK), intent(out), optional :: found true if there were no problems logical(kind=LK), intent(in), optional :: use_alt_array_tokens if true, then '()' are used for array elements\n otherwise, '[]' are used [default]\n (only used if path_mode=1 ) character(kind=CK,len=1), intent(in), optional :: path_sep character to use for path separator\n (otherwise use json%path_separator )\n (only used if path_mode=1 ) procedure, private :: json_get_string private subroutine json_get_string (json, me, value) Get a character string from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value procedure, private :: json_get_string_by_path private subroutine json_get_string_by_path (json, me, path, value, found) Get a character string from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found procedure, private :: json_get_string_vec private subroutine json_get_string_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a string vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec procedure, private :: json_get_string_vec_by_path private subroutine json_get_string_vec_by_path (json, me, path, vec, found) Get a string vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, private :: json_info private subroutine json_info (json, p, var_type, n_children, name) Author Jacob Williams Date 2/13/2014 Returns information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, private :: json_info_by_path private subroutine json_info_by_path (json, p, path, found, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, private :: json_matrix_info private subroutine json_matrix_info (json, p, is_matrix, var_type, n_sets, set_size, name) Author Jacob Williams Date 10/16/2015 Alternate version of json_info that returns matrix\n  information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix integer(kind=IK), intent(out), optional :: var_type variable type of data in the matrix\n (if all elements have the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, private :: json_matrix_info_by_path private subroutine json_matrix_info_by_path (json, p, path, is_matrix, found, var_type, n_sets, set_size, name) Returns matrix information about a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, private :: json_parse_file private subroutine json_parse_file (json, file, p, unit) Parse the JSON file and populate the json_value tree. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) procedure, private :: json_parse_string private subroutine json_parse_string (json, p, str) Parse the JSON string and populate the json_value tree. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data procedure, private :: json_print_1 private subroutine json_print_1 (json, p, iunit) Author Jacob Williams Date 6/20/2014 Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must\n already have been opened, can't be -1). procedure, private :: json_print_2 private subroutine json_print_2 (json, p, filename) Author Jacob Williams Date 12/23/2014 Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to\n (should not already be open) procedure, private :: json_rename_by_path private subroutine json_rename_by_path (json, me, path, name, found) Rename a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found procedure, private :: json_string_info private subroutine json_string_info (json, p, ilen, max_str_len, found) Author Jacob Williams Date 12/18/2016 Returns information about character strings returned from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional dimension(:), allocatable :: ilen if p is an array, this\n is the actual length\n of each character\n string in the array.\n if not an array, this\n is returned unallocated. integer(kind=IK), intent(out), optional :: max_str_len The maximum length required to\n hold the string representation returned\n by a call to a get routine. If a scalar,\n this is just the length of the scalar. If\n a vector, this is the maximum length of\n any element. logical(kind=LK), intent(out), optional :: found true if there were no errors.\n if not present, an error will\n throw an exception procedure, private :: json_throw_exception private subroutine json_throw_exception (json, msg) Author Jacob Williams Date 12/4/2013 Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message procedure, private :: json_update_double private subroutine json_update_double (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, private :: json_update_integer private subroutine json_update_integer (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, private :: json_update_logical private subroutine json_update_logical (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, private :: json_update_string private subroutine json_update_string (json, p, path, val, found, trim_str, adjustl_str) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) procedure, private :: json_valid_path private function json_valid_path (json, p, path) result(found) Returns true if the path is present in the p JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable Return Value logical(kind=LK) true if it was found procedure, private :: json_value_add_double private subroutine json_value_add_double (json, p, name, val) Author Jacob Williams Date 1/19/2014 Add a real value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value procedure, private :: json_value_add_double_vec private subroutine json_value_add_double_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a real vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val procedure, private :: json_value_add_integer private subroutine json_value_add_integer (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add an integer value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val procedure, private :: json_value_add_integer_vec private subroutine json_value_add_integer_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add an integer vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value procedure, private :: json_value_add_logical private subroutine json_value_add_logical (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a logical value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value procedure, private :: json_value_add_logical_vec private subroutine json_value_add_logical_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a logical vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value procedure, private :: json_value_add_member private subroutine json_value_add_member (json, p, member) Adds member as a child of p . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p type( json_value ), pointer :: member the child member\n to add to p procedure, private :: json_value_add_null private subroutine json_value_add_null (json, p, name) Add a NULL value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_add_string private subroutine json_value_add_string (json, p, name, val, trim_str, adjustl_str) Author Jacob Williams Date 1/19/2014 Add a character string child to the json_value variable. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val procedure, private :: json_value_add_string_vec private subroutine json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Author Jacob Williams Date 1/19/2014 Add an array of character strings to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element procedure, private :: json_value_create_array private subroutine json_value_create_array (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_create_double private subroutine json_value_create_double (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_create_integer private subroutine json_value_create_integer (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_create_logical private subroutine json_value_create_logical (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name procedure, private :: json_value_create_null private subroutine json_value_create_null (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_create_object private subroutine json_value_create_object (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_create_string private subroutine json_value_create_string (json, p, val, name, trim_str, adjustl_str) Author Jacob Williams Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val procedure, private :: json_value_destroy private recursive subroutine json_value_destroy (json, p, destroy_next) Author Jacob Williams Date 1/22/2014 Destroy a json_value linked-list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) procedure, private :: json_value_get_child private subroutine json_value_get_child (json, p, child) Returns pointer to the first child of the object\n  (or null() if it is not associated). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), pointer :: child pointer to the child procedure, private :: json_value_get_child_by_index private subroutine json_value_get_child_by_index (json, p, idx, child, found) Returns a child in the object or array given the index. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child\n (this is a 1-based Fortran\n style array index). type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). procedure, private :: json_value_get_child_by_name private subroutine json_value_get_child_by_name (json, p, name, child, found) Returns a child in the object or array given the name string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). procedure, private :: json_value_insert_after private subroutine json_value_insert_after (json, p, element) Inserts element after p , and updates the JSON structure accordingly. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a value from a JSON structure\n (presumably, this is a child of\n an object or array). type( json_value ), pointer :: element the element to insert after p procedure, private :: json_value_insert_after_child_by_index private subroutine json_value_insert_after_child_by_index (json, p, idx, element) Inserts element after the idx -th child of p ,\n  and updates the JSON structure accordingly. This is just\n  a wrapper for json_value_insert_after . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON object or array. integer(kind=IK), intent(in) :: idx the index of the child of p to\n insert the new element after\n (this is a 1-based Fortran\n style array index) type( json_value ), pointer :: element the element to insert procedure, private :: json_value_print private recursive subroutine json_value_print (json, p, iunit, str, indent, need_comma, colon, is_array_element, is_compressed_vector) Print the JSON structure to a string or a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element logical(kind=LK), intent(in), optional :: is_compressed_vector if True, this is an element\n from an array being printed\n on one line [default is False] procedure, private :: json_value_remove_if_present private subroutine json_value_remove_if_present (json, p, name) Author Jacob Williams Date 12/6/2014 Given the path string, remove the variable from\n  the json_value structure, if it exists. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name procedure, private :: json_value_rename private subroutine json_value_rename (json, p, name) Author Jacob Williams Date 4/29/2016 Rename a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name generic, public :: matrix_info => json_matrix_info , json_matrix_info_by_path get matrix info about a json_value private subroutine json_matrix_info (json, p, is_matrix, var_type, n_sets, set_size, name) Author Jacob Williams Date 10/16/2015 Alternate version of json_info that returns matrix\n  information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix integer(kind=IK), intent(out), optional :: var_type variable type of data in the matrix\n (if all elements have the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_matrix_info_by_path (json, p, path, is_matrix, found, var_type, n_sets, set_size, name) Returns matrix information about a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, private :: name_equal private function name_equal (json, p, name) result(is_equal) Author Jacob Williams Returns true if name is equal to p%name , using the specified\n  settings for case sensitivity and trailing whitespace. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in) :: p the json object character(kind=CK,len=*), intent(in) :: name the name to check for Return Value logical(kind=LK) true if the string are\n lexically equal procedure, private :: name_strings_equal private function name_strings_equal (json, name1, name2) result(is_equal) Author Jacob Williams Date 8/25/2017 Returns true if the name strings name1 is equal to name2 , using\n  the specified settings for case sensitivity and trailing whitespace. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: name1 the name to check character(kind=CK,len=*), intent(in) :: name2 the name to check Return Value logical(kind=LK) true if the string are\n lexically equal generic, public :: parse => json_parse_file , json_parse_string Parse the JSON file and populate the json_value tree. private subroutine json_parse_file (json, file, p, unit) Parse the JSON file and populate the json_value tree. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) private subroutine json_parse_string (json, p, str) Parse the JSON string and populate the json_value tree. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data procedure, private :: parse_array private recursive subroutine parse_array (json, unit, str, array) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: array procedure, private :: parse_for_chars private subroutine parse_for_chars (json, unit, str, chars) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. procedure, private :: parse_number private subroutine parse_number (json, unit, str, value) Author Jacob Williams Date 1/20/2014 Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: value procedure, private :: parse_object private recursive subroutine parse_object (json, unit, str, parent) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: parent the parsed object will be added as a child of this procedure, private :: parse_string private subroutine parse_string (json, unit, str, string) Parses a string while reading a JSON file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string the string (unescaped if necessary) procedure, private :: parse_value private recursive subroutine parse_value (json, unit, str, value) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), pointer :: value JSON data that is extracted procedure, private :: pop_char private recursive subroutine pop_char (json, unit, str, skip_ws, skip_comments, eof, popped) Get the next character from the file (or string). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing\n from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a\n string) – only used if unit=0 logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace [default False] logical(kind=LK), intent(in), optional :: skip_comments to ignore comment lines [default False] logical(kind=LK), intent(out) :: eof true if the end of the file has\n been reached. character(kind=CK,len=1), intent(out) :: popped the popped character returned generic, public :: print => json_print_1 , json_print_2 Print the json_value to a file. Example type ( json_core ) :: json type ( json_value ) :: p !... call json % print ( p , 'test.json' ) !this is json_print_2 private subroutine json_print_1 (json, p, iunit) Author Jacob Williams Date 6/20/2014 Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must\n already have been opened, can't be -1). private subroutine json_print_2 (json, p, filename) Author Jacob Williams Date 12/23/2014 Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to\n (should not already be open) procedure, public :: print_error_message => json_print_error_message simply routine to print error\n messages private subroutine json_print_error_message (json, io_unit) Author Jacob Williams Print any error message, and then clear the exceptions. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit procedure, public :: print_to_string => json_value_to_string Print the json_value structure to an allocatable\n string private subroutine json_value_to_string (json, p, str) Author Jacob Williams Date 2/12/2014 Print the json_value structure to an allocatable string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string procedure, private :: push_char private subroutine push_char (json, c) Core routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=1), intent(in) :: c to character to push procedure, public :: remove => json_value_remove Remove a json_value from a\n linked-list structure. private subroutine json_value_remove (json, p, destroy) Author Jacob Williams Date 9/9/2014 Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. generic, public :: remove_if_present => json_value_remove_if_present If the child variable is present, then remove it. private subroutine json_value_remove_if_present (json, p, name) Author Jacob Williams Date 12/6/2014 Given the path string, remove the variable from\n  the json_value structure, if it exists. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: rename => json_value_rename , json_rename_by_path Rename a json_value variable. private subroutine json_value_rename (json, p, name) Author Jacob Williams Date 4/29/2016 Rename a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name private subroutine json_rename_by_path (json, me, path, name, found) Rename a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found procedure, public :: replace => json_value_replace Replace a json_value in a\n linked-list structure. private subroutine json_value_replace (json, p1, p2, destroy) Replace p1 with p2 in a JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 the item to replace type( json_value ), pointer :: p2 item to take the place of p1 logical(kind=LK), intent(in), optional :: destroy Should p1 also be destroyed\n (default is True). Normally,\n this should be true to avoid\n a memory leak. procedure, public :: reverse => json_value_reverse Reverse the order of the children\n of an array of object. private subroutine json_value_reverse (json, p) Author Jacob Williams Date 4/11/2017 Reverse the order of the children of an array or object. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p generic, public :: string_info => json_string_info get string info about a json_value private subroutine json_string_info (json, p, ilen, max_str_len, found) Author Jacob Williams Date 12/18/2016 Returns information about character strings returned from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional dimension(:), allocatable :: ilen if p is an array, this\n is the actual length\n of each character\n string in the array.\n if not an array, this\n is returned unallocated. integer(kind=IK), intent(out), optional :: max_str_len The maximum length required to\n hold the string representation returned\n by a call to a get routine. If a scalar,\n this is just the length of the scalar. If\n a vector, this is the maximum length of\n any element. logical(kind=LK), intent(out), optional :: found true if there were no errors.\n if not present, an error will\n throw an exception procedure, private :: string_to_dble private function string_to_dble (json, str) result(rval) Convert a string into a double. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) procedure, private :: string_to_int private function string_to_int (json, str) result(ival) Convert a string into an integer. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) procedure, public :: swap => json_value_swap Swap two json_value pointers\n in a structure (or two different\n structures). private subroutine json_value_swap (json, p1, p2) Author Jacob Williams Date 4/26/2016 Swap two elements in a JSON structure.\n  All of the children are carried along as well. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 type( json_value ), pointer :: p2 generic, public :: throw_exception => json_throw_exception Throw an exception. private subroutine json_throw_exception (json, msg) Author Jacob Williams Date 12/4/2013 Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message procedure, private :: to_array private subroutine to_array (json, p, name) Author Jacob Williams Change the json_value variable to an array. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. procedure, private :: to_double private subroutine to_double (json, p, val, name) Author Jacob Williams Change the json_value variable to a double. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in), optional :: val if the value is also to be set\n (if not present, then 0.0_rk is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. procedure, private :: to_integer private subroutine to_integer (json, p, val, name) Author Jacob Williams Change the json_value variable to an integer. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in), optional :: val if the value is also to be set\n (if not present, then 0 is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. procedure, private :: to_logical private subroutine to_logical (json, p, val, name) Author Jacob Williams Change the json_value variable to a logical. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in), optional :: val if the value is also to be set\n (if not present, then .false. is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. procedure, private :: to_null private subroutine to_null (json, p, name) Author Jacob Williams Change the json_value variable to a null. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. procedure, private :: to_object private subroutine to_object (json, p, name) Author Jacob Williams Change the json_value variable to an object. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. procedure, private :: to_string private subroutine to_string (json, p, val, name, trim_str, adjustl_str) Author Jacob Williams Change the json_value variable to a string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: val if the value is also to be set\n (if not present, then '' is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) procedure, public :: traverse => json_traverse to traverse all elements of a JSON structure private subroutine json_traverse (json, p, traverse_callback) Author Jacob Williams Date 4/28/2016 Traverse a JSON structure.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure( json_traverse_callback_func ) :: traverse_callback generic, public :: update => json_update_logical , json_update_double , json_update_integer , json_update_string These are like the add methods, except if a variable with the\n  same path is already present, then its value is simply updated.\n  Note that currently, these only work for scalar variables.\n  These routines can also change the variable's type (but an error will be\n  thrown if the existing variable is not a scalar). See also add_by_path - this one can be used to change\n    arrays and objects to scalars if so desired. Note Unlike some routines, the found output is not optional,\n      so it doesn't present exceptions from being thrown. Note These have been mostly supplanted by the add_by_path methods, which do a similar thing (and can be used for\n      scalars and vectors, etc.) private subroutine json_update_logical (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_double (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_integer (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_string (json, p, path, val, found, trim_str, adjustl_str) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) generic, public :: valid_path => json_valid_path verify if a path is valid\n  (i.e., a variable with this path exists in the file). private function json_valid_path (json, p, path) result(found) Returns true if the path is present in the p JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable Return Value logical(kind=LK) true if it was found procedure, public :: validate => json_value_validate Check that a json_value linked\n list is valid (i.e., is properly\n constructed). This may be useful\n if it has been constructed externally. private subroutine json_value_validate (json, p, is_valid, error_msg) Author Jacob Williams Date 5/2/2016 Validate a json_value linked list by checking to make sure\n  all the pointers are properly associated, arrays and objects\n  have the correct number of children, and the correct data is\n  allocated for the variable types. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), intent(out), allocatable :: error_msg if not valid, this will contain\n a description of the problem Source Code type , public :: json_core private integer ( IK ) :: spaces_per_tab = 2 !! number of spaces for indenting logical ( LK ) :: compact_real = . true . !! to use the \"compact\" form of real !! numbers for output character ( kind = CDK , len = :), allocatable :: real_fmt !! the format string to use !! for converting real numbers to strings. !! It can be set in [[json_initialize]], !! and used in [[json_value_print]] !! If not set, then `default_real_fmt` !! is used instead. logical ( LK ) :: is_verbose = . false . !! if true, all exceptions are !! immediately printed to console. logical ( LK ) :: stop_on_error = . false . !! if true, then the program is !! stopped immediately when an !! exception is raised. logical ( LK ) :: exception_thrown = . false . !! The error flag. Will be set to true !! when an error is thrown in the class. !! Many of the methods will check this !! and return immediately if it is true. character ( kind = CK , len = :), allocatable :: err_message !! the error message integer ( IK ) :: char_count = 0 !! character position in the current line integer ( IK ) :: line_count = 1 !! lines read counter integer ( IK ) :: pushed_index = 0 !! used when parsing lines in file character ( kind = CK , len = pushed_char_size ) :: pushed_char = CK_ '' !! used when parsing !! lines in file integer ( IK ) :: ipos = 1 !! for allocatable strings: next character to read logical ( LK ) :: strict_type_checking = . false . !! if true, then no type conversions are done !! in the `get` routines if the actual variable !! type is different from the return type (for !! example, integer to double). logical ( LK ) :: trailing_spaces_significant = . false . !! for name and path comparisons, if trailing !! space is to be considered significant. logical ( LK ) :: case_sensitive_keys = . true . !! if name and path comparisons !! are case sensitive. logical ( LK ) :: no_whitespace = . false . !! when printing a JSON string, don't include !! non-significant spaces or line breaks. !! If true, the entire structure will be !! printed on one line. logical ( LK ) :: unescaped_strings = . true . !! If false, then the escaped !! string is returned from [[json_get_string]] !! and similar routines. If true [default], !! then the string is returned unescaped. logical ( LK ) :: allow_comments = . true . !! if true, any comments will be ignored when !! parsing a file. The comment token is defined !! by the `comment_char` character variable. character ( kind = CK , len = 1 ) :: comment_char = CK_ '!' !! comment token when !! `allow_comments` is true. !! Examples: '`!`' or '`#`'. integer ( IK ) :: path_mode = 1_IK !! How the path strings are interpreted in the !! `get_by_path` routines: !! !! * 1 -- Default mode (see [[json_get_by_path_default]]) !! * 2 -- as RFC 6901 \"JSON Pointer\" paths !!   (see [[json_get_by_path_rfc6901]]) !! * 3 -- JSONPath \"bracket-notation\" !!   see [[json_get_by_path_jsonpath_bracket]]) character ( kind = CK , len = 1 ) :: path_separator = dot !! The `path` separator to use !! in the \"default\" mode for !! the paths in the various !! `get_by_path` routines. !! Note: if `path_mode/=1` !! then this is ignored. logical ( LK ) :: compress_vectors = . false . !! If true, then arrays of integers, !! nulls, doubles, & logicals are !! printed all on one line. !! [Note: `no_whitespace` will !! override this option if necessary] logical ( LK ) :: allow_duplicate_keys = . true . !! If False, then after parsing, if any !! duplicate keys are found, an error is !! thrown. A call to [[json_value_validate]] !! will also check for duplicates. If True !! [default] then no special checks are done logical ( LK ) :: escape_solidus = . false . !! If True then the solidus \"`/`\" is always escaped !! (\"`\\/`\") when serializing JSON. !! If False [default], then it is not escaped. !! Note that this option does not affect parsing !! (both escaped and unescaped versions are still !! valid in all cases). contains private !> !  Return a child of a [[json_value]] structure. generic , public :: get_child => json_value_get_child_by_index , & json_value_get_child ,& MAYBEWRAP ( json_value_get_child_by_name ) procedure , private :: json_value_get_child_by_index procedure , private :: MAYBEWRAP ( json_value_get_child_by_name ) procedure , private :: json_value_get_child !> !  Add objects to a linked list of [[json_value]]s. ! !@note It might make more sense to call this `add_child`. generic , public :: add => json_value_add_member , & MAYBEWRAP ( json_value_add_null ), & MAYBEWRAP ( json_value_add_integer ), & MAYBEWRAP ( json_value_add_integer_vec ), & MAYBEWRAP ( json_value_add_double ), & MAYBEWRAP ( json_value_add_double_vec ), & MAYBEWRAP ( json_value_add_logical ), & MAYBEWRAP ( json_value_add_logical_vec ), & MAYBEWRAP ( json_value_add_string ), & MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_value_add_string_name_ascii , & json_value_add_string_val_ascii , & json_value_add_string_vec_name_ascii , & json_value_add_string_vec_val_ascii #endif procedure , private :: json_value_add_member procedure , private :: MAYBEWRAP ( json_value_add_integer ) procedure , private :: MAYBEWRAP ( json_value_add_null ) procedure , private :: MAYBEWRAP ( json_value_add_integer_vec ) procedure , private :: MAYBEWRAP ( json_value_add_double ) procedure , private :: MAYBEWRAP ( json_value_add_double_vec ) procedure , private :: MAYBEWRAP ( json_value_add_logical ) procedure , private :: MAYBEWRAP ( json_value_add_logical_vec ) procedure , private :: MAYBEWRAP ( json_value_add_string ) procedure , private :: MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 procedure , private :: json_value_add_string_name_ascii procedure , private :: json_value_add_string_val_ascii procedure , private :: json_value_add_string_vec_name_ascii procedure , private :: json_value_add_string_vec_val_ascii #endif !> !  These are like the `add` methods, except if a variable with the !  same path is already present, then its value is simply updated. !  Note that currently, these only work for scalar variables. !  These routines can also change the variable's type (but an error will be !  thrown if the existing variable is not a scalar). ! !### See also !  * [[json_core(type):add_by_path]] - this one can be used to change !    arrays and objects to scalars if so desired. ! !@note Unlike some routines, the `found` output is not optional, !      so it doesn't present exceptions from being thrown. ! !@note These have been mostly supplanted by the [[json_core(type):add_by_path]] !      methods, which do a similar thing (and can be used for !      scalars and vectors, etc.) generic , public :: update => MAYBEWRAP ( json_update_logical ),& MAYBEWRAP ( json_update_double ),& MAYBEWRAP ( json_update_integer ),& MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 generic , public :: update => json_update_string_name_ascii ,& json_update_string_val_ascii #endif procedure , private :: MAYBEWRAP ( json_update_logical ) procedure , private :: MAYBEWRAP ( json_update_double ) procedure , private :: MAYBEWRAP ( json_update_integer ) procedure , private :: MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 procedure , private :: json_update_string_name_ascii procedure , private :: json_update_string_val_ascii #endif !> !  Add variables to a [[json_value]] linked list !  by specifying their paths. ! !### Example ! !````fortran !    use, intrinsic :: iso_fortran_env, only: output_unit, wp=>real64 !    use json_module !    type(json_core) :: json !    type(json_value) :: p !    call json%create_object(p,'root') ! create the root !    ! now add some variables using the paths: !    call json%add_by_path(p,'inputs.t',    0.0_wp  ) !    call json%add_by_path(p,'inputs.x(1)', 100.0_wp) !    call json%add_by_path(p,'inputs.x(2)', 200.0_wp) !    call json%print(p,output_unit)  ! now print to console !```` ! !### Notes !  * This uses [[json_create_by_path]] ! !### See also !  * The `json_core%update` methods. !  * [[json_create_by_path]] generic , public :: add_by_path => MAYBEWRAP ( json_add_member_by_path ),& MAYBEWRAP ( json_add_integer_by_path ),& MAYBEWRAP ( json_add_double_by_path ),& MAYBEWRAP ( json_add_logical_by_path ),& MAYBEWRAP ( json_add_string_by_path ),& MAYBEWRAP ( json_add_integer_vec_by_path ),& MAYBEWRAP ( json_add_double_vec_by_path ),& MAYBEWRAP ( json_add_logical_vec_by_path ),& MAYBEWRAP ( json_add_string_vec_by_path ) #ifdef USE_UCS4 generic , public :: add_by_path => json_add_string_by_path_value_ascii ,& json_add_string_by_path_path_ascii ,& json_add_string_vec_by_path_value_ascii ,& json_add_string_vec_by_path_path_ascii #endif procedure :: MAYBEWRAP ( json_add_member_by_path ) procedure :: MAYBEWRAP ( json_add_integer_by_path ) procedure :: MAYBEWRAP ( json_add_double_by_path ) procedure :: MAYBEWRAP ( json_add_logical_by_path ) procedure :: MAYBEWRAP ( json_add_string_by_path ) procedure :: MAYBEWRAP ( json_add_integer_vec_by_path ) procedure :: MAYBEWRAP ( json_add_double_vec_by_path ) procedure :: MAYBEWRAP ( json_add_logical_vec_by_path ) procedure :: MAYBEWRAP ( json_add_string_vec_by_path ) #ifdef USE_UCS4 procedure :: json_add_string_by_path_value_ascii procedure :: json_add_string_by_path_path_ascii procedure :: json_add_string_vec_by_path_value_ascii procedure :: json_add_string_vec_by_path_path_ascii #endif !> !  Create a [[json_value]] linked list using the !  path to the variables. Optionally return a !  pointer to the variable. ! !  (This will create a `null` variable) ! !### See also !  * [[json_core(type):add_by_path]] generic , public :: create => MAYBEWRAP ( json_create_by_path ) procedure :: MAYBEWRAP ( json_create_by_path ) !> !  Get data from a [[json_value]] linked list. ! !@note There are two versions (e.g. [[json_get_integer]] and [[json_get_integer_by_path]]). !      The first one gets the value from the [[json_value]] passed into the routine, !      while the second one gets the value from the [[json_value]] found by parsing the !      path.  The path version is split up into unicode and non-unicode versions. generic , public :: get => & MAYBEWRAP ( json_get_by_path ), & json_get_integer , MAYBEWRAP ( json_get_integer_by_path ), & json_get_integer_vec , MAYBEWRAP ( json_get_integer_vec_by_path ), & json_get_double , MAYBEWRAP ( json_get_double_by_path ), & json_get_double_vec , MAYBEWRAP ( json_get_double_vec_by_path ), & json_get_logical , MAYBEWRAP ( json_get_logical_by_path ), & json_get_logical_vec , MAYBEWRAP ( json_get_logical_vec_by_path ), & json_get_string , MAYBEWRAP ( json_get_string_by_path ), & json_get_string_vec , MAYBEWRAP ( json_get_string_vec_by_path ), & json_get_alloc_string_vec , MAYBEWRAP ( json_get_alloc_string_vec_by_path ),& json_get_array , MAYBEWRAP ( json_get_array_by_path ) procedure , private :: json_get_integer procedure , private :: json_get_integer_vec procedure , private :: json_get_double procedure , private :: json_get_double_vec procedure , private :: json_get_logical procedure , private :: json_get_logical_vec procedure , private :: json_get_string procedure , private :: json_get_string_vec procedure , private :: json_get_alloc_string_vec procedure , private :: json_get_array procedure , private :: MAYBEWRAP ( json_get_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_double_by_path ) procedure , private :: MAYBEWRAP ( json_get_double_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_logical_by_path ) procedure , private :: MAYBEWRAP ( json_get_logical_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_string_by_path ) procedure , private :: MAYBEWRAP ( json_get_string_vec_by_path ) procedure , private :: MAYBEWRAP ( json_get_array_by_path ) procedure , private :: MAYBEWRAP ( json_get_alloc_string_vec_by_path ) procedure , private :: json_get_by_path_default procedure , private :: json_get_by_path_rfc6901 procedure , private :: json_get_by_path_jsonpath_bracket procedure , public :: print_to_string => json_value_to_string !! Print the [[json_value]] !! structure to an allocatable !! string !> !  Print the [[json_value]] to a file. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value) :: p !    !... !    call json%print(p,'test.json')  !this is [[json_print_2]] !```` generic , public :: print => json_print_1 , json_print_2 procedure :: json_print_1 procedure :: json_print_2 !> !  Destructor routine for a [[json_value]] pointer. !  This must be called explicitly if it is no longer needed, !  before it goes out of scope.  Otherwise, a memory leak will result. ! !### Example ! !  Destroy the [[json_value]] pointer before the variable goes out of scope: !````fortran !     subroutine example1() !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%print(p) !     call json%destroy(p) !     end subroutine example1 !```` ! !  Note: it should NOT be called for a [[json_value]] pointer than has already been !  added to another [[json_value]] structure, since doing so may render the !  other structure invalid.  Consider the following example: !````fortran !     subroutine example2(p) !     type(json_core) :: json !     type(json_value),pointer,intent(out) :: p !     type(json_value),pointer :: q !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%create_object(q,'q') !     call json%add(q,'val',1) !     call json%add(p, q)  !add q to p structure !     ! do NOT call json%destroy(q) here, because q is !     ! now part of the output structure p.  p should be destroyed !     ! somewhere upstream by the caller of this routine. !     nullify(q) !OK, but not strictly necessary !     end subroutine example2 !```` generic , public :: destroy => json_value_destroy , destroy_json_core procedure :: json_value_destroy procedure :: destroy_json_core !> !  If the child variable is present, then remove it. generic , public :: remove_if_present => MAYBEWRAP ( json_value_remove_if_present ) procedure :: MAYBEWRAP ( json_value_remove_if_present ) !> !  Allocate a [[json_value]] pointer and make it a double variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_double(p,'value',1.0_RK) !```` generic , public :: create_double => MAYBEWRAP ( json_value_create_double ) procedure :: MAYBEWRAP ( json_value_create_double ) !> !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_array(p,'arrayname') !```` generic , public :: create_array => MAYBEWRAP ( json_value_create_array ) procedure :: MAYBEWRAP ( json_value_create_array ) !> !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. generic , public :: create_object => MAYBEWRAP ( json_value_create_object ) procedure :: MAYBEWRAP ( json_value_create_object ) !> !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_null(p,'value') !```` generic , public :: create_null => MAYBEWRAP ( json_value_create_null ) procedure :: MAYBEWRAP ( json_value_create_null ) !> !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_string(p,'value','foobar') !```` generic , public :: create_string => MAYBEWRAP ( json_value_create_string ) procedure :: MAYBEWRAP ( json_value_create_string ) !> !  Allocate a json_value pointer and make it an integer variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_integer(p,42,'value') !```` generic , public :: create_integer => MAYBEWRAP ( json_value_create_integer ) procedure :: MAYBEWRAP ( json_value_create_integer ) !> !  Allocate a json_value pointer and make it a logical variable. !  The pointer should not already be allocated. ! !### Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_logical(p,'value',.true.) !```` generic , public :: create_logical => MAYBEWRAP ( json_value_create_logical ) procedure :: MAYBEWRAP ( json_value_create_logical ) !> !  Parse the JSON file and populate the [[json_value]] tree. generic , public :: parse => json_parse_file , MAYBEWRAP ( json_parse_string ) procedure :: json_parse_file procedure :: MAYBEWRAP ( json_parse_string ) !> !  Throw an exception. generic , public :: throw_exception => MAYBEWRAP ( json_throw_exception ) procedure :: MAYBEWRAP ( json_throw_exception ) !> !  Rename a [[json_value]] variable. generic , public :: rename => MAYBEWRAP ( json_value_rename ),& MAYBEWRAP ( json_rename_by_path ) procedure :: MAYBEWRAP ( json_value_rename ) procedure :: MAYBEWRAP ( json_rename_by_path ) #ifdef USE_UCS4 generic , public :: rename => json_rename_by_path_name_ascii ,& json_rename_by_path_path_ascii procedure :: json_rename_by_path_name_ascii procedure :: json_rename_by_path_path_ascii #endif !> !  get info about a [[json_value]] generic , public :: info => json_info , MAYBEWRAP ( json_info_by_path ) procedure :: json_info procedure :: MAYBEWRAP ( json_info_by_path ) !> !  get string info about a [[json_value]] generic , public :: string_info => json_string_info procedure :: json_string_info !> !  get matrix info about a [[json_value]] generic , public :: matrix_info => json_matrix_info , MAYBEWRAP ( json_matrix_info_by_path ) procedure :: json_matrix_info procedure :: MAYBEWRAP ( json_matrix_info_by_path ) !> !  insert a new element after an existing one, !  updating the JSON structure accordingly generic , public :: insert_after => json_value_insert_after , & json_value_insert_after_child_by_index procedure :: json_value_insert_after procedure :: json_value_insert_after_child_by_index !> !  get the path to a JSON variable in a structure: generic , public :: get_path => MAYBEWRAP ( json_get_path ) procedure :: MAYBEWRAP ( json_get_path ) !> !  verify if a path is valid !  (i.e., a variable with this path exists in the file). generic , public :: valid_path => MAYBEWRAP ( json_valid_path ) procedure :: MAYBEWRAP ( json_valid_path ) procedure , public :: remove => json_value_remove !! Remove a [[json_value]] from a !! linked-list structure. procedure , public :: replace => json_value_replace !! Replace a [[json_value]] in a !! linked-list structure. procedure , public :: reverse => json_value_reverse !! Reverse the order of the children !! of an array of object. procedure , public :: check_for_errors => json_check_for_errors !! check for error and get error message procedure , public :: clear_exceptions => json_clear_exceptions !! clear exceptions procedure , public :: count => json_count !! count the number of children procedure , public :: clone => json_clone !! clone a JSON structure (deep copy) procedure , public :: failed => json_failed !! check for error procedure , public :: get_parent => json_get_parent !! get pointer to json_value parent procedure , public :: get_next => json_get_next !! get pointer to json_value next procedure , public :: get_previous => json_get_previous !! get pointer to json_value previous procedure , public :: get_tail => json_get_tail !! get pointer to json_value tail procedure , public :: initialize => json_initialize !! to initialize some parsing parameters procedure , public :: traverse => json_traverse !! to traverse all elements of a JSON !! structure procedure , public :: print_error_message => json_print_error_message !! simply routine to print error !! messages procedure , public :: swap => json_value_swap !! Swap two [[json_value]] pointers !! in a structure (or two different !! structures). procedure , public :: is_child_of => json_value_is_child_of !! Check if a [[json_value]] is a !! descendant of another. procedure , public :: validate => json_value_validate !! Check that a [[json_value]] linked !! list is valid (i.e., is properly !! constructed). This may be useful !! if it has been constructed externally. procedure , public :: check_for_duplicate_keys & => json_check_all_for_duplicate_keys !! Check entire JSON structure !! for duplicate keys (recursively) procedure , public :: check_children_for_duplicate_keys & => json_check_children_for_duplicate_keys !! Check a `json_value` object's !! children for duplicate keys !other private routines: procedure :: name_equal procedure :: name_strings_equal procedure :: json_value_print procedure :: string_to_int procedure :: string_to_dble procedure :: parse_value procedure :: parse_number procedure :: parse_string procedure :: parse_for_chars procedure :: parse_object procedure :: parse_array procedure :: annotate_invalid_json procedure :: pop_char procedure :: push_char procedure :: get_current_line_from_file_stream procedure :: get_current_line_from_file_sequential procedure :: convert procedure :: to_string procedure :: to_logical procedure :: to_integer procedure :: to_double procedure :: to_null procedure :: to_object procedure :: to_array end type json_core","title":"json_core – JSON-Fortran ","tags":"","loc":"type/json_core.html"},{"text":"type, public :: json_value sequence Type used to construct the linked-list JSON structure.\n  Normally, this should always be a pointer variable.\n  This type should only be used by an instance of json_core . Example The following test program: program test use json_module implicit none type ( json_core ) :: json type ( json_value ), pointer :: p call json % create_object ( p , '' ) !create the root call json % add ( p , 'year' , 1805 ) !add some data call json % add ( p , 'value' , 1.0_RK ) !add some data call json % print ( p , 'test.json' ) !write it to a file call json % destroy ( p ) !cleanup end program test Produces the JSON file test.json : { \"year\" : 1805 , \"value\" : 0.1E+1 } Inherited By type~~json_value~~InheritedByGraph type~json_value json_value type~json_value->type~json_value children, next, parent, previous, tail type~json_file json_file type~json_value->type~json_file p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables children dbl_value int_value log_value n_children name next parent previous str_value tail var_type Source Code json_value Components Type Visibility Attributes Name Initial type( json_value ), private, pointer :: children => null() first child item of this real(kind=RK), private, allocatable :: dbl_value real data for this variable integer(kind=IK), private, allocatable :: int_value integer data for this variable logical(kind=LK), private, allocatable :: log_value logical data for this variable integer(kind=IK), private :: n_children = 0 number of children character(kind=CK,len=:), private, allocatable :: name variable name (unescaped) type( json_value ), private, pointer :: next => null() next item in the list type( json_value ), private, pointer :: parent => null() parent item of this type( json_value ), private, pointer :: previous => null() previous item in the list character(kind=CK,len=:), private, allocatable :: str_value string data for this variable\n (unescaped) type( json_value ), private, pointer :: tail => null() last child item of this integer(kind=IK), private :: var_type = json_unknown variable type Source Code type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name (unescaped) real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable !! (unescaped) integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value","title":"json_value – JSON-Fortran ","tags":"","loc":"type/json_value.html"},{"text":"abstract interface public subroutine json_array_callback_func(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array Description Array element callback function.  Used by json_get_array","title":"json_array_callback_func – JSON-Fortran","tags":"","loc":"interface/json_array_callback_func.html"},{"text":"abstract interface public subroutine json_traverse_callback_func(json, p, finished) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: finished set true to stop traversing Description Callback function used by json_traverse","title":"json_traverse_callback_func – JSON-Fortran","tags":"","loc":"interface/json_traverse_callback_func.html"},{"text":"private function initialize_json_file(p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(file_object) Cast a json_value object as a json_file object.\n  It also calls the initialize() method. Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys If True [default] then no special checks\n   are done to check for duplicate keys. If False, then after parsing, if any duplicate\n   keys are found, an error is thrown. A call to json_value_validate will also check for\n   duplicates. logical(kind=LK), intent(in), optional :: escape_solidus If True then the solidus \" / \" is always escaped\n   \" \\/ \" when serializing JSON If False [default], then it is not escaped.\n Note that this option does not affect parsing\n (both escaped and unescaped are still valid in\n all cases). logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_file ) Called By proc~~initialize_json_file~~CalledByGraph proc~initialize_json_file initialize_json_file interface~json_file json_file interface~json_file->proc~initialize_json_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_json_file Source Code function initialize_json_file ( p , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object #include \"json_initialize_arguments.inc\" call file_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) if ( present ( p )) file_object % p => p end function initialize_json_file","title":"initialize_json_file – JSON-Fortran","tags":"","loc":"proc/initialize_json_file.html"},{"text":"private function initialize_json_file_v2(json_value_object, json_core_object) result(file_object) Cast a json_value pointer and a json_core object\n  as a json_file object. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Called By proc~~initialize_json_file_v2~~CalledByGraph proc~initialize_json_file_v2 initialize_json_file_v2 interface~json_file json_file interface~json_file->proc~initialize_json_file_v2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_json_file_v2 Source Code function initialize_json_file_v2 ( json_value_object , json_core_object ) & result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , intent ( in ) :: json_value_object type ( json_core ), intent ( in ) :: json_core_object file_object % p => json_value_object file_object % core = json_core_object end function initialize_json_file_v2","title":"initialize_json_file_v2 – JSON-Fortran","tags":"","loc":"proc/initialize_json_file_v2.html"},{"text":"private pure function json_file_failed(me) result(failed) Check error status in the file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. Source Code json_file_failed Source Code pure function json_file_failed ( me ) result ( failed ) implicit none class ( json_file ), intent ( in ) :: me logical ( LK ) :: failed !! will be true if there has been an error. failed = me % core % failed () end function json_file_failed","title":"json_file_failed – JSON-Fortran","tags":"","loc":"proc/json_file_failed.html"},{"text":"private function json_file_valid_path(me, path) result(found) Returns true if the path is present in the JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable Return Value logical(kind=LK) if the variable was found Source Code json_file_valid_path Source Code function json_file_valid_path ( me , path ) result ( found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ) :: found !! if the variable was found found = me % core % valid_path ( me % p , path ) end function json_file_valid_path","title":"json_file_valid_path – JSON-Fortran","tags":"","loc":"proc/json_file_valid_path.html"},{"text":"private function json_file_valid_path_op(path, me) result(found) A wrapper for json_file_valid_path for the .in. operator Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: path the path to the variable class( json_file ), intent(in) :: me the JSON file Return Value logical(kind=LK) if the variable was found Source Code json_file_valid_path_op Source Code function json_file_valid_path_op ( path , me ) result ( found ) implicit none character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable class ( json_file ), intent ( in ) :: me !! the JSON file logical ( LK ) :: found !! if the variable was found type ( json_core ) :: core_copy !! a copy of `core` from `me` ! This is sort of a hack. Since `me` has to have `intent(in)` ! for the operator to work, we need to make a copy of `me%core` ! so we can call the low level routine (since it needs it to ! be `intent(inout)`) because it's technically possible for this ! function to raise an exception. This normally should never ! happen here unless the JSON structure is malformed. core_copy = me % core ! copy the settings (need them to know ! how to interpret the path) found = core_copy % valid_path ( me % p , path ) ! call the low-level routine call core_copy % destroy () ! just in case (but not really necessary) end function json_file_valid_path_op","title":"json_file_valid_path_op – JSON-Fortran","tags":"","loc":"proc/json_file_valid_path_op.html"},{"text":"private function wrap_json_file_valid_path(me, path) result(found) Alternate version of json_file_valid_path , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable Return Value logical(kind=LK) if the variable was found Calls proc~~wrap_json_file_valid_path~~CallsGraph proc~wrap_json_file_valid_path wrap_json_file_valid_path interface~to_unicode to_unicode proc~wrap_json_file_valid_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_valid_path Source Code function wrap_json_file_valid_path ( me , path ) result ( found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ) :: found !! if the variable was found found = me % valid_path ( to_unicode ( path )) end function wrap_json_file_valid_path","title":"wrap_json_file_valid_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_valid_path.html"},{"text":"private function wrap_json_file_valid_path_op(path, me) result(found) Alternate version of json_file_valid_path_op , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: path the path to the variable class( json_file ), intent(in) :: me the JSON file Return Value logical(kind=LK) if the variable was found Calls proc~~wrap_json_file_valid_path_op~~CallsGraph proc~wrap_json_file_valid_path_op wrap_json_file_valid_path_op interface~to_unicode to_unicode proc~wrap_json_file_valid_path_op->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_valid_path_op Source Code function wrap_json_file_valid_path_op ( path , me ) result ( found ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable class ( json_file ), intent ( in ) :: me !! the JSON file logical ( LK ) :: found !! if the variable was found found = to_unicode ( path ) . in . me end function wrap_json_file_valid_path_op","title":"wrap_json_file_valid_path_op – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_valid_path_op.html"},{"text":"private subroutine get_json_core_in_file(me, core) Get a copy of the json_core in this json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me type( json_core ), intent(out) :: core Source Code get_json_core_in_file Source Code subroutine get_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( in ) :: me type ( json_core ), intent ( out ) :: core core = me % core end subroutine get_json_core_in_file","title":"get_json_core_in_file – JSON-Fortran","tags":"","loc":"proc/get_json_core_in_file.html"},{"text":"private subroutine initialize_json_core_in_file(me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . Note : This does not destroy the data in the file. Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys If True [default] then no special checks\n   are done to check for duplicate keys. If False, then after parsing, if any duplicate\n   keys are found, an error is thrown. A call to json_value_validate will also check for\n   duplicates. logical(kind=LK), intent(in), optional :: escape_solidus If True then the solidus \" / \" is always escaped\n   \" \\/ \" when serializing JSON If False [default], then it is not escaped.\n Note that this option does not affect parsing\n (both escaped and unescaped are still valid in\n all cases). logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Source Code initialize_json_core_in_file Source Code subroutine initialize_json_core_in_file ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) implicit none class ( json_file ), intent ( inout ) :: me #include \"json_initialize_arguments.inc\" call me % core % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) end subroutine initialize_json_core_in_file","title":"initialize_json_core_in_file – JSON-Fortran","tags":"","loc":"proc/initialize_json_core_in_file.html"},{"text":"private subroutine json_file_add_double(me, path, val, found, was_created) Add a real(RK) variable value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_double Source Code subroutine json_file_add_double ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created ) end subroutine json_file_add_double","title":"json_file_add_double – JSON-Fortran","tags":"","loc":"proc/json_file_add_double.html"},{"text":"private subroutine json_file_add_double_vec(me, path, vec, found, was_created) Add a real(RK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_double_vec Source Code subroutine json_file_add_double_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created ) end subroutine json_file_add_double_vec","title":"json_file_add_double_vec – JSON-Fortran","tags":"","loc":"proc/json_file_add_double_vec.html"},{"text":"private subroutine json_file_add_integer(me, path, val, found, was_created) Add an integer value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_integer Source Code subroutine json_file_add_integer ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created ) end subroutine json_file_add_integer","title":"json_file_add_integer – JSON-Fortran","tags":"","loc":"proc/json_file_add_integer.html"},{"text":"private subroutine json_file_add_integer_vec(me, path, vec, found, was_created) Add an integer vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_integer_vec Source Code subroutine json_file_add_integer_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created ) end subroutine json_file_add_integer_vec","title":"json_file_add_integer_vec – JSON-Fortran","tags":"","loc":"proc/json_file_add_integer_vec.html"},{"text":"private subroutine json_file_add_logical(me, path, val, found, was_created) Add a logical(LK) value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_logical Source Code subroutine json_file_add_logical ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created ) end subroutine json_file_add_logical","title":"json_file_add_logical – JSON-Fortran","tags":"","loc":"proc/json_file_add_logical.html"},{"text":"private subroutine json_file_add_logical_vec(me, path, vec, found, was_created) Add a logical(LK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_logical_vec Source Code subroutine json_file_add_logical_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created ) end subroutine json_file_add_logical_vec","title":"json_file_add_logical_vec – JSON-Fortran","tags":"","loc":"proc/json_file_add_logical_vec.html"},{"text":"private subroutine json_file_add_object(me, path, p, found, was_created) Add a json_value pointer to an object to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p pointer to the variable to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_file_add_object Source Code subroutine json_file_add_object ( me , path , p , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! pointer to the variable to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , p , found , was_created ) end subroutine json_file_add_object","title":"json_file_add_object – JSON-Fortran","tags":"","loc":"proc/json_file_add_object.html"},{"text":"private subroutine json_file_add_string(me, path, val, found, was_created, trim_str, adjustl_str) Add a character string to a json file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Source Code json_file_add_string Source Code subroutine json_file_add_string ( me , path , val , found , was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , val , found , was_created , trim_str , adjustl_str ) end subroutine json_file_add_string","title":"json_file_add_string – JSON-Fortran","tags":"","loc":"proc/json_file_add_string.html"},{"text":"private subroutine json_file_add_string_path_ascii(me, path, val, found, was_created, trim_str, adjustl_str) Wrapper for json_file_add_string where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Calls proc~~json_file_add_string_path_ascii~~CallsGraph proc~json_file_add_string_path_ascii json_file_add_string_path_ascii interface~to_unicode to_unicode proc~json_file_add_string_path_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_add_string_path_ascii Source Code subroutine json_file_add_string_path_ascii ( me , path , val , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % json_file_add_string ( to_unicode ( path ), val , found ,& was_created , trim_str , adjustl_str ) end subroutine json_file_add_string_path_ascii","title":"json_file_add_string_path_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_add_string_path_ascii.html"},{"text":"private subroutine json_file_add_string_value_ascii(me, path, val, found, was_created, trim_str, adjustl_str) Wrapper for json_file_add_string where \"val\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Calls proc~~json_file_add_string_value_ascii~~CallsGraph proc~json_file_add_string_value_ascii json_file_add_string_value_ascii interface~to_unicode to_unicode proc~json_file_add_string_value_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_add_string_value_ascii Source Code subroutine json_file_add_string_value_ascii ( me , path , val , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % json_file_add_string ( path , to_unicode ( val ), found ,& was_created , trim_str , adjustl_str ) end subroutine json_file_add_string_value_ascii","title":"json_file_add_string_value_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_add_string_value_ascii.html"},{"text":"private subroutine json_file_add_string_vec(me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Add a string vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) Source Code json_file_add_string_vec Source Code subroutine json_file_add_string_vec ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) if (. not . associated ( me % p )) call me % core % create_object ( me % p , ck_ '' ) ! create root call me % core % add_by_path ( me % p , path , vec , found , was_created , ilen , trim_str , adjustl_str ) end subroutine json_file_add_string_vec","title":"json_file_add_string_vec – JSON-Fortran","tags":"","loc":"proc/json_file_add_string_vec.html"},{"text":"private subroutine json_file_add_string_vec_path_ascii(me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Alternate version of json_file_add_string_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) Calls proc~~json_file_add_string_vec_path_ascii~~CallsGraph proc~json_file_add_string_vec_path_ascii json_file_add_string_vec_path_ascii interface~to_unicode to_unicode proc~json_file_add_string_vec_path_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_add_string_vec_path_ascii Source Code subroutine json_file_add_string_vec_path_ascii ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string_vec ( to_unicode ( path ), vec , found ,& was_created , ilen , trim_str , adjustl_str ) end subroutine json_file_add_string_vec_path_ascii","title":"json_file_add_string_vec_path_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_add_string_vec_path_ascii.html"},{"text":"private subroutine json_file_add_string_vec_vec_ascii(me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Alternate version of json_file_add_string_vec , where \"vec\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) Calls proc~~json_file_add_string_vec_vec_ascii~~CallsGraph proc~json_file_add_string_vec_vec_ascii json_file_add_string_vec_vec_ascii interface~to_unicode to_unicode proc~json_file_add_string_vec_vec_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_add_string_vec_vec_ascii Source Code subroutine json_file_add_string_vec_vec_ascii ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string_vec ( path , to_unicode ( vec ), found ,& was_created , ilen , trim_str , adjustl_str ) end subroutine json_file_add_string_vec_vec_ascii","title":"json_file_add_string_vec_vec_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_add_string_vec_vec_ascii.html"},{"text":"private subroutine json_file_check_for_errors(me, status_ok, error_msg) Retrieve error status and message from the class. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Source Code json_file_check_for_errors Source Code subroutine json_file_check_for_errors ( me , status_ok , error_msg ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) call me % core % check_for_errors ( status_ok , error_msg ) end subroutine json_file_check_for_errors","title":"json_file_check_for_errors – JSON-Fortran","tags":"","loc":"proc/json_file_check_for_errors.html"},{"text":"private pure subroutine json_file_clear_exceptions(me) Clear exceptions in the class. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Source Code json_file_clear_exceptions Source Code pure subroutine json_file_clear_exceptions ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % clear_exceptions () end subroutine json_file_clear_exceptions","title":"json_file_clear_exceptions – JSON-Fortran","tags":"","loc":"proc/json_file_clear_exceptions.html"},{"text":"private subroutine json_file_destroy(me, destroy_core) Destroy the json_value data in a json_file .\n  This must be done when the variable is no longer needed,\n  or will be reused to open a different file.\n  Otherwise a memory leak will occur. Optionally, also destroy the json_core instance (this\n  is not necessary to prevent memory leaks, since a json_core does not use pointers). History 12/9/2013 : Created 4/26/2016 : Added optional destroy_core argument Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. Source Code json_file_destroy Source Code subroutine json_file_destroy ( me , destroy_core ) implicit none class ( json_file ), intent ( inout ) :: me logical , intent ( in ), optional :: destroy_core !! to also destroy the [[json_core(type)]]. !! default is to leave it as is. if ( associated ( me % p )) call me % core % destroy ( me % p ) if ( present ( destroy_core )) then if ( destroy_core ) call me % core % destroy () end if end subroutine json_file_destroy","title":"json_file_destroy – JSON-Fortran","tags":"","loc":"proc/json_file_destroy.html"},{"text":"private subroutine json_file_get_alloc_string_vec(me, path, vec, ilen, found) Get an (allocatable length) string vector from a JSON file.\n  This is just a wrapper for json_get_alloc_string_vec_by_path . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec value vector integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found Source Code json_file_get_alloc_string_vec Source Code subroutine json_file_get_alloc_string_vec ( me , path , vec , ilen , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec !! value vector integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found call me % core % get ( me % p , path , vec , ilen , found ) end subroutine json_file_get_alloc_string_vec","title":"json_file_get_alloc_string_vec – JSON-Fortran","tags":"","loc":"proc/json_file_get_alloc_string_vec.html"},{"text":"private subroutine json_file_get_double(me, path, val, found) Get a real(RK) variable value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_double Source Code subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double","title":"json_file_get_double – JSON-Fortran","tags":"","loc":"proc/json_file_get_double.html"},{"text":"private subroutine json_file_get_double_vec(me, path, vec, found) Get a real(RK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_double_vec Source Code subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec","title":"json_file_get_double_vec – JSON-Fortran","tags":"","loc":"proc/json_file_get_double_vec.html"},{"text":"private subroutine json_file_get_integer(me, path, val, found) Get an integer value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_integer Source Code subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer","title":"json_file_get_integer – JSON-Fortran","tags":"","loc":"proc/json_file_get_integer.html"},{"text":"private subroutine json_file_get_integer_vec(me, path, vec, found) Get an integer vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_integer_vec Source Code subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec","title":"json_file_get_integer_vec – JSON-Fortran","tags":"","loc":"proc/json_file_get_integer_vec.html"},{"text":"private subroutine json_file_get_logical(me, path, val, found) Get a logical(LK) value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_logical Source Code subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical","title":"json_file_get_logical – JSON-Fortran","tags":"","loc":"proc/json_file_get_logical.html"},{"text":"private subroutine json_file_get_logical_vec(me, path, vec, found) Get a logical(LK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_logical_vec Source Code subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec","title":"json_file_get_logical_vec – JSON-Fortran","tags":"","loc":"proc/json_file_get_logical_vec.html"},{"text":"private subroutine json_file_get_object(me, path, p, found) Get a json_value pointer to an object from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_object Source Code subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object","title":"json_file_get_object – JSON-Fortran","tags":"","loc":"proc/json_file_get_object.html"},{"text":"private subroutine json_file_get_root(me, p) Get a json_value pointer to the JSON file root. Note This is equivalent to calling json_file %get('$',p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Source Code json_file_get_root Source Code subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root","title":"json_file_get_root – JSON-Fortran","tags":"","loc":"proc/json_file_get_root.html"},{"text":"private subroutine json_file_get_string(me, path, val, found) Get a character string from a json file.\n  The output val is an allocatable character string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), allocatable :: val value logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_string Source Code subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), allocatable , intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string","title":"json_file_get_string – JSON-Fortran","tags":"","loc":"proc/json_file_get_string.html"},{"text":"private subroutine json_file_get_string_vec(me, path, vec, found) Get a string vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec value vector logical(kind=LK), intent(out), optional :: found if it was really found Source Code json_file_get_string_vec Source Code subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec !! value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % core % get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec","title":"json_file_get_string_vec – JSON-Fortran","tags":"","loc":"proc/json_file_get_string_vec.html"},{"text":"private subroutine json_file_load(me, filename, unit) Load the JSON data from a file. Example program main use json_module implicit none type ( json_file ) :: f call f % load_file ( 'my_file.json' ) !... call f % destroy () end program main Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use\n (if not present, a newunit\n is used) Source Code json_file_load Source Code subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use !! (if not present, a newunit !! is used) call me % core % parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load","title":"json_file_load – JSON-Fortran","tags":"","loc":"proc/json_file_load.html"},{"text":"private subroutine json_file_load_from_string(me, str) Load the JSON data from a string. Example Load JSON from a string: type ( json_file ) :: f call f % load_from_string ( '{ \"name\": \"Leonidas\" }' ) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Source Code json_file_load_from_string Source Code subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call me % core % parse ( str = str , p = me % p ) end subroutine json_file_load_from_string","title":"json_file_load_from_string – JSON-Fortran","tags":"","loc":"proc/json_file_load_from_string.html"},{"text":"private subroutine json_file_move_pointer(to, from) Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. Note If \"from%p\" is not associated, then an error is thrown. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from Source Code json_file_move_pointer Source Code subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then if ( from % failed ()) then !Don't get the data if the FROM file has an !active exception, since it may not be valid. call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'error exception in FROM file.' ) else call to % initialize () !initialize and clear any exceptions that may be present to % p => from % p nullify ( from % p ) end if else call to % core % throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer","title":"json_file_move_pointer – JSON-Fortran","tags":"","loc":"proc/json_file_move_pointer.html"},{"text":"private subroutine json_file_print_1(me, iunit) Prints the JSON file to the specified file unit number. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Source Code json_file_print_1 Source Code subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) if ( iunit /= unit2str ) then call me % core % print ( me % p , iunit = iunit ) else call me % core % throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1","title":"json_file_print_1 – JSON-Fortran","tags":"","loc":"proc/json_file_print_1.html"},{"text":"private subroutine json_file_print_2(me, filename) Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Example Example loading a JSON file, changing a value, and then printing\n  result to a new file: type ( json_file ) :: f logical :: found call f % load_file ( 'my_file.json' ) !open the original file call f % update ( 'version' , 4 , found ) !change the value of a variable call f % print_file ( 'my_file_2.json' ) !save file as new name Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Source Code json_file_print_2 Source Code subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to call me % core % print ( me % p , filename ) end subroutine json_file_print_2","title":"json_file_print_2 – JSON-Fortran","tags":"","loc":"proc/json_file_print_2.html"},{"text":"private subroutine json_file_print_error_message(me, io_unit) This is a wrapper for json_print_error_message . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit Source Code json_file_print_error_message Source Code subroutine json_file_print_error_message ( me , io_unit ) implicit none class ( json_file ), intent ( inout ) :: me integer , intent ( in ), optional :: io_unit call me % core % print_error_message ( io_unit ) end subroutine json_file_print_error_message","title":"json_file_print_error_message – JSON-Fortran","tags":"","loc":"proc/json_file_print_error_message.html"},{"text":"private subroutine json_file_print_to_console(me) Print the JSON file to the console. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Source Code json_file_print_to_console Source Code subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % core % print ( me % p , iunit = output_unit ) end subroutine json_file_print_to_console","title":"json_file_print_to_console – JSON-Fortran","tags":"","loc":"proc/json_file_print_to_console.html"},{"text":"private subroutine json_file_print_to_string(me, str) Print the JSON file to a string. Example Open a JSON file, and then print the contents to a string: type ( json_file ) :: f character ( kind = CK , len = :), allocatable :: str call f % load_file ( 'my_file.json' ) call f % print_file ( str ) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to Source Code json_file_print_to_string Source Code subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call me % core % print_to_string ( me % p , str ) end subroutine json_file_print_to_string","title":"json_file_print_to_string – JSON-Fortran","tags":"","loc":"proc/json_file_print_to_string.html"},{"text":"private subroutine json_file_rename(me, path, name, found) Rename a variable in a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found Source Code json_file_rename Source Code subroutine json_file_rename ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % core % rename ( me % p , path , name , found ) end subroutine json_file_rename","title":"json_file_rename – JSON-Fortran","tags":"","loc":"proc/json_file_rename.html"},{"text":"private subroutine json_file_rename_name_ascii(me, path, name, found) Wrapper for json_file_rename where \"name\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found Calls proc~~json_file_rename_name_ascii~~CallsGraph proc~json_file_rename_name_ascii json_file_rename_name_ascii interface~to_unicode to_unicode proc~json_file_rename_name_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_rename_name_ascii Source Code subroutine json_file_rename_name_ascii ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % json_file_rename ( path , to_unicode ( name ), found ) end subroutine json_file_rename_name_ascii","title":"json_file_rename_name_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_rename_name_ascii.html"},{"text":"private subroutine json_file_rename_path_ascii(me, path, name, found) Wrapper for json_file_rename where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found Calls proc~~json_file_rename_path_ascii~~CallsGraph proc~json_file_rename_path_ascii json_file_rename_path_ascii interface~to_unicode to_unicode proc~json_file_rename_path_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_rename_path_ascii Source Code subroutine json_file_rename_path_ascii ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % json_file_rename ( to_unicode ( path ), name , found ) end subroutine json_file_rename_path_ascii","title":"json_file_rename_path_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_rename_path_ascii.html"},{"text":"private subroutine json_file_traverse(me, traverse_callback) Traverse the JSON structure in the file.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure( json_traverse_callback_func ) :: traverse_callback Source Code json_file_traverse Source Code subroutine json_file_traverse ( me , traverse_callback ) implicit none class ( json_file ), intent ( inout ) :: me procedure ( json_traverse_callback_func ) :: traverse_callback call me % core % traverse ( me % p , traverse_callback ) end subroutine json_file_traverse","title":"json_file_traverse – JSON-Fortran","tags":"","loc":"proc/json_file_traverse.html"},{"text":"private subroutine json_file_update_integer(me, path, val, found) Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_integer Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Source Code json_file_update_integer Source Code subroutine json_file_update_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found ) end subroutine json_file_update_integer","title":"json_file_update_integer – JSON-Fortran","tags":"","loc":"proc/json_file_update_integer.html"},{"text":"private subroutine json_file_update_logical(me, path, val, found) Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_logical Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Source Code json_file_update_logical Source Code subroutine json_file_update_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found ) end subroutine json_file_update_logical","title":"json_file_update_logical – JSON-Fortran","tags":"","loc":"proc/json_file_update_logical.html"},{"text":"private subroutine json_file_update_real(me, path, val, found) Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_double Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Source Code json_file_update_real Source Code subroutine json_file_update_real ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found ) end subroutine json_file_update_real","title":"json_file_update_real – JSON-Fortran","tags":"","loc":"proc/json_file_update_real.html"},{"text":"private subroutine json_file_update_string(me, path, val, found, trim_str, adjustl_str) Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_string Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Source Code json_file_update_string Source Code subroutine json_file_update_string ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) if (. not . me % core % failed ()) call me % core % update ( me % p , path , val , found , trim_str , adjustl_str ) end subroutine json_file_update_string","title":"json_file_update_string – JSON-Fortran","tags":"","loc":"proc/json_file_update_string.html"},{"text":"private subroutine json_file_update_string_name_ascii(me, path, val, found, trim_str, adjustl_str) Alternate version of json_file_update_string , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Calls proc~~json_file_update_string_name_ascii~~CallsGraph proc~json_file_update_string_name_ascii json_file_update_string_name_ascii interface~to_unicode to_unicode proc~json_file_update_string_name_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_update_string_name_ascii Source Code subroutine json_file_update_string_name_ascii ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % update ( to_unicode ( path ), val , found , trim_str , adjustl_str ) end subroutine json_file_update_string_name_ascii","title":"json_file_update_string_name_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_update_string_name_ascii.html"},{"text":"private subroutine json_file_update_string_val_ascii(me, path, val, found, trim_str, adjustl_str) Alternate version of json_file_update_string , where \"val\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Calls proc~~json_file_update_string_val_ascii~~CallsGraph proc~json_file_update_string_val_ascii json_file_update_string_val_ascii interface~to_unicode to_unicode proc~json_file_update_string_val_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_file_update_string_val_ascii Source Code subroutine json_file_update_string_val_ascii ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % update ( path , to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine json_file_update_string_val_ascii","title":"json_file_update_string_val_ascii – JSON-Fortran","tags":"","loc":"proc/json_file_update_string_val_ascii.html"},{"text":"private subroutine json_file_variable_info(me, path, found, var_type, n_children, name) Returns information about a variable in a json_file . Note If found is present, no exceptions will be thrown if an\n      error occurs. Otherwise, an exception will be thrown if the\n      variable is not found. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found the variable exists in the structure integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Source Code json_file_variable_info Source Code subroutine json_file_variable_info ( me , path , found , var_type , n_children , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! the variable exists in the structure integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % core % info ( me % p , path , found , var_type , n_children , name ) end subroutine json_file_variable_info","title":"json_file_variable_info – JSON-Fortran","tags":"","loc":"proc/json_file_variable_info.html"},{"text":"private subroutine json_file_variable_matrix_info(me, path, is_matrix, found, var_type, n_sets, set_size, name) Returns matrix information about a variable in a json_file . Note If found is present, no exceptions will be thrown if an\n      error occurs. Otherwise, an exception will be thrown if the\n      variable is not found. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Source Code json_file_variable_matrix_info Source Code subroutine json_file_variable_matrix_info ( me , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % core % matrix_info ( me % p , path , is_matrix , found , var_type , n_sets , set_size , name ) end subroutine json_file_variable_matrix_info","title":"json_file_variable_matrix_info – JSON-Fortran","tags":"","loc":"proc/json_file_variable_matrix_info.html"},{"text":"private subroutine set_json_core_in_file(me, core) Set the json_core for this json_file . Note : This does not destroy the data in the file. Note : This one is used if you want to initialize the file with\n       an already-existing json_core (presumably, this was already\n       initialized by a call to initialize_json_core or similar). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core Source Code set_json_core_in_file Source Code subroutine set_json_core_in_file ( me , core ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_core ), intent ( in ) :: core me % core = core end subroutine set_json_core_in_file","title":"set_json_core_in_file – JSON-Fortran","tags":"","loc":"proc/set_json_core_in_file.html"},{"text":"private subroutine wrap_json_file_add_double(me, path, val, found, was_created) Alternate version of json_file_add_double , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_double~~CallsGraph proc~wrap_json_file_add_double wrap_json_file_add_double interface~to_unicode to_unicode proc~wrap_json_file_add_double->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_double Source Code subroutine wrap_json_file_add_double ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_double ( to_unicode ( path ), val , found , was_created ) end subroutine wrap_json_file_add_double","title":"wrap_json_file_add_double – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_double.html"},{"text":"private subroutine wrap_json_file_add_double_vec(me, path, vec, found, was_created) Alternate version of json_file_add_double_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_double_vec~~CallsGraph proc~wrap_json_file_add_double_vec wrap_json_file_add_double_vec interface~to_unicode to_unicode proc~wrap_json_file_add_double_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_double_vec Source Code subroutine wrap_json_file_add_double_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_double_vec ( to_unicode ( path ), vec , found , was_created ) end subroutine wrap_json_file_add_double_vec","title":"wrap_json_file_add_double_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_double_vec.html"},{"text":"private subroutine wrap_json_file_add_integer(me, path, val, found, was_created) Alternate version of json_file_add_integer , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_integer~~CallsGraph proc~wrap_json_file_add_integer wrap_json_file_add_integer interface~to_unicode to_unicode proc~wrap_json_file_add_integer->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_integer Source Code subroutine wrap_json_file_add_integer ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_integer ( to_unicode ( path ), val , found , was_created ) end subroutine wrap_json_file_add_integer","title":"wrap_json_file_add_integer – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_integer.html"},{"text":"private subroutine wrap_json_file_add_integer_vec(me, path, vec, found, was_created) Alternate version of json_file_add_integer_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_integer_vec~~CallsGraph proc~wrap_json_file_add_integer_vec wrap_json_file_add_integer_vec interface~to_unicode to_unicode proc~wrap_json_file_add_integer_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_integer_vec Source Code subroutine wrap_json_file_add_integer_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_integer_vec ( to_unicode ( path ), vec , found , was_created ) end subroutine wrap_json_file_add_integer_vec","title":"wrap_json_file_add_integer_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_integer_vec.html"},{"text":"private subroutine wrap_json_file_add_logical(me, path, val, found, was_created) Alternate version of json_file_add_logical , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_logical~~CallsGraph proc~wrap_json_file_add_logical wrap_json_file_add_logical interface~to_unicode to_unicode proc~wrap_json_file_add_logical->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_logical Source Code subroutine wrap_json_file_add_logical ( me , path , val , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_logical ( to_unicode ( path ), val , found , was_created ) end subroutine wrap_json_file_add_logical","title":"wrap_json_file_add_logical – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_logical.html"},{"text":"private subroutine wrap_json_file_add_logical_vec(me, path, vec, found, was_created) Alternate version of json_file_add_logical_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_logical_vec~~CallsGraph proc~wrap_json_file_add_logical_vec wrap_json_file_add_logical_vec interface~to_unicode to_unicode proc~wrap_json_file_add_logical_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_logical_vec Source Code subroutine wrap_json_file_add_logical_vec ( me , path , vec , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_logical_vec ( to_unicode ( path ), vec , found , was_created ) end subroutine wrap_json_file_add_logical_vec","title":"wrap_json_file_add_logical_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_logical_vec.html"},{"text":"private subroutine wrap_json_file_add_object(me, path, p, found, was_created) Alternate version of json_file_add_object , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p pointer to the variable to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_file_add_object~~CallsGraph proc~wrap_json_file_add_object wrap_json_file_add_object interface~to_unicode to_unicode proc~wrap_json_file_add_object->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_object Source Code subroutine wrap_json_file_add_object ( me , path , p , found , was_created ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! pointer to the variable to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call me % json_file_add_object ( to_unicode ( path ), p , found , was_created ) end subroutine wrap_json_file_add_object","title":"wrap_json_file_add_object – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_object.html"},{"text":"private subroutine wrap_json_file_add_string(me, path, val, found, was_created, trim_str, adjustl_str) Alternate version of json_file_add_string , where \"path\" and \"val\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Calls proc~~wrap_json_file_add_string~~CallsGraph proc~wrap_json_file_add_string wrap_json_file_add_string interface~to_unicode to_unicode proc~wrap_json_file_add_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_string Source Code subroutine wrap_json_file_add_string ( me , path , val , found , was_created , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string ( to_unicode ( path ), to_unicode ( val ), found ,& was_created , trim_str , adjustl_str ) end subroutine wrap_json_file_add_string","title":"wrap_json_file_add_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_string.html"},{"text":"private subroutine wrap_json_file_add_string_vec(me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Alternate version of json_file_add_string_vec , where \"path\" and \"vec\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) Calls proc~~wrap_json_file_add_string_vec~~CallsGraph proc~wrap_json_file_add_string_vec wrap_json_file_add_string_vec interface~to_unicode to_unicode proc~wrap_json_file_add_string_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_add_string_vec Source Code subroutine wrap_json_file_add_string_vec ( me , path , vec , found ,& was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element !! (note that ADJUSTL is done before TRIM) call me % json_file_add_string_vec ( to_unicode ( path ), to_unicode ( vec ), found ,& was_created , ilen , trim_str , adjustl_str ) end subroutine wrap_json_file_add_string_vec","title":"wrap_json_file_add_string_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_add_string_vec.html"},{"text":"private subroutine wrap_json_file_get_alloc_string_vec(me, path, vec, ilen, found) Alternate version of json_file_get_alloc_string_vec , where \"path\" is kind=CDK.\n  This is just a wrapper for wrap_json_get_alloc_string_vec_by_path . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec value vector integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_file_get_alloc_string_vec~~CallsGraph proc~wrap_json_file_get_alloc_string_vec wrap_json_file_get_alloc_string_vec interface~to_unicode to_unicode proc~wrap_json_file_get_alloc_string_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_alloc_string_vec Source Code subroutine wrap_json_file_get_alloc_string_vec ( me , path , vec , ilen , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec !! value vector integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , ilen , found ) end subroutine wrap_json_file_get_alloc_string_vec","title":"wrap_json_file_get_alloc_string_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_alloc_string_vec.html"},{"text":"private subroutine wrap_json_file_get_double(me, path, val, found) Alternate version of json_file_get_double , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_double~~CallsGraph proc~wrap_json_file_get_double wrap_json_file_get_double interface~to_unicode to_unicode proc~wrap_json_file_get_double->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_double Source Code subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double","title":"wrap_json_file_get_double – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_double.html"},{"text":"private subroutine wrap_json_file_get_double_vec(me, path, vec, found) Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_double_vec~~CallsGraph proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec interface~to_unicode to_unicode proc~wrap_json_file_get_double_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_double_vec Source Code subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec","title":"wrap_json_file_get_double_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_double_vec.html"},{"text":"private subroutine wrap_json_file_get_integer(me, path, val, found) Alternate version of json_file_get_integer , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_integer~~CallsGraph proc~wrap_json_file_get_integer wrap_json_file_get_integer interface~to_unicode to_unicode proc~wrap_json_file_get_integer->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_integer Source Code subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer","title":"wrap_json_file_get_integer – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_integer.html"},{"text":"private subroutine wrap_json_file_get_integer_vec(me, path, vec, found) Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_integer_vec~~CallsGraph proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec interface~to_unicode to_unicode proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_integer_vec Source Code subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec","title":"wrap_json_file_get_integer_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_integer_vec.html"},{"text":"private subroutine wrap_json_file_get_logical(me, path, val, found) Alternate version of json_file_get_logical , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_logical~~CallsGraph proc~wrap_json_file_get_logical wrap_json_file_get_logical interface~to_unicode to_unicode proc~wrap_json_file_get_logical->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_logical Source Code subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical","title":"wrap_json_file_get_logical – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_logical.html"},{"text":"private subroutine wrap_json_file_get_logical_vec(me, path, vec, found) Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_logical_vec~~CallsGraph proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec interface~to_unicode to_unicode proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_logical_vec Source Code subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec","title":"wrap_json_file_get_logical_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_logical_vec.html"},{"text":"private subroutine wrap_json_file_get_object(me, path, p, found) Alternate version of json_file_get_object , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_object~~CallsGraph proc~wrap_json_file_get_object wrap_json_file_get_object interface~to_unicode to_unicode proc~wrap_json_file_get_object->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_object Source Code subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object","title":"wrap_json_file_get_object – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_object.html"},{"text":"private subroutine wrap_json_file_get_string(me, path, val, found) Alternate version of json_file_get_string , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), allocatable :: val value logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_string~~CallsGraph proc~wrap_json_file_get_string wrap_json_file_get_string interface~to_unicode to_unicode proc~wrap_json_file_get_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_string Source Code subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len = :), allocatable , intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string","title":"wrap_json_file_get_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_string.html"},{"text":"private subroutine wrap_json_file_get_string_vec(me, path, vec, found) Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec value vector logical(kind=LK), intent(out), optional :: found if it was really found Calls proc~~wrap_json_file_get_string_vec~~CallsGraph proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec interface~to_unicode to_unicode proc~wrap_json_file_get_string_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_get_string_vec Source Code subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec !! value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec","title":"wrap_json_file_get_string_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_get_string_vec.html"},{"text":"private subroutine wrap_json_file_load_from_string(me, str) Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str Calls proc~~wrap_json_file_load_from_string~~CallsGraph proc~wrap_json_file_load_from_string wrap_json_file_load_from_string interface~to_unicode to_unicode proc~wrap_json_file_load_from_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_load_from_string Source Code subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call me % load_from_string ( to_unicode ( str )) end subroutine wrap_json_file_load_from_string","title":"wrap_json_file_load_from_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_load_from_string.html"},{"text":"private subroutine wrap_json_file_rename(me, path, name, found) Alternate version of json_file_rename , where \"path\" and \"name\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found Calls proc~~wrap_json_file_rename~~CallsGraph proc~wrap_json_file_rename wrap_json_file_rename interface~to_unicode to_unicode proc~wrap_json_file_rename->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_rename Source Code subroutine wrap_json_file_rename ( me , path , name , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found !! if the variable was found call me % json_file_rename ( to_unicode ( path ), to_unicode ( name ), found ) end subroutine wrap_json_file_rename","title":"wrap_json_file_rename – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_rename.html"},{"text":"private subroutine wrap_json_file_update_integer(me, path, val, found) Alternate version of json_file_update_integer , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Calls proc~~wrap_json_file_update_integer~~CallsGraph proc~wrap_json_file_update_integer wrap_json_file_update_integer interface~to_unicode to_unicode proc~wrap_json_file_update_integer->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_update_integer Source Code subroutine wrap_json_file_update_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_update_integer","title":"wrap_json_file_update_integer – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_update_integer.html"},{"text":"private subroutine wrap_json_file_update_logical(me, path, val, found) Alternate version of json_file_update_logical , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Calls proc~~wrap_json_file_update_logical~~CallsGraph proc~wrap_json_file_update_logical wrap_json_file_update_logical interface~to_unicode to_unicode proc~wrap_json_file_update_logical->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_update_logical Source Code subroutine wrap_json_file_update_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_update_logical","title":"wrap_json_file_update_logical – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_update_logical.html"},{"text":"private subroutine wrap_json_file_update_real(me, path, val, found) Alternate version of json_file_update_real , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Calls proc~~wrap_json_file_update_real~~CallsGraph proc~wrap_json_file_update_real wrap_json_file_update_real interface~to_unicode to_unicode proc~wrap_json_file_update_real->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_update_real Source Code subroutine wrap_json_file_update_real ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_update_real","title":"wrap_json_file_update_real – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_update_real.html"},{"text":"private subroutine wrap_json_file_update_string(me, path, val, found, trim_str, adjustl_str) Alternate version of json_file_update_string , where \"path\" and \"val\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) Calls proc~~wrap_json_file_update_string~~CallsGraph proc~wrap_json_file_update_string wrap_json_file_update_string interface~to_unicode to_unicode proc~wrap_json_file_update_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_update_string Source Code subroutine wrap_json_file_update_string ( me , path , val , found , trim_str , adjustl_str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (note that ADJUSTL is done before TRIM) call me % update ( to_unicode ( path ), to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine wrap_json_file_update_string","title":"wrap_json_file_update_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_update_string.html"},{"text":"private subroutine wrap_json_file_variable_info(me, path, found, var_type, n_children, name) Alternate version of json_file_variable_info , where \"path\" is kind=CDK. Note If found is present, no exceptions will be thrown if an\n      error occurs. Otherwise, an exception will be thrown if the\n      variable is not found. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), optional :: found integer(kind=IK), intent(out), optional :: var_type integer(kind=IK), intent(out), optional :: n_children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Calls proc~~wrap_json_file_variable_info~~CallsGraph proc~wrap_json_file_variable_info wrap_json_file_variable_info interface~to_unicode to_unicode proc~wrap_json_file_variable_info->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_variable_info Source Code subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ), optional :: found integer ( IK ), intent ( out ), optional :: var_type integer ( IK ), intent ( out ), optional :: n_children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % info ( to_unicode ( path ), found , var_type , n_children , name ) end subroutine wrap_json_file_variable_info","title":"wrap_json_file_variable_info – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_variable_info.html"},{"text":"private subroutine wrap_json_file_variable_matrix_info(me, path, is_matrix, found, var_type, n_sets, set_size, name) Alternate version of json_file_variable_matrix_info , where \"path\" is kind=CDK. Note If found is present, no exceptions will be thrown if an\n      error occurs. Otherwise, an exception will be thrown if the\n      variable is not found. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Calls proc~~wrap_json_file_variable_matrix_info~~CallsGraph proc~wrap_json_file_variable_matrix_info wrap_json_file_variable_matrix_info interface~to_unicode to_unicode proc~wrap_json_file_variable_matrix_info->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_file_variable_matrix_info Source Code subroutine wrap_json_file_variable_matrix_info ( me , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call me % matrix_info ( to_unicode ( path ), is_matrix , found , var_type , n_sets , set_size , name ) end subroutine wrap_json_file_variable_matrix_info","title":"wrap_json_file_variable_matrix_info – JSON-Fortran","tags":"","loc":"proc/wrap_json_file_variable_matrix_info.html"},{"text":"public interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. Example ... type ( json_file ) :: my_file type ( json_value ), pointer :: json_object type ( json_core ) :: json_core_object ... ! Construct a json_object: !could do this: my_file = json_file ( json_object ) !or: my_file = json_file ( json_object , verbose = . true .) !or: my_file = json_file ( json_object , json_core_object ) Calls interface~~json_file~~CallsGraph interface~json_file json_file proc~initialize_json_file initialize_json_file interface~json_file->proc~initialize_json_file proc~initialize_json_file_v2 initialize_json_file_v2 interface~json_file->proc~initialize_json_file_v2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Module Procedures initialize_json_file initialize_json_file_v2 Module Procedures private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(file_object) Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_file ) private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file )","title":"json_file – JSON-Fortran","tags":"","loc":"interface/json_file.html"},{"text":"public pure function decode_rfc6901(str) result(str_out) Decode a string from the \" JSON Pointer\" RFC 6901 format. It replaces ~1 with / and ~0 with ~ . Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str Return Value character(kind=CK,len=:),\n  allocatable Calls proc~~decode_rfc6901~~CallsGraph proc~decode_rfc6901 decode_rfc6901 proc~replace_string replace_string proc~decode_rfc6901->proc~replace_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~decode_rfc6901~~CalledByGraph proc~decode_rfc6901 decode_rfc6901 proc~json_get_by_path_rfc6901 json_get_by_path_rfc6901 proc~json_get_by_path_rfc6901->proc~decode_rfc6901 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code decode_rfc6901 Source Code pure function decode_rfc6901 ( str ) result ( str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str character ( kind = CK , len = :), allocatable :: str_out str_out = str call replace_string ( str_out , tilde // CK_ '1' , slash ) call replace_string ( str_out , tilde // CK_ '0' , tilde ) end function decode_rfc6901","title":"decode_rfc6901 – JSON-Fortran","tags":"","loc":"proc/decode_rfc6901.html"},{"text":"private pure elemental function default_comp_ucs4(def_str, ucs4_str) result(res) CDK == CK operator. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Calls proc~~default_comp_ucs4~~CallsGraph proc~default_comp_ucs4 default_comp_ucs4 interface~to_unicode to_unicode proc~default_comp_ucs4->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code default_comp_ucs4 Source Code pure elemental function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4","title":"default_comp_ucs4 – JSON-Fortran","tags":"","loc":"proc/default_comp_ucs4.html"},{"text":"private pure function default_join_ucs4(def_str, ucs4_str) result(res) CDK // CK operator. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) Calls proc~~default_join_ucs4~~CallsGraph proc~default_join_ucs4 default_join_ucs4 interface~to_unicode to_unicode proc~default_join_ucs4->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code default_join_ucs4 Source Code pure function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4","title":"default_join_ucs4 – JSON-Fortran","tags":"","loc":"proc/default_join_ucs4.html"},{"text":"private pure elemental function default_neq_ucs4(def_str, ucs4_str) result(res) CDK /= CK operator. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Calls proc~~default_neq_ucs4~~CallsGraph proc~default_neq_ucs4 default_neq_ucs4 interface~to_unicode to_unicode proc~default_neq_ucs4->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code default_neq_ucs4 Source Code pure elemental function default_neq_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) /= ucs4_str ) end function default_neq_ucs4","title":"default_neq_ucs4 – JSON-Fortran","tags":"","loc":"proc/default_neq_ucs4.html"},{"text":"public pure function encode_rfc6901(str) result(str_out) Encode a string into the \" JSON Pointer\" RFC 6901 format. It replaces ~ with ~0 and / with ~1 . Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str Return Value character(kind=CK,len=:),\n  allocatable Calls proc~~encode_rfc6901~~CallsGraph proc~encode_rfc6901 encode_rfc6901 proc~replace_string replace_string proc~encode_rfc6901->proc~replace_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~encode_rfc6901~~CalledByGraph proc~encode_rfc6901 encode_rfc6901 proc~json_get_path json_get_path proc~json_get_path->proc~encode_rfc6901 proc~wrap_json_get_path wrap_json_get_path proc~wrap_json_get_path->proc~json_get_path Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code encode_rfc6901 Source Code pure function encode_rfc6901 ( str ) result ( str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str character ( kind = CK , len = :), allocatable :: str_out str_out = str call replace_string ( str_out , tilde , tilde // CK_ '0' ) call replace_string ( str_out , slash , tilde // CK_ '1' ) end function encode_rfc6901","title":"encode_rfc6901 – JSON-Fortran","tags":"","loc":"proc/encode_rfc6901.html"},{"text":"public pure elemental function lowercase_string(str) result(s_lower) Returns lowercase version of the CK string. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str input string Return Value character(kind=CK,len=(len(str))) lowercase version of the string Called By proc~~lowercase_string~~CalledByGraph proc~lowercase_string lowercase_string proc~name_strings_equal name_strings_equal proc~name_strings_equal->proc~lowercase_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code lowercase_string Source Code pure elemental function lowercase_string ( str ) result ( s_lower ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! input string character ( kind = CK , len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: j !! index of uppercase character s_lower = str do i = 1 , len_trim ( str ) j = index ( upper , s_lower ( i : i )) if ( j > 0 ) s_lower ( i : i ) = lower ( j : j ) end do end function lowercase_string","title":"lowercase_string – JSON-Fortran","tags":"","loc":"proc/lowercase_string.html"},{"text":"private pure function to_uni(str) Convert string to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Called By proc~~to_uni~~CalledByGraph proc~to_uni to_uni interface~to_unicode to_unicode interface~to_unicode->proc~to_uni proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec proc~wrap_json_file_get_string_vec->interface~to_unicode proc~wrap_json_update_integer wrap_json_update_integer proc~wrap_json_update_integer->interface~to_unicode proc~wrap_json_file_get_string wrap_json_file_get_string proc~wrap_json_file_get_string->interface~to_unicode proc~wrap_json_file_get_object wrap_json_file_get_object proc~wrap_json_file_get_object->interface~to_unicode proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec proc~wrap_json_value_add_double_vec->interface~to_unicode proc~wrap_json_matrix_info_by_path wrap_json_matrix_info_by_path proc~wrap_json_matrix_info_by_path->interface~to_unicode proc~wrap_json_get_string_by_path wrap_json_get_string_by_path proc~wrap_json_get_string_by_path->interface~to_unicode proc~wrap_json_get_string_vec_by_path wrap_json_get_string_vec_by_path proc~wrap_json_get_string_vec_by_path->interface~to_unicode proc~wrap_json_update_logical wrap_json_update_logical proc~wrap_json_update_logical->interface~to_unicode proc~wrap_json_get_logical_vec_by_path wrap_json_get_logical_vec_by_path proc~wrap_json_get_logical_vec_by_path->interface~to_unicode proc~wrap_json_throw_exception wrap_json_throw_exception proc~wrap_json_throw_exception->interface~to_unicode proc~wrap_json_get_integer_by_path wrap_json_get_integer_by_path proc~wrap_json_get_integer_by_path->interface~to_unicode proc~json_add_string_by_path_path_ascii json_add_string_by_path_path_ascii proc~json_add_string_by_path_path_ascii->interface~to_unicode proc~wrap_json_get_integer_vec_by_path wrap_json_get_integer_vec_by_path proc~wrap_json_get_integer_vec_by_path->interface~to_unicode proc~json_rename_by_path_name_ascii json_rename_by_path_name_ascii proc~json_rename_by_path_name_ascii->interface~to_unicode proc~wrap_json_info_by_path wrap_json_info_by_path proc~wrap_json_info_by_path->interface~to_unicode proc~wrap_json_file_valid_path_op wrap_json_file_valid_path_op proc~wrap_json_file_valid_path_op->interface~to_unicode proc~wrap_json_rename_by_path wrap_json_rename_by_path proc~wrap_json_rename_by_path->interface~to_unicode proc~wrap_json_update_string wrap_json_update_string proc~wrap_json_update_string->interface~to_unicode proc~wrap_json_value_create_array wrap_json_value_create_array proc~wrap_json_value_create_array->interface~to_unicode proc~wrap_json_file_update_integer wrap_json_file_update_integer proc~wrap_json_file_update_integer->interface~to_unicode proc~wrap_json_parse_string wrap_json_parse_string proc~wrap_json_parse_string->interface~to_unicode proc~wrap_json_update_double wrap_json_update_double proc~wrap_json_update_double->interface~to_unicode proc~json_file_rename_path_ascii json_file_rename_path_ascii proc~json_file_rename_path_ascii->interface~to_unicode proc~wrap_json_value_create_double wrap_json_value_create_double proc~wrap_json_value_create_double->interface~to_unicode proc~wrap_json_value_add_integer wrap_json_value_add_integer proc~wrap_json_value_add_integer->interface~to_unicode proc~wrap_json_value_add_string wrap_json_value_add_string proc~wrap_json_value_add_string->interface~to_unicode proc~wrap_json_file_variable_matrix_info wrap_json_file_variable_matrix_info proc~wrap_json_file_variable_matrix_info->interface~to_unicode proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec proc~wrap_json_value_add_string_vec->interface~to_unicode proc~wrap_json_value_add_logical wrap_json_value_add_logical proc~wrap_json_value_add_logical->interface~to_unicode proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~wrap_json_file_update_real wrap_json_file_update_real proc~wrap_json_file_update_real->interface~to_unicode proc~wrap_json_value_add_null wrap_json_value_add_null proc~wrap_json_value_add_null->interface~to_unicode proc~wrap_json_file_update_logical wrap_json_file_update_logical proc~wrap_json_file_update_logical->interface~to_unicode proc~wrap_json_file_update_string wrap_json_file_update_string proc~wrap_json_file_update_string->interface~to_unicode proc~wrap_json_file_variable_info wrap_json_file_variable_info proc~wrap_json_file_variable_info->interface~to_unicode proc~wrap_json_file_rename wrap_json_file_rename proc~wrap_json_file_rename->interface~to_unicode proc~json_file_add_string_vec_vec_ascii json_file_add_string_vec_vec_ascii proc~json_file_add_string_vec_vec_ascii->interface~to_unicode proc~json_file_add_string_path_ascii json_file_add_string_path_ascii proc~json_file_add_string_path_ascii->interface~to_unicode proc~json_file_update_string_name_ascii json_file_update_string_name_ascii proc~json_file_update_string_name_ascii->interface~to_unicode proc~json_file_add_string_vec_path_ascii json_file_add_string_vec_path_ascii proc~json_file_add_string_vec_path_ascii->interface~to_unicode proc~json_file_add_string_value_ascii json_file_add_string_value_ascii proc~json_file_add_string_value_ascii->interface~to_unicode proc~wrap_json_file_valid_path wrap_json_file_valid_path proc~wrap_json_file_valid_path->interface~to_unicode proc~wrap_json_get_logical_by_path wrap_json_get_logical_by_path proc~wrap_json_get_logical_by_path->interface~to_unicode proc~json_file_rename_name_ascii json_file_rename_name_ascii proc~json_file_rename_name_ascii->interface~to_unicode proc~json_file_update_string_val_ascii json_file_update_string_val_ascii proc~json_file_update_string_val_ascii->interface~to_unicode proc~json_add_string_vec_by_path_path_ascii json_add_string_vec_by_path_path_ascii proc~json_add_string_vec_by_path_path_ascii->interface~to_unicode proc~json_add_string_by_path_value_ascii json_add_string_by_path_value_ascii proc~json_add_string_by_path_value_ascii->interface~to_unicode proc~wrap_json_get_double_vec_by_path wrap_json_get_double_vec_by_path proc~wrap_json_get_double_vec_by_path->interface~to_unicode proc~wrap_json_valid_path wrap_json_valid_path proc~wrap_json_valid_path->interface~to_unicode proc~json_add_string_vec_by_path_value_ascii json_add_string_vec_by_path_value_ascii proc~json_add_string_vec_by_path_value_ascii->interface~to_unicode proc~wrap_json_value_add_double wrap_json_value_add_double proc~wrap_json_value_add_double->interface~to_unicode proc~wrap_json_get_double_by_path wrap_json_get_double_by_path proc~wrap_json_get_double_by_path->interface~to_unicode proc~wrap_json_file_load_from_string wrap_json_file_load_from_string proc~wrap_json_file_load_from_string->interface~to_unicode proc~wrap_json_get_by_path wrap_json_get_by_path proc~wrap_json_get_by_path->interface~to_unicode proc~wrap_json_value_create_string wrap_json_value_create_string proc~wrap_json_value_create_string->interface~to_unicode proc~wrap_json_add_logical_by_path wrap_json_add_logical_by_path proc~wrap_json_add_logical_by_path->interface~to_unicode proc~wrap_json_value_rename wrap_json_value_rename proc~wrap_json_value_rename->interface~to_unicode proc~wrap_json_value_create_null wrap_json_value_create_null proc~wrap_json_value_create_null->interface~to_unicode proc~wrap_json_file_get_alloc_string_vec wrap_json_file_get_alloc_string_vec proc~wrap_json_file_get_alloc_string_vec->interface~to_unicode proc~wrap_json_file_add_object wrap_json_file_add_object proc~wrap_json_file_add_object->interface~to_unicode proc~wrap_json_file_get_double wrap_json_file_get_double proc~wrap_json_file_get_double->interface~to_unicode proc~wrap_json_value_create_object wrap_json_value_create_object proc~wrap_json_value_create_object->interface~to_unicode proc~ucs4_neq_default ucs4_neq_default proc~ucs4_neq_default->interface~to_unicode proc~json_update_string_name_ascii json_update_string_name_ascii proc~json_update_string_name_ascii->interface~to_unicode proc~wrap_json_value_get_child_by_name wrap_json_value_get_child_by_name proc~wrap_json_value_get_child_by_name->interface~to_unicode proc~ucs4_comp_default ucs4_comp_default proc~ucs4_comp_default->interface~to_unicode proc~default_comp_ucs4 default_comp_ucs4 proc~default_comp_ucs4->interface~to_unicode proc~ucs4_join_default ucs4_join_default proc~ucs4_join_default->interface~to_unicode proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec proc~wrap_json_file_get_double_vec->interface~to_unicode proc~wrap_json_add_double_vec_by_path wrap_json_add_double_vec_by_path proc~wrap_json_add_double_vec_by_path->interface~to_unicode proc~wrap_json_value_create_logical wrap_json_value_create_logical proc~wrap_json_value_create_logical->interface~to_unicode proc~wrap_json_file_get_logical wrap_json_file_get_logical proc~wrap_json_file_get_logical->interface~to_unicode proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present proc~wrap_json_value_remove_if_present->interface~to_unicode proc~wrap_json_value_create_integer wrap_json_value_create_integer proc~wrap_json_value_create_integer->interface~to_unicode proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii proc~json_value_add_string_vec_val_ascii->interface~to_unicode proc~wrap_json_file_add_double_vec wrap_json_file_add_double_vec proc~wrap_json_file_add_double_vec->interface~to_unicode proc~wrap_json_file_add_integer wrap_json_file_add_integer proc~wrap_json_file_add_integer->interface~to_unicode proc~wrap_json_file_add_integer_vec wrap_json_file_add_integer_vec proc~wrap_json_file_add_integer_vec->interface~to_unicode proc~wrap_json_file_get_integer wrap_json_file_get_integer proc~wrap_json_file_get_integer->interface~to_unicode proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~json_rename_by_path_path_ascii json_rename_by_path_path_ascii proc~json_rename_by_path_path_ascii->interface~to_unicode proc~json_value_add_string_val_ascii json_value_add_string_val_ascii proc~json_value_add_string_val_ascii->interface~to_unicode proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~json_value_add_string_name_ascii json_value_add_string_name_ascii proc~json_value_add_string_name_ascii->interface~to_unicode proc~unescape_string unescape_string proc~unescape_string->interface~to_unicode proc~wrap_json_file_add_string_vec wrap_json_file_add_string_vec proc~wrap_json_file_add_string_vec->interface~to_unicode proc~wrap_json_file_add_logical_vec wrap_json_file_add_logical_vec proc~wrap_json_file_add_logical_vec->interface~to_unicode proc~wrap_json_add_double_by_path wrap_json_add_double_by_path proc~wrap_json_add_double_by_path->interface~to_unicode proc~wrap_json_file_add_string wrap_json_file_add_string proc~wrap_json_file_add_string->interface~to_unicode proc~json_update_string_val_ascii json_update_string_val_ascii proc~json_update_string_val_ascii->interface~to_unicode proc~wrap_json_add_integer_vec_by_path wrap_json_add_integer_vec_by_path proc~wrap_json_add_integer_vec_by_path->interface~to_unicode proc~wrap_json_get_array_by_path wrap_json_get_array_by_path proc~wrap_json_get_array_by_path->interface~to_unicode proc~wrap_json_add_string_vec_by_path wrap_json_add_string_vec_by_path proc~wrap_json_add_string_vec_by_path->interface~to_unicode proc~default_join_ucs4 default_join_ucs4 proc~default_join_ucs4->interface~to_unicode proc~wrap_json_add_string_by_path wrap_json_add_string_by_path proc~wrap_json_add_string_by_path->interface~to_unicode proc~wrap_json_get_alloc_string_vec_by_path wrap_json_get_alloc_string_vec_by_path proc~wrap_json_get_alloc_string_vec_by_path->interface~to_unicode proc~wrap_json_add_logical_vec_by_path wrap_json_add_logical_vec_by_path proc~wrap_json_add_logical_vec_by_path->interface~to_unicode proc~wrap_json_add_integer_by_path wrap_json_add_integer_by_path proc~wrap_json_add_integer_by_path->interface~to_unicode proc~default_neq_ucs4 default_neq_ucs4 proc~default_neq_ucs4->interface~to_unicode proc~wrap_json_add_member_by_path wrap_json_add_member_by_path proc~wrap_json_add_member_by_path->interface~to_unicode proc~wrap_json_create_by_path wrap_json_create_by_path proc~wrap_json_create_by_path->interface~to_unicode proc~wrap_json_file_add_logical wrap_json_file_add_logical proc~wrap_json_file_add_logical->interface~to_unicode proc~wrap_json_file_add_double wrap_json_file_add_double proc~wrap_json_file_add_double->interface~to_unicode proc~parse_string parse_string proc~parse_string->proc~unescape_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_uni Source Code pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni","title":"to_uni – JSON-Fortran","tags":"","loc":"proc/to_uni.html"},{"text":"private pure function to_uni_vec(str) Convert array of strings to unicode (CDK to CK). Note JW: may be able to remove this by making to_uni PURE ELEMENTAL ? Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Called By proc~~to_uni_vec~~CalledByGraph proc~to_uni_vec to_uni_vec interface~to_unicode to_unicode interface~to_unicode->proc~to_uni_vec proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec proc~wrap_json_file_get_string_vec->interface~to_unicode proc~wrap_json_update_integer wrap_json_update_integer proc~wrap_json_update_integer->interface~to_unicode proc~wrap_json_file_get_string wrap_json_file_get_string proc~wrap_json_file_get_string->interface~to_unicode proc~wrap_json_file_get_object wrap_json_file_get_object proc~wrap_json_file_get_object->interface~to_unicode proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec proc~wrap_json_value_add_double_vec->interface~to_unicode proc~wrap_json_matrix_info_by_path wrap_json_matrix_info_by_path proc~wrap_json_matrix_info_by_path->interface~to_unicode proc~wrap_json_get_string_by_path wrap_json_get_string_by_path proc~wrap_json_get_string_by_path->interface~to_unicode proc~wrap_json_get_string_vec_by_path wrap_json_get_string_vec_by_path proc~wrap_json_get_string_vec_by_path->interface~to_unicode proc~wrap_json_update_logical wrap_json_update_logical proc~wrap_json_update_logical->interface~to_unicode proc~wrap_json_get_logical_vec_by_path wrap_json_get_logical_vec_by_path proc~wrap_json_get_logical_vec_by_path->interface~to_unicode proc~wrap_json_throw_exception wrap_json_throw_exception proc~wrap_json_throw_exception->interface~to_unicode proc~wrap_json_get_integer_by_path wrap_json_get_integer_by_path proc~wrap_json_get_integer_by_path->interface~to_unicode proc~json_add_string_by_path_path_ascii json_add_string_by_path_path_ascii proc~json_add_string_by_path_path_ascii->interface~to_unicode proc~wrap_json_get_integer_vec_by_path wrap_json_get_integer_vec_by_path proc~wrap_json_get_integer_vec_by_path->interface~to_unicode proc~json_rename_by_path_name_ascii json_rename_by_path_name_ascii proc~json_rename_by_path_name_ascii->interface~to_unicode proc~wrap_json_info_by_path wrap_json_info_by_path proc~wrap_json_info_by_path->interface~to_unicode proc~wrap_json_file_valid_path_op wrap_json_file_valid_path_op proc~wrap_json_file_valid_path_op->interface~to_unicode proc~wrap_json_rename_by_path wrap_json_rename_by_path proc~wrap_json_rename_by_path->interface~to_unicode proc~wrap_json_update_string wrap_json_update_string proc~wrap_json_update_string->interface~to_unicode proc~wrap_json_value_create_array wrap_json_value_create_array proc~wrap_json_value_create_array->interface~to_unicode proc~wrap_json_file_update_integer wrap_json_file_update_integer proc~wrap_json_file_update_integer->interface~to_unicode proc~wrap_json_parse_string wrap_json_parse_string proc~wrap_json_parse_string->interface~to_unicode proc~wrap_json_update_double wrap_json_update_double proc~wrap_json_update_double->interface~to_unicode proc~json_file_rename_path_ascii json_file_rename_path_ascii proc~json_file_rename_path_ascii->interface~to_unicode proc~wrap_json_value_create_double wrap_json_value_create_double proc~wrap_json_value_create_double->interface~to_unicode proc~wrap_json_value_add_integer wrap_json_value_add_integer proc~wrap_json_value_add_integer->interface~to_unicode proc~wrap_json_value_add_string wrap_json_value_add_string proc~wrap_json_value_add_string->interface~to_unicode proc~wrap_json_file_variable_matrix_info wrap_json_file_variable_matrix_info proc~wrap_json_file_variable_matrix_info->interface~to_unicode proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec proc~wrap_json_value_add_string_vec->interface~to_unicode proc~wrap_json_value_add_logical wrap_json_value_add_logical proc~wrap_json_value_add_logical->interface~to_unicode proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~wrap_json_file_update_real wrap_json_file_update_real proc~wrap_json_file_update_real->interface~to_unicode proc~wrap_json_value_add_null wrap_json_value_add_null proc~wrap_json_value_add_null->interface~to_unicode proc~wrap_json_file_update_logical wrap_json_file_update_logical proc~wrap_json_file_update_logical->interface~to_unicode proc~wrap_json_file_update_string wrap_json_file_update_string proc~wrap_json_file_update_string->interface~to_unicode proc~wrap_json_file_variable_info wrap_json_file_variable_info proc~wrap_json_file_variable_info->interface~to_unicode proc~wrap_json_file_rename wrap_json_file_rename proc~wrap_json_file_rename->interface~to_unicode proc~json_file_add_string_vec_vec_ascii json_file_add_string_vec_vec_ascii proc~json_file_add_string_vec_vec_ascii->interface~to_unicode proc~json_file_add_string_path_ascii json_file_add_string_path_ascii proc~json_file_add_string_path_ascii->interface~to_unicode proc~json_file_update_string_name_ascii json_file_update_string_name_ascii proc~json_file_update_string_name_ascii->interface~to_unicode proc~json_file_add_string_vec_path_ascii json_file_add_string_vec_path_ascii proc~json_file_add_string_vec_path_ascii->interface~to_unicode proc~json_file_add_string_value_ascii json_file_add_string_value_ascii proc~json_file_add_string_value_ascii->interface~to_unicode proc~wrap_json_file_valid_path wrap_json_file_valid_path proc~wrap_json_file_valid_path->interface~to_unicode proc~wrap_json_get_logical_by_path wrap_json_get_logical_by_path proc~wrap_json_get_logical_by_path->interface~to_unicode proc~json_file_rename_name_ascii json_file_rename_name_ascii proc~json_file_rename_name_ascii->interface~to_unicode proc~json_file_update_string_val_ascii json_file_update_string_val_ascii proc~json_file_update_string_val_ascii->interface~to_unicode proc~json_add_string_vec_by_path_path_ascii json_add_string_vec_by_path_path_ascii proc~json_add_string_vec_by_path_path_ascii->interface~to_unicode proc~json_add_string_by_path_value_ascii json_add_string_by_path_value_ascii proc~json_add_string_by_path_value_ascii->interface~to_unicode proc~wrap_json_get_double_vec_by_path wrap_json_get_double_vec_by_path proc~wrap_json_get_double_vec_by_path->interface~to_unicode proc~wrap_json_valid_path wrap_json_valid_path proc~wrap_json_valid_path->interface~to_unicode proc~json_add_string_vec_by_path_value_ascii json_add_string_vec_by_path_value_ascii proc~json_add_string_vec_by_path_value_ascii->interface~to_unicode proc~wrap_json_value_add_double wrap_json_value_add_double proc~wrap_json_value_add_double->interface~to_unicode proc~wrap_json_get_double_by_path wrap_json_get_double_by_path proc~wrap_json_get_double_by_path->interface~to_unicode proc~wrap_json_file_load_from_string wrap_json_file_load_from_string proc~wrap_json_file_load_from_string->interface~to_unicode proc~wrap_json_get_by_path wrap_json_get_by_path proc~wrap_json_get_by_path->interface~to_unicode proc~wrap_json_value_create_string wrap_json_value_create_string proc~wrap_json_value_create_string->interface~to_unicode proc~wrap_json_add_logical_by_path wrap_json_add_logical_by_path proc~wrap_json_add_logical_by_path->interface~to_unicode proc~wrap_json_value_rename wrap_json_value_rename proc~wrap_json_value_rename->interface~to_unicode proc~wrap_json_value_create_null wrap_json_value_create_null proc~wrap_json_value_create_null->interface~to_unicode proc~wrap_json_file_get_alloc_string_vec wrap_json_file_get_alloc_string_vec proc~wrap_json_file_get_alloc_string_vec->interface~to_unicode proc~wrap_json_file_add_object wrap_json_file_add_object proc~wrap_json_file_add_object->interface~to_unicode proc~wrap_json_file_get_double wrap_json_file_get_double proc~wrap_json_file_get_double->interface~to_unicode proc~wrap_json_value_create_object wrap_json_value_create_object proc~wrap_json_value_create_object->interface~to_unicode proc~ucs4_neq_default ucs4_neq_default proc~ucs4_neq_default->interface~to_unicode proc~json_update_string_name_ascii json_update_string_name_ascii proc~json_update_string_name_ascii->interface~to_unicode proc~wrap_json_value_get_child_by_name wrap_json_value_get_child_by_name proc~wrap_json_value_get_child_by_name->interface~to_unicode proc~ucs4_comp_default ucs4_comp_default proc~ucs4_comp_default->interface~to_unicode proc~default_comp_ucs4 default_comp_ucs4 proc~default_comp_ucs4->interface~to_unicode proc~ucs4_join_default ucs4_join_default proc~ucs4_join_default->interface~to_unicode proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec proc~wrap_json_file_get_double_vec->interface~to_unicode proc~wrap_json_add_double_vec_by_path wrap_json_add_double_vec_by_path proc~wrap_json_add_double_vec_by_path->interface~to_unicode proc~wrap_json_value_create_logical wrap_json_value_create_logical proc~wrap_json_value_create_logical->interface~to_unicode proc~wrap_json_file_get_logical wrap_json_file_get_logical proc~wrap_json_file_get_logical->interface~to_unicode proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present proc~wrap_json_value_remove_if_present->interface~to_unicode proc~wrap_json_value_create_integer wrap_json_value_create_integer proc~wrap_json_value_create_integer->interface~to_unicode proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii proc~json_value_add_string_vec_val_ascii->interface~to_unicode proc~wrap_json_file_add_double_vec wrap_json_file_add_double_vec proc~wrap_json_file_add_double_vec->interface~to_unicode proc~wrap_json_file_add_integer wrap_json_file_add_integer proc~wrap_json_file_add_integer->interface~to_unicode proc~wrap_json_file_add_integer_vec wrap_json_file_add_integer_vec proc~wrap_json_file_add_integer_vec->interface~to_unicode proc~wrap_json_file_get_integer wrap_json_file_get_integer proc~wrap_json_file_get_integer->interface~to_unicode proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~json_rename_by_path_path_ascii json_rename_by_path_path_ascii proc~json_rename_by_path_path_ascii->interface~to_unicode proc~json_value_add_string_val_ascii json_value_add_string_val_ascii proc~json_value_add_string_val_ascii->interface~to_unicode proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~json_value_add_string_name_ascii json_value_add_string_name_ascii proc~json_value_add_string_name_ascii->interface~to_unicode proc~unescape_string unescape_string proc~unescape_string->interface~to_unicode proc~wrap_json_file_add_string_vec wrap_json_file_add_string_vec proc~wrap_json_file_add_string_vec->interface~to_unicode proc~wrap_json_file_add_logical_vec wrap_json_file_add_logical_vec proc~wrap_json_file_add_logical_vec->interface~to_unicode proc~wrap_json_add_double_by_path wrap_json_add_double_by_path proc~wrap_json_add_double_by_path->interface~to_unicode proc~wrap_json_file_add_string wrap_json_file_add_string proc~wrap_json_file_add_string->interface~to_unicode proc~json_update_string_val_ascii json_update_string_val_ascii proc~json_update_string_val_ascii->interface~to_unicode proc~wrap_json_add_integer_vec_by_path wrap_json_add_integer_vec_by_path proc~wrap_json_add_integer_vec_by_path->interface~to_unicode proc~wrap_json_get_array_by_path wrap_json_get_array_by_path proc~wrap_json_get_array_by_path->interface~to_unicode proc~wrap_json_add_string_vec_by_path wrap_json_add_string_vec_by_path proc~wrap_json_add_string_vec_by_path->interface~to_unicode proc~default_join_ucs4 default_join_ucs4 proc~default_join_ucs4->interface~to_unicode proc~wrap_json_add_string_by_path wrap_json_add_string_by_path proc~wrap_json_add_string_by_path->interface~to_unicode proc~wrap_json_get_alloc_string_vec_by_path wrap_json_get_alloc_string_vec_by_path proc~wrap_json_get_alloc_string_vec_by_path->interface~to_unicode proc~wrap_json_add_logical_vec_by_path wrap_json_add_logical_vec_by_path proc~wrap_json_add_logical_vec_by_path->interface~to_unicode proc~wrap_json_add_integer_by_path wrap_json_add_integer_by_path proc~wrap_json_add_integer_by_path->interface~to_unicode proc~default_neq_ucs4 default_neq_ucs4 proc~default_neq_ucs4->interface~to_unicode proc~wrap_json_add_member_by_path wrap_json_add_member_by_path proc~wrap_json_add_member_by_path->interface~to_unicode proc~wrap_json_create_by_path wrap_json_create_by_path proc~wrap_json_create_by_path->interface~to_unicode proc~wrap_json_file_add_logical wrap_json_file_add_logical proc~wrap_json_file_add_logical->interface~to_unicode proc~wrap_json_file_add_double wrap_json_file_add_double proc~wrap_json_file_add_double->interface~to_unicode proc~parse_string parse_string proc~parse_string->proc~unescape_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_uni_vec Source Code pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec","title":"to_uni_vec – JSON-Fortran","tags":"","loc":"proc/to_uni_vec.html"},{"text":"private pure elemental function ucs4_comp_default(ucs4_str, def_str) result(res) CK == CDK operator. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Calls proc~~ucs4_comp_default~~CallsGraph proc~ucs4_comp_default ucs4_comp_default interface~to_unicode to_unicode proc~ucs4_comp_default->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ucs4_comp_default Source Code pure elemental function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default","title":"ucs4_comp_default – JSON-Fortran","tags":"","loc":"proc/ucs4_comp_default.html"},{"text":"private pure function ucs4_join_default(ucs4_str, def_str) result(res) CK // CDK operator. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) Calls proc~~ucs4_join_default~~CallsGraph proc~ucs4_join_default ucs4_join_default interface~to_unicode to_unicode proc~ucs4_join_default->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ucs4_join_default Source Code pure function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default","title":"ucs4_join_default – JSON-Fortran","tags":"","loc":"proc/ucs4_join_default.html"},{"text":"private pure elemental function ucs4_neq_default(ucs4_str, def_str) result(res) CK /= CDK operator. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Calls proc~~ucs4_neq_default~~CallsGraph proc~ucs4_neq_default ucs4_neq_default interface~to_unicode to_unicode proc~ucs4_neq_default->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ucs4_neq_default Source Code pure elemental function ucs4_neq_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str /= to_unicode ( def_str ) ) end function ucs4_neq_default","title":"ucs4_neq_default – JSON-Fortran","tags":"","loc":"proc/ucs4_neq_default.html"},{"text":"public pure function valid_json_hex(str) result(valid) Returns true if the string is a valid 4-digit hex string. Examples valid_json_hex ( '0000' ) !returns true valid_json_hex ( 'ABC4' ) !returns true valid_json_hex ( 'AB' ) !returns false (< 4 characters) valid_json_hex ( 'WXYZ' ) !returns false (invalid characters) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Called By proc~~valid_json_hex~~CalledByGraph proc~valid_json_hex valid_json_hex proc~escape_string escape_string proc~escape_string->proc~valid_json_hex proc~parse_string parse_string proc~parse_string->proc~valid_json_hex proc~json_get_string json_get_string proc~json_get_string->proc~escape_string proc~json_value_print json_value_print proc~json_value_print->proc~escape_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code valid_json_hex Source Code pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n !! length of `str` integer ( IK ) :: i !! counter !> an array of the valid hex characters character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex","title":"valid_json_hex – JSON-Fortran","tags":"","loc":"proc/valid_json_hex.html"},{"text":"private subroutine compact_real_string(str) Compact a string representing a real number, so that\n  the same value is displayed with fewer characters. See also real_to_string Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(inout) :: str string representation of a real number. Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~real_to_string real_to_string proc~real_to_string->proc~compact_real_string proc~json_get_string json_get_string proc~json_get_string->proc~real_to_string proc~json_value_print json_value_print proc~json_value_print->proc~real_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code compact_real_string Source Code subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand character ( kind = CK , len = len ( str )) :: expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start integer ( IK ) :: decimal_pos integer ( IK ) :: sig_trim integer ( IK ) :: exp_trim integer ( IK ) :: i !! counter str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string","title":"compact_real_string – JSON-Fortran","tags":"","loc":"proc/compact_real_string.html"},{"text":"public subroutine escape_string(str_in, str_out, escape_solidus) Add the escape characters to a string for adding to JSON . Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out logical(kind=LK), intent(in) :: escape_solidus if the solidus (forward slash)\n is also to be escaped Calls proc~~escape_string~~CallsGraph proc~escape_string escape_string proc~valid_json_hex valid_json_hex proc~escape_string->proc~valid_json_hex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~escape_string~~CalledByGraph proc~escape_string escape_string proc~json_get_string json_get_string proc~json_get_string->proc~escape_string proc~json_value_print json_value_print proc~json_value_print->proc~escape_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code escape_string Source Code subroutine escape_string ( str_in , str_out , escape_solidus ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out logical ( LK ), intent ( in ) :: escape_solidus !! if the solidus (forward slash) !! is also to be escaped integer ( IK ) :: i !! counter integer ( IK ) :: ipos !! accumulated string size !! (so we can allocate it in chunks for !! greater runtime efficiency) character ( kind = CK , len = 1 ) :: c !! for reading `str_in` one character at a time. #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! workaround for bug in gfortran 6.1 #endif logical :: to_be_escaped !! if there are characters to be escaped character ( kind = CK , len =* ), parameter :: specials_no_slash = quotation_mark // & backslash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab character ( kind = CK , len =* ), parameter :: specials = specials_no_slash // slash !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( escape_solidus ) then to_be_escaped = scan ( str_in , specials ) > 0 else to_be_escaped = scan ( str_in , specials_no_slash ) > 0 end if if ( to_be_escaped ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( backslash ) !test for unicode sequence: '\\uXXXX' ![don't add an extra '\\' for those] if ( i + 5 <= len ( str_in )) then if ( str_in ( i + 1 : i + 1 ) == CK_ 'u' . and . & valid_json_hex ( str_in ( i + 2 : i + 5 ))) then str_out ( ipos : ipos ) = c ipos = ipos + 1 cycle end if end if str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( quotation_mark ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( slash ) if ( escape_solidus ) then str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 else str_out ( ipos : ipos ) = c ipos = ipos + 1 end if case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = CK_ '' else #if defined __GFORTRAN__ tmp = str_out ( 1 : ipos - 1 ) !workaround for bug in gfortran 6.1 str_out = tmp #else str_out = str_out ( 1 : ipos - 1 ) !original #endif end if end if else str_out = str_in end if end subroutine escape_string","title":"escape_string – JSON-Fortran","tags":"","loc":"proc/escape_string.html"},{"text":"public pure subroutine integer_to_string(ival, int_fmt, str) Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CDK,len=*), intent(in) :: int_fmt format for integers character(kind=CK,len=*), intent(out) :: str ival converted to a string. Called By proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~json_get_string json_get_string proc~json_get_string->proc~integer_to_string proc~json_get_path json_get_path proc~json_get_path->proc~integer_to_string proc~json_create_by_path json_create_by_path proc~json_create_by_path->proc~integer_to_string proc~json_get_by_path json_get_by_path proc~json_get_by_path->proc~integer_to_string proc~annotate_invalid_json annotate_invalid_json proc~annotate_invalid_json->proc~integer_to_string proc~json_value_print json_value_print proc~json_value_print->proc~integer_to_string proc~push_char push_char proc~push_char->proc~integer_to_string proc~wrap_json_get_path wrap_json_get_path proc~wrap_json_get_path->proc~json_get_path Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code integer_to_string Source Code pure subroutine integer_to_string ( ival , int_fmt , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CDK , len =* ), intent ( in ) :: int_fmt !! format for integers character ( kind = CK , len =* ), intent ( out ) :: str !! `ival` converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string","title":"integer_to_string – JSON-Fortran","tags":"","loc":"proc/integer_to_string.html"},{"text":"public subroutine real_to_string(rval, real_fmt, compact_real, str) Convert a real value to a string. Modified Izaak Beekman : 02/24/2015 : added the compact option. Jacob Williams : 10/27/2015 : added the star option. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CDK,len=*), intent(in) :: real_fmt format for real numbers logical(kind=LK), intent(in) :: compact_real compact the string so that it is\n displayed with fewer characters character(kind=CK,len=*), intent(out) :: str rval converted to a string. Calls proc~~real_to_string~~CallsGraph proc~real_to_string real_to_string proc~compact_real_string compact_real_string proc~real_to_string->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~real_to_string~~CalledByGraph proc~real_to_string real_to_string proc~json_get_string json_get_string proc~json_get_string->proc~real_to_string proc~json_value_print json_value_print proc~json_value_print->proc~real_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code real_to_string Source Code subroutine real_to_string ( rval , real_fmt , compact_real , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CDK , len =* ), intent ( in ) :: real_fmt !! format for real numbers logical ( LK ), intent ( in ) :: compact_real !! compact the string so that it is !! displayed with fewer characters character ( kind = CK , len =* ), intent ( out ) :: str !! `rval` converted to a string. integer ( IK ) :: istat if ( real_fmt == star ) then write ( str , fmt =* , iostat = istat ) rval else write ( str , fmt = real_fmt , iostat = istat ) rval end if if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string","title":"real_to_string – JSON-Fortran","tags":"","loc":"proc/real_to_string.html"},{"text":"public pure subroutine replace_string(str, s1, s2) Replace all occurrences of s1 in str with s2 . A case-sensitive match is used. Note str must be allocated. Arguments Type Intent Optional Attributes Name character(kind=CK,len=:), intent(inout), allocatable :: str character(kind=CK,len=*), intent(in) :: s1 character(kind=CK,len=*), intent(in) :: s2 Called By proc~~replace_string~~CalledByGraph proc~replace_string replace_string proc~decode_rfc6901 decode_rfc6901 proc~decode_rfc6901->proc~replace_string proc~encode_rfc6901 encode_rfc6901 proc~encode_rfc6901->proc~replace_string proc~json_get_by_path_rfc6901 json_get_by_path_rfc6901 proc~json_get_by_path_rfc6901->proc~decode_rfc6901 proc~json_get_path json_get_path proc~json_get_path->proc~encode_rfc6901 proc~wrap_json_get_path wrap_json_get_path proc~wrap_json_get_path->proc~json_get_path Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code replace_string Source Code pure subroutine replace_string ( str , s1 , s2 ) implicit none character ( kind = CK , len = :), allocatable , intent ( inout ) :: str character ( kind = CK , len =* ), intent ( in ) :: s1 character ( kind = CK , len =* ), intent ( in ) :: s2 character ( kind = CK , len = :), allocatable :: tmp !! temporary string for accumulating result integer ( IK ) :: i !! counter integer ( IK ) :: n !! for accumulating the string integer ( IK ) :: ilen !! length of `str` string integer ( IK ) :: ilen1 !! length of `s1` string if ( len ( str ) > 0 ) then tmp = CK_ '' ! initialize ilen1 = len ( s1 ) !     . ! '123ab789' do ilen = len ( str ) i = index ( str , s1 ) if ( i > 0 ) then if ( i > 1 ) tmp = tmp // str ( 1 : i - 1 ) tmp = tmp // s2 ! replace s1 with s2 in new string n = i + ilen1 ! start of remainder of str to keep if ( n <= ilen ) then str = str ( n : ilen ) else ! done exit end if else ! done: get remainder of string tmp = tmp // str exit end if end do str = tmp end if end subroutine replace_string","title":"replace_string – JSON-Fortran","tags":"","loc":"proc/replace_string.html"},{"text":"public subroutine string_to_integer(str, ival, status_ok) Convert a string into an integer. History Jacob Williams : 12/10/2013 : Rewrote original parse_integer routine.\n    Added error checking. Modified by Izaak Beekman Jacob Williams : 2/4/2017 : moved core logic to this routine. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to conver to an integer integer(kind=IK), intent(out) :: ival the integer value logical(kind=LK), intent(out) :: status_ok true if there were no errors Called By proc~~string_to_integer~~CalledByGraph proc~string_to_integer string_to_integer proc~string_to_int string_to_int proc~string_to_int->proc~string_to_integer proc~json_get_by_path_rfc6901 json_get_by_path_rfc6901 proc~json_get_by_path_rfc6901->proc~string_to_integer proc~json_get_by_path_jsonpath_bracket json_get_by_path_jsonpath_bracket proc~json_get_by_path_jsonpath_bracket->proc~string_to_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code string_to_integer Source Code subroutine string_to_integer ( str , ival , status_ok ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! the string to conver to an integer integer ( IK ), intent ( out ) :: ival !! the integer value logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer ! error check: status_ok = ( ierr == 0 ) if (. not . status_ok ) ival = 0_IK end subroutine string_to_integer","title":"string_to_integer – JSON-Fortran","tags":"","loc":"proc/string_to_integer.html"},{"text":"public subroutine string_to_real(str, rval, status_ok) Convert a string into a real(RK) . History Jacob Williams, 10/27/2015 : Now using fmt=* , rather than fmt=real_fmt , since it doesn't work for some unusual cases\n    (e.g., when str='1E-5' ). Jacob Williams : 2/6/2017 : moved core logic to this routine. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str real(kind=RK), intent(out) :: rval logical(kind=LK), intent(out) :: status_ok true if there were no errors Called By proc~~string_to_real~~CalledByGraph proc~string_to_real string_to_real proc~string_to_dble string_to_dble proc~string_to_dble->proc~string_to_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code string_to_real Source Code subroutine string_to_real ( str , rval , status_ok ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ), intent ( out ) :: rval logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors integer ( IK ) :: ierr !! read iostat error code read ( str , fmt =* , iostat = ierr ) rval status_ok = ( ierr == 0 ) if (. not . status_ok ) rval = 0.0_RK end subroutine string_to_real","title":"string_to_real – JSON-Fortran","tags":"","loc":"proc/string_to_real.html"},{"text":"public subroutine unescape_string(str_in, str_out, error_message) Remove the escape characters from a JSON string and return it. The escaped characters are denoted by the \\ character: \\\" - quotation mark \\\\ - reverse solidus \\/ - solidus \\b - backspace \\f - formfeed \\n - newline (LF) \\r - carriage return (CR) \\t - horizontal tab \\uXXXX - 4 hexadecimal digits Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in string as stored in a json_value character(kind=CK,len=:), intent(out), allocatable :: str_out decoded string character(kind=CK,len=:), intent(out), allocatable :: error_message will be allocated if there was an error Calls proc~~unescape_string~~CallsGraph proc~unescape_string unescape_string interface~to_unicode to_unicode proc~unescape_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~unescape_string~~CalledByGraph proc~unescape_string unescape_string proc~parse_string parse_string proc~parse_string->proc~unescape_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code unescape_string Source Code subroutine unescape_string ( str_in , str_out , error_message ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in !! string as stored in a [[json_value]] character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out !! decoded string character ( kind = CK , len = :), allocatable , intent ( out ) :: error_message !! will be allocated if there was an error integer :: i !! counter integer :: n !! length of str_in integer :: m !! length of str_out character ( kind = CK , len = 1 ) :: c !! for scanning each character in string #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! for GFortran bug workaround #endif if ( scan ( str_in , backslash ) > 0 ) then !there is at least one escape character, so process this string: n = len ( str_in ) str_out = repeat ( space , n ) !size the output string (will be trimmed later) m = 0 !counter in str_out i = 0 !counter in str_in do i = i + 1 if ( i > n ) exit ! finished c = str_in ( i : i ) ! get next character in the string if ( c == backslash ) then if ( i < n ) then i = i + 1 c = str_in ( i : i ) !character after the escape if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then select case ( c ) case ( quotation_mark , backslash , slash ) !use d as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select m = m + 1 str_out ( m : m ) = c else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just returning them as is ![not checking to see if it is a valid hex value] ! ! Example: !   123456 !   \\uXXXX if ( i + 4 <= n ) then m = m + 1 str_out ( m : m + 5 ) = str_in ( i - 1 : i + 4 ) i = i + 4 m = m + 5 else error_message = 'Error in unescape_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // str_in ( i - 1 :) if ( allocated ( str_out )) deallocate ( str_out ) return end if else !unknown escape character error_message = 'Error in unescape_string:' // & ' unknown escape sequence in string \"' // & trim ( str_in ) // '\" [' // backslash // c // ']' if ( allocated ( str_out )) deallocate ( str_out ) return end if else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] m = m + 1 str_out ( m : m ) = c end if else m = m + 1 str_out ( m : m ) = c end if end do !trim trailing space: #if defined __GFORTRAN__ ! workaround for Gfortran 6.1.0 bug tmp = str_out ( 1 : m ) str_out = tmp #else str_out = str_out ( 1 : m ) #endif else !there are no escape characters, so return as is: str_out = str_in end if end subroutine unescape_string","title":"unescape_string – JSON-Fortran","tags":"","loc":"proc/unescape_string.html"},{"text":"public interface to_unicode Convert a 'DEFAULT' kind character input to\n  'ISO_10646' kind and return it Calls interface~~to_unicode~~CallsGraph interface~to_unicode to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By interface~~to_unicode~~CalledByGraph interface~to_unicode to_unicode proc~wrap_json_file_get_string_vec wrap_json_file_get_string_vec proc~wrap_json_file_get_string_vec->interface~to_unicode proc~wrap_json_update_integer wrap_json_update_integer proc~wrap_json_update_integer->interface~to_unicode proc~wrap_json_file_get_string wrap_json_file_get_string proc~wrap_json_file_get_string->interface~to_unicode proc~wrap_json_file_get_object wrap_json_file_get_object proc~wrap_json_file_get_object->interface~to_unicode proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec proc~wrap_json_value_add_double_vec->interface~to_unicode proc~wrap_json_matrix_info_by_path wrap_json_matrix_info_by_path proc~wrap_json_matrix_info_by_path->interface~to_unicode proc~wrap_json_get_string_by_path wrap_json_get_string_by_path proc~wrap_json_get_string_by_path->interface~to_unicode proc~wrap_json_get_string_vec_by_path wrap_json_get_string_vec_by_path proc~wrap_json_get_string_vec_by_path->interface~to_unicode proc~wrap_json_update_logical wrap_json_update_logical proc~wrap_json_update_logical->interface~to_unicode proc~wrap_json_get_logical_vec_by_path wrap_json_get_logical_vec_by_path proc~wrap_json_get_logical_vec_by_path->interface~to_unicode proc~wrap_json_throw_exception wrap_json_throw_exception proc~wrap_json_throw_exception->interface~to_unicode proc~wrap_json_get_integer_by_path wrap_json_get_integer_by_path proc~wrap_json_get_integer_by_path->interface~to_unicode proc~json_add_string_by_path_path_ascii json_add_string_by_path_path_ascii proc~json_add_string_by_path_path_ascii->interface~to_unicode proc~wrap_json_get_integer_vec_by_path wrap_json_get_integer_vec_by_path proc~wrap_json_get_integer_vec_by_path->interface~to_unicode proc~json_rename_by_path_name_ascii json_rename_by_path_name_ascii proc~json_rename_by_path_name_ascii->interface~to_unicode proc~wrap_json_info_by_path wrap_json_info_by_path proc~wrap_json_info_by_path->interface~to_unicode proc~wrap_json_file_valid_path_op wrap_json_file_valid_path_op proc~wrap_json_file_valid_path_op->interface~to_unicode proc~wrap_json_rename_by_path wrap_json_rename_by_path proc~wrap_json_rename_by_path->interface~to_unicode proc~wrap_json_update_string wrap_json_update_string proc~wrap_json_update_string->interface~to_unicode proc~wrap_json_value_create_array wrap_json_value_create_array proc~wrap_json_value_create_array->interface~to_unicode proc~wrap_json_file_update_integer wrap_json_file_update_integer proc~wrap_json_file_update_integer->interface~to_unicode proc~wrap_json_parse_string wrap_json_parse_string proc~wrap_json_parse_string->interface~to_unicode proc~wrap_json_update_double wrap_json_update_double proc~wrap_json_update_double->interface~to_unicode proc~json_file_rename_path_ascii json_file_rename_path_ascii proc~json_file_rename_path_ascii->interface~to_unicode proc~wrap_json_value_create_double wrap_json_value_create_double proc~wrap_json_value_create_double->interface~to_unicode proc~wrap_json_value_add_integer wrap_json_value_add_integer proc~wrap_json_value_add_integer->interface~to_unicode proc~wrap_json_value_add_string wrap_json_value_add_string proc~wrap_json_value_add_string->interface~to_unicode proc~wrap_json_file_variable_matrix_info wrap_json_file_variable_matrix_info proc~wrap_json_file_variable_matrix_info->interface~to_unicode proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec proc~wrap_json_value_add_string_vec->interface~to_unicode proc~wrap_json_value_add_logical wrap_json_value_add_logical proc~wrap_json_value_add_logical->interface~to_unicode proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~wrap_json_file_update_real wrap_json_file_update_real proc~wrap_json_file_update_real->interface~to_unicode proc~wrap_json_value_add_null wrap_json_value_add_null proc~wrap_json_value_add_null->interface~to_unicode proc~wrap_json_file_update_logical wrap_json_file_update_logical proc~wrap_json_file_update_logical->interface~to_unicode proc~wrap_json_file_update_string wrap_json_file_update_string proc~wrap_json_file_update_string->interface~to_unicode proc~wrap_json_file_variable_info wrap_json_file_variable_info proc~wrap_json_file_variable_info->interface~to_unicode proc~wrap_json_file_rename wrap_json_file_rename proc~wrap_json_file_rename->interface~to_unicode proc~json_file_add_string_vec_vec_ascii json_file_add_string_vec_vec_ascii proc~json_file_add_string_vec_vec_ascii->interface~to_unicode proc~json_file_add_string_path_ascii json_file_add_string_path_ascii proc~json_file_add_string_path_ascii->interface~to_unicode proc~json_file_update_string_name_ascii json_file_update_string_name_ascii proc~json_file_update_string_name_ascii->interface~to_unicode proc~json_file_add_string_vec_path_ascii json_file_add_string_vec_path_ascii proc~json_file_add_string_vec_path_ascii->interface~to_unicode proc~json_file_add_string_value_ascii json_file_add_string_value_ascii proc~json_file_add_string_value_ascii->interface~to_unicode proc~wrap_json_file_valid_path wrap_json_file_valid_path proc~wrap_json_file_valid_path->interface~to_unicode proc~wrap_json_get_logical_by_path wrap_json_get_logical_by_path proc~wrap_json_get_logical_by_path->interface~to_unicode proc~json_file_rename_name_ascii json_file_rename_name_ascii proc~json_file_rename_name_ascii->interface~to_unicode proc~json_file_update_string_val_ascii json_file_update_string_val_ascii proc~json_file_update_string_val_ascii->interface~to_unicode proc~json_add_string_vec_by_path_path_ascii json_add_string_vec_by_path_path_ascii proc~json_add_string_vec_by_path_path_ascii->interface~to_unicode proc~json_add_string_by_path_value_ascii json_add_string_by_path_value_ascii proc~json_add_string_by_path_value_ascii->interface~to_unicode proc~wrap_json_get_double_vec_by_path wrap_json_get_double_vec_by_path proc~wrap_json_get_double_vec_by_path->interface~to_unicode proc~wrap_json_valid_path wrap_json_valid_path proc~wrap_json_valid_path->interface~to_unicode proc~json_add_string_vec_by_path_value_ascii json_add_string_vec_by_path_value_ascii proc~json_add_string_vec_by_path_value_ascii->interface~to_unicode proc~wrap_json_value_add_double wrap_json_value_add_double proc~wrap_json_value_add_double->interface~to_unicode proc~wrap_json_get_double_by_path wrap_json_get_double_by_path proc~wrap_json_get_double_by_path->interface~to_unicode proc~wrap_json_file_load_from_string wrap_json_file_load_from_string proc~wrap_json_file_load_from_string->interface~to_unicode proc~wrap_json_get_by_path wrap_json_get_by_path proc~wrap_json_get_by_path->interface~to_unicode proc~wrap_json_value_create_string wrap_json_value_create_string proc~wrap_json_value_create_string->interface~to_unicode proc~wrap_json_add_logical_by_path wrap_json_add_logical_by_path proc~wrap_json_add_logical_by_path->interface~to_unicode proc~wrap_json_value_rename wrap_json_value_rename proc~wrap_json_value_rename->interface~to_unicode proc~wrap_json_value_create_null wrap_json_value_create_null proc~wrap_json_value_create_null->interface~to_unicode proc~wrap_json_file_get_alloc_string_vec wrap_json_file_get_alloc_string_vec proc~wrap_json_file_get_alloc_string_vec->interface~to_unicode proc~wrap_json_file_add_object wrap_json_file_add_object proc~wrap_json_file_add_object->interface~to_unicode proc~wrap_json_file_get_double wrap_json_file_get_double proc~wrap_json_file_get_double->interface~to_unicode proc~wrap_json_value_create_object wrap_json_value_create_object proc~wrap_json_value_create_object->interface~to_unicode proc~ucs4_neq_default ucs4_neq_default proc~ucs4_neq_default->interface~to_unicode proc~json_update_string_name_ascii json_update_string_name_ascii proc~json_update_string_name_ascii->interface~to_unicode proc~wrap_json_value_get_child_by_name wrap_json_value_get_child_by_name proc~wrap_json_value_get_child_by_name->interface~to_unicode proc~ucs4_comp_default ucs4_comp_default proc~ucs4_comp_default->interface~to_unicode proc~default_comp_ucs4 default_comp_ucs4 proc~default_comp_ucs4->interface~to_unicode proc~ucs4_join_default ucs4_join_default proc~ucs4_join_default->interface~to_unicode proc~wrap_json_file_get_double_vec wrap_json_file_get_double_vec proc~wrap_json_file_get_double_vec->interface~to_unicode proc~wrap_json_add_double_vec_by_path wrap_json_add_double_vec_by_path proc~wrap_json_add_double_vec_by_path->interface~to_unicode proc~wrap_json_value_create_logical wrap_json_value_create_logical proc~wrap_json_value_create_logical->interface~to_unicode proc~wrap_json_file_get_logical wrap_json_file_get_logical proc~wrap_json_file_get_logical->interface~to_unicode proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present proc~wrap_json_value_remove_if_present->interface~to_unicode proc~wrap_json_value_create_integer wrap_json_value_create_integer proc~wrap_json_value_create_integer->interface~to_unicode proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii proc~json_value_add_string_vec_val_ascii->interface~to_unicode proc~wrap_json_file_add_double_vec wrap_json_file_add_double_vec proc~wrap_json_file_add_double_vec->interface~to_unicode proc~wrap_json_file_add_integer wrap_json_file_add_integer proc~wrap_json_file_add_integer->interface~to_unicode proc~wrap_json_file_add_integer_vec wrap_json_file_add_integer_vec proc~wrap_json_file_add_integer_vec->interface~to_unicode proc~wrap_json_file_get_integer wrap_json_file_get_integer proc~wrap_json_file_get_integer->interface~to_unicode proc~wrap_json_file_get_integer_vec wrap_json_file_get_integer_vec proc~wrap_json_file_get_integer_vec->interface~to_unicode proc~wrap_json_file_get_logical_vec wrap_json_file_get_logical_vec proc~wrap_json_file_get_logical_vec->interface~to_unicode proc~json_rename_by_path_path_ascii json_rename_by_path_path_ascii proc~json_rename_by_path_path_ascii->interface~to_unicode proc~json_value_add_string_val_ascii json_value_add_string_val_ascii proc~json_value_add_string_val_ascii->interface~to_unicode proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~json_value_add_string_name_ascii json_value_add_string_name_ascii proc~json_value_add_string_name_ascii->interface~to_unicode proc~unescape_string unescape_string proc~unescape_string->interface~to_unicode proc~wrap_json_file_add_string_vec wrap_json_file_add_string_vec proc~wrap_json_file_add_string_vec->interface~to_unicode proc~wrap_json_file_add_logical_vec wrap_json_file_add_logical_vec proc~wrap_json_file_add_logical_vec->interface~to_unicode proc~wrap_json_add_double_by_path wrap_json_add_double_by_path proc~wrap_json_add_double_by_path->interface~to_unicode proc~wrap_json_file_add_string wrap_json_file_add_string proc~wrap_json_file_add_string->interface~to_unicode proc~json_update_string_val_ascii json_update_string_val_ascii proc~json_update_string_val_ascii->interface~to_unicode proc~wrap_json_add_integer_vec_by_path wrap_json_add_integer_vec_by_path proc~wrap_json_add_integer_vec_by_path->interface~to_unicode proc~wrap_json_get_array_by_path wrap_json_get_array_by_path proc~wrap_json_get_array_by_path->interface~to_unicode proc~wrap_json_add_string_vec_by_path wrap_json_add_string_vec_by_path proc~wrap_json_add_string_vec_by_path->interface~to_unicode proc~default_join_ucs4 default_join_ucs4 proc~default_join_ucs4->interface~to_unicode proc~wrap_json_add_string_by_path wrap_json_add_string_by_path proc~wrap_json_add_string_by_path->interface~to_unicode proc~wrap_json_get_alloc_string_vec_by_path wrap_json_get_alloc_string_vec_by_path proc~wrap_json_get_alloc_string_vec_by_path->interface~to_unicode proc~wrap_json_add_logical_vec_by_path wrap_json_add_logical_vec_by_path proc~wrap_json_add_logical_vec_by_path->interface~to_unicode proc~wrap_json_add_integer_by_path wrap_json_add_integer_by_path proc~wrap_json_add_integer_by_path->interface~to_unicode proc~default_neq_ucs4 default_neq_ucs4 proc~default_neq_ucs4->interface~to_unicode proc~wrap_json_add_member_by_path wrap_json_add_member_by_path proc~wrap_json_add_member_by_path->interface~to_unicode proc~wrap_json_create_by_path wrap_json_create_by_path proc~wrap_json_create_by_path->interface~to_unicode proc~wrap_json_file_add_logical wrap_json_file_add_logical proc~wrap_json_file_add_logical->interface~to_unicode proc~wrap_json_file_add_double wrap_json_file_add_double proc~wrap_json_file_add_double->interface~to_unicode proc~parse_string parse_string proc~parse_string->proc~unescape_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Module Procedures to_uni to_uni_vec Module Procedures private pure function to_uni (str) Author Izaak Beekman Convert string to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) private pure function to_uni_vec (str) Author Izaak Beekman Convert array of strings to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str))","title":"to_unicode – JSON-Fortran","tags":"","loc":"interface/to_unicode.html"},{"text":"private function initialize_json_core(verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(json_core_object) Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys If True [default] then no special checks\n   are done to check for duplicate keys. If False, then after parsing, if any duplicate\n   keys are found, an error is thrown. A call to json_value_validate will also check for\n   duplicates. logical(kind=LK), intent(in), optional :: escape_solidus If True then the solidus \" / \" is always escaped\n   \" \\/ \" when serializing JSON If False [default], then it is not escaped.\n Note that this option does not affect parsing\n (both escaped and unescaped are still valid in\n all cases). logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_core ) Called By proc~~initialize_json_core~~CalledByGraph proc~initialize_json_core initialize_json_core interface~json_core json_core interface~json_core->proc~initialize_json_core Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_json_core Source Code function initialize_json_core ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) result ( json_core_object ) implicit none type ( json_core ) :: json_core_object #include \"json_initialize_arguments.inc\" call json_core_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) end function initialize_json_core","title":"initialize_json_core – JSON-Fortran","tags":"","loc":"proc/initialize_json_core.html"},{"text":"private function json_count(json, p) result(count) Count the number of children. History JW : 1/4/2014 : Original routine removed.\n    Now using n_children variable.\n    Renamed from json_value_count . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) number of children Source Code json_count Source Code function json_count ( json , p ) result ( count ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ) :: count !! number of children if ( associated ( p )) then count = p % n_children else call json % throw_exception ( 'Error in json_count: ' // & 'pointer is not associated.' ) end if end function json_count","title":"json_count – JSON-Fortran","tags":"","loc":"proc/json_count.html"},{"text":"private pure function json_failed(json) result(failed) Logical function to indicate if an exception has been thrown in a json_core . Example type ( json_core ) :: json type ( json_value ), pointer :: p logical :: status_ok character ( len = :), allocatable :: error_msg call json % parse ( filename = 'myfile.json' , p ) if ( json % failed ()) then call json % check_for_errors ( status_ok , error_msg ) write ( * , * ) 'Error: ' // error_msg call json % clear_exceptions () call json % destroy ( p ) end if Note that json_file contains a wrapper for this routine, which is used like: type ( json_file ) :: f logical :: status_ok character ( len = :), allocatable :: error_msg call f % load_file ( filename = 'myfile.json' ) if ( f % failed ()) then call f % check_for_errors ( status_ok , error_msg ) write ( * , * ) 'Error: ' // error_msg call f % clear_exceptions () call f % destroy () end if See also json_check_for_errors Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. Source Code json_failed Source Code pure function json_failed ( json ) result ( failed ) implicit none class ( json_core ), intent ( in ) :: json logical ( LK ) :: failed !! will be true if an exception !! has been thrown. failed = json % exception_thrown end function json_failed","title":"json_failed – JSON-Fortran","tags":"","loc":"proc/json_failed.html"},{"text":"private function json_valid_path(json, p, path) result(found) Returns true if the path is present in the p JSON structure. Note Just a wrapper for json_get_by_path , so it uses the\n      specified path_mode and other settings. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable Return Value logical(kind=LK) true if it was found Source Code json_valid_path Source Code function json_valid_path ( json , p , path ) result ( found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ) :: found !! true if it was found type ( json_value ), pointer :: tmp !! pointer to the variable specified by `path` call json % get ( p , path , tmp , found ) end function json_valid_path","title":"json_valid_path – JSON-Fortran","tags":"","loc":"proc/json_valid_path.html"},{"text":"private function json_value_is_child_of(json, p1, p2) result(is_child_of) Returns True if p2 is a descendant of p1 (i.e, a child, or a child of child, etc.) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 type( json_value ), pointer :: p2 Return Value logical(kind=LK) Source Code json_value_is_child_of Source Code function json_value_is_child_of ( json , p1 , p2 ) result ( is_child_of ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical ( LK ) :: is_child_of is_child_of = . false . if ( json % exception_thrown ) return if ( associated ( p1 ) . and . associated ( p2 )) then if ( associated ( p1 % children )) then call json % traverse ( p1 % children , is_child_of_callback ) end if end if contains subroutine is_child_of_callback ( json , p , finished ) !! Traverse until `p` is `p2`. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished is_child_of = associated ( p , p2 ) finished = is_child_of ! stop searching if found end subroutine is_child_of_callback end function json_value_is_child_of","title":"json_value_is_child_of – JSON-Fortran","tags":"","loc":"proc/json_value_is_child_of.html"},{"text":"private function name_equal(json, p, name) result(is_equal) Returns true if name is equal to p%name , using the specified\n  settings for case sensitivity and trailing whitespace. History 4/30/2016 : original version 8/25/2017 : now just a wrapper for name_strings_equal Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in) :: p the json object character(kind=CK,len=*), intent(in) :: name the name to check for Return Value logical(kind=LK) true if the string are\n lexically equal Source Code name_equal Source Code function name_equal ( json , p , name ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), intent ( in ) :: p !! the json object character ( kind = CK , len =* ), intent ( in ) :: name !! the name to check for logical ( LK ) :: is_equal !! true if the string are !! lexically equal if ( allocated ( p % name )) then ! call the low-level routines for the name strings: is_equal = json % name_strings_equal ( p % name , name ) else is_equal = name == CK_ '' ! check a blank name end if end function name_equal","title":"name_equal – JSON-Fortran","tags":"","loc":"proc/name_equal.html"},{"text":"private function name_strings_equal(json, name1, name2) result(is_equal) Returns true if the name strings name1 is equal to name2 , using\n  the specified settings for case sensitivity and trailing whitespace. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: name1 the name to check character(kind=CK,len=*), intent(in) :: name2 the name to check Return Value logical(kind=LK) true if the string are\n lexically equal Calls proc~~name_strings_equal~~CallsGraph proc~name_strings_equal name_strings_equal proc~lowercase_string lowercase_string proc~name_strings_equal->proc~lowercase_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code name_strings_equal Source Code function name_strings_equal ( json , name1 , name2 ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: name1 !! the name to check character ( kind = CK , len =* ), intent ( in ) :: name2 !! the name to check logical ( LK ) :: is_equal !! true if the string are !! lexically equal !must be the same length if we are treating !trailing spaces as significant, so do a !quick test of this first: if ( json % trailing_spaces_significant ) then is_equal = len ( name1 ) == len ( name2 ) if (. not . is_equal ) return end if if ( json % case_sensitive_keys ) then is_equal = name1 == name2 else is_equal = lowercase_string ( name1 ) == lowercase_string ( name2 ) end if end function name_strings_equal","title":"name_strings_equal – JSON-Fortran","tags":"","loc":"proc/name_strings_equal.html"},{"text":"private function string_to_dble(json, str) result(rval) Convert a string into a double. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) Calls proc~~string_to_dble~~CallsGraph proc~string_to_dble string_to_dble proc~string_to_real string_to_real proc~string_to_dble->proc~string_to_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code string_to_dble Source Code function string_to_dble ( json , str ) result ( rval ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ) :: rval logical ( LK ) :: status_ok !! error flag if (. not . json % exception_thrown ) then call string_to_real ( str , rval , status_ok ) if (. not . status_ok ) then !if there was an error rval = 0.0_RK call json % throw_exception ( 'Error in string_to_dble: ' // & 'string cannot be converted to a double: ' // & trim ( str )) end if else rval = 0.0_RK end if end function string_to_dble","title":"string_to_dble – JSON-Fortran","tags":"","loc":"proc/string_to_dble.html"},{"text":"private function string_to_int(json, str) result(ival) Convert a string into an integer. Note Replacement for the parse_integer function in the original code. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) Calls proc~~string_to_int~~CallsGraph proc~string_to_int string_to_int proc~string_to_integer string_to_integer proc~string_to_int->proc~string_to_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code string_to_int Source Code function string_to_int ( json , str ) result ( ival ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival logical ( LK ) :: status_ok !! error flag if (. not . json % exception_thrown ) then ! call the core routine: call string_to_integer ( str , ival , status_ok ) if (. not . status_ok ) then ival = 0 call json % throw_exception ( 'Error in string_to_int: ' // & 'string cannot be converted to an integer: ' // & trim ( str )) end if else ival = 0 end if end function string_to_int","title":"string_to_int – JSON-Fortran","tags":"","loc":"proc/string_to_int.html"},{"text":"private function wrap_json_valid_path(json, p, path) result(found) Alternate version of json_valid_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable Return Value logical(kind=LK) true if it was found Calls proc~~wrap_json_valid_path~~CallsGraph proc~wrap_json_valid_path wrap_json_valid_path interface~to_unicode to_unicode proc~wrap_json_valid_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_valid_path Source Code function wrap_json_valid_path ( json , p , path ) result ( found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ) :: found !! true if it was found found = json % valid_path ( p , to_unicode ( path )) end function wrap_json_valid_path","title":"wrap_json_valid_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_valid_path.html"},{"text":"private subroutine annotate_invalid_json(json, iunit, str) Generate a warning message if there was an error parsing a JSON file or string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data Calls proc~~annotate_invalid_json~~CallsGraph proc~annotate_invalid_json annotate_invalid_json proc~integer_to_string integer_to_string proc~annotate_invalid_json->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code annotate_invalid_json Source Code subroutine annotate_invalid_json ( json , iunit , str ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl !  If there was an error reading the file, then !   print the line where the error occurred: if ( json % exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( json % line_count , int_fmt , line_str ) call integer_to_string ( json % char_count , int_fmt , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , json % char_count - 1 ) ) // '&#94;' if ( json % line_count > 0 . and . json % char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call json % get_current_line_from_file_stream ( iunit , line ) else call json % get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , json % line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = CK_ '' end if !create the error message: json % err_message = json % err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json","title":"annotate_invalid_json – JSON-Fortran","tags":"","loc":"proc/annotate_invalid_json.html"},{"text":"private subroutine convert(json, p, var_type) Convert an existing JSON variable p to a different variable type.\n  The existing variable (and its children) is destroyed. It is replaced\n  in the structure by a new variable of type var_type (which can be a json_null , json_object or json_array ). Note This is an internal routine used when creating variables by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p the variable to convert integer(kind=IK), intent(in) :: var_type the variable type to convert p to Source Code convert Source Code subroutine convert ( json , p , var_type ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! the variable to convert integer ( IK ), intent ( in ) :: var_type !! the variable type to convert `p` to type ( json_value ), pointer :: tmp !! temporary variable character ( kind = CK , len = :), allocatable :: name !! the name of a JSON variable logical :: convert_it !! if `p` needs to be converted convert_it = p % var_type /= var_type if ( convert_it ) then call json % info ( p , name = name ) ! get existing name select case ( var_type ) case ( json_object ) call json % create_object ( tmp , name ) case ( json_array ) call json % create_array ( tmp , name ) case ( json_null ) call json % create_null ( tmp , name ) case default call json % throw_exception ( 'Error in convert: invalid var_type value.' ) return end select call json % replace ( p , tmp , destroy = . true .) p => tmp nullify ( tmp ) end if end subroutine convert","title":"convert – JSON-Fortran","tags":"","loc":"proc/convert.html"},{"text":"private subroutine destroy_json_core(me) Destructor for the json_core type. Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me Source Code destroy_json_core Source Code subroutine destroy_json_core ( me ) implicit none class ( json_core ), intent ( out ) :: me end subroutine destroy_json_core","title":"destroy_json_core – JSON-Fortran","tags":"","loc":"proc/destroy_json_core.html"},{"text":"private subroutine destroy_json_data(d) Destroy the data within a json_value , and reset type to json_unknown . Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: d Called By proc~~destroy_json_data~~CalledByGraph proc~destroy_json_data destroy_json_data proc~to_string to_string proc~to_string->proc~destroy_json_data proc~to_logical to_logical proc~to_logical->proc~destroy_json_data proc~to_null to_null proc~to_null->proc~destroy_json_data proc~to_double to_double proc~to_double->proc~destroy_json_data proc~to_integer to_integer proc~to_integer->proc~destroy_json_data proc~json_value_destroy json_value_destroy proc~json_value_destroy->proc~destroy_json_data proc~to_array to_array proc~to_array->proc~destroy_json_data proc~to_object to_object proc~to_object->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code destroy_json_data Source Code subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data","title":"destroy_json_data – JSON-Fortran","tags":"","loc":"proc/destroy_json_data.html"},{"text":"private subroutine get_current_line_from_file_sequential(json, iunit, line) Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Source Code get_current_line_from_file_sequential Source Code subroutine get_current_line_from_file_sequential ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line character ( kind = CK , len = seq_chunk_size ) :: chunk !! for reading line in chunks integer ( IK ) :: istat !! iostat flag integer ( IK ) :: isize !! number of characters read in read statement !initialize: line = CK_ '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = '(A)' , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= seq_chunk_size ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential","title":"get_current_line_from_file_sequential – JSON-Fortran","tags":"","loc":"proc/get_current_line_from_file_sequential.html"},{"text":"private subroutine get_current_line_from_file_stream(json, iunit, line) Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Source Code get_current_line_from_file_stream Source Code subroutine get_current_line_from_file_stream ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c istart = json % ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = json % ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream","title":"get_current_line_from_file_stream – JSON-Fortran","tags":"","loc":"proc/get_current_line_from_file_stream.html"},{"text":"private subroutine json_add_double_by_path(json, me, path, value, found, was_created) Add an double value to a json_value , given the path. Warning If the path points to an existing variable in the structure,\n         then this routine will destroy it and replace it with the\n         new value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_double_by_path Source Code subroutine json_add_double_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_double_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_double ) then p % dbl_value = value else call json % info ( p , name = name ) call json % create_double ( tmp , value , name ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_double_by_path","title":"json_add_double_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_double_by_path.html"},{"text":"private subroutine json_add_double_vec_by_path(json, me, path, value, found, was_created) Wrapper to json_add_double_by_path for adding a double vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_double_vec_by_path Source Code subroutine json_add_double_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) call json % add ( var , CK_ '' , value ( i )) end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_double_vec_by_path","title":"json_add_double_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_double_vec_by_path.html"},{"text":"private subroutine json_add_integer_by_path(json, me, path, value, found, was_created) Add an integer value to a json_value , given the path. Warning If the path points to an existing variable in the structure,\n         then this routine will destroy it and replace it with the\n         new value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_integer_by_path Source Code subroutine json_add_integer_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_integer_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_integer ) then p % int_value = value else call json % info ( p , name = name ) call json % create_integer ( tmp , value , name ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_integer_by_path","title":"json_add_integer_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_integer_by_path.html"},{"text":"private subroutine json_add_integer_vec_by_path(json, me, path, value, found, was_created) Wrapper to json_add_integer_by_path for adding an integer vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_integer_vec_by_path Source Code subroutine json_add_integer_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) call json % add ( var , CK_ '' , value ( i )) end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_integer_vec_by_path","title":"json_add_integer_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_integer_vec_by_path.html"},{"text":"private subroutine json_add_logical_by_path(json, me, path, value, found, was_created) Add a logical value to a json_value , given the path. Warning If the path points to an existing variable in the structure,\n         then this routine will destroy it and replace it with the\n         new value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_logical_by_path Source Code subroutine json_add_logical_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_logical_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_logical ) then p % log_value = value else call json % info ( p , name = name ) call json % create_logical ( tmp , value , name ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_logical_by_path","title":"json_add_logical_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_logical_by_path.html"},{"text":"private subroutine json_add_logical_vec_by_path(json, me, path, value, found, was_created) Wrapper to json_add_logical_by_path for adding a logical vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_logical_vec_by_path Source Code subroutine json_add_logical_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) call json % add ( var , CK_ '' , value ( i )) end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_logical_vec_by_path","title":"json_add_logical_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_logical_vec_by_path.html"},{"text":"private subroutine json_add_member_by_path(json, me, path, p, found, was_created) Add a new member ( json_value pointer) to a JSON structure, given the path. Warning If the path points to an existing variable in the structure,\n         then this routine will destroy it and replace it with the\n         new value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Source Code json_add_member_by_path Source Code subroutine json_add_member_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! name of the variable if ( . not . json % exception_thrown ) then if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_member_by_path:' // & ' Input pointer p is not associated.' ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if if ( present ( was_created ) ) was_created = . false . else ! return a pointer to the path (possibly creating it) call json % create ( me , path , tmp , found , was_created ) if (. not . associated ( tmp )) then call json % throw_exception ( 'Error in json_add_member_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else call json % info ( tmp , name = name ) ! replace it with the new one: call json % replace ( tmp , p , destroy = . true .) call json % rename ( p , name ) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_member_by_path","title":"json_add_member_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_member_by_path.html"},{"text":"private subroutine json_add_string_by_path(json, me, path, value, found, was_created, trim_str, adjustl_str) Add a string value to a json_value , given the path. Warning If the path points to an existing variable in the structure,\n         then this routine will destroy it and replace it with the\n         new value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Source Code json_add_string_by_path Source Code subroutine json_add_string_by_path ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp character ( kind = CK , len = :), allocatable :: name !! variable name if ( . not . json % exception_thrown ) then nullify ( p ) ! return a pointer to the path (possibly creating it) ! If the variable had to be created, then ! it will be a json_null variable. call json % create ( me , path , p , found , was_created ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_add_string_by_path:' // & ' Unable to resolve path: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else !NOTE: a new object is created, and the old one !      is replaced and destroyed. This is to !      prevent memory leaks if the type is !      being changed (for example, if an array !      is being replaced with a scalar). if ( p % var_type == json_string ) then p % str_value = value else call json % info ( p , name = name ) call json % create_string ( tmp , value , name , trim_str , adjustl_str ) call json % replace ( p , tmp , destroy = . true .) end if end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_string_by_path","title":"json_add_string_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_string_by_path.html"},{"text":"private subroutine json_add_string_by_path_path_ascii(json, me, path, value, found, was_created, trim_str, adjustl_str) Wrapper for json_add_string_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Calls proc~~json_add_string_by_path_path_ascii~~CallsGraph proc~json_add_string_by_path_path_ascii json_add_string_by_path_path_ascii interface~to_unicode to_unicode proc~json_add_string_by_path_path_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_add_string_by_path_path_ascii Source Code subroutine json_add_string_by_path_path_ascii ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine json_add_string_by_path_path_ascii","title":"json_add_string_by_path_path_ascii – JSON-Fortran","tags":"","loc":"proc/json_add_string_by_path_path_ascii.html"},{"text":"private subroutine json_add_string_by_path_value_ascii(json, me, path, value, found, was_created, trim_str, adjustl_str) Wrapper for json_add_string_by_path where \"value\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Calls proc~~json_add_string_by_path_value_ascii~~CallsGraph proc~json_add_string_by_path_value_ascii json_add_string_by_path_value_ascii interface~to_unicode to_unicode proc~json_add_string_by_path_value_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_add_string_by_path_value_ascii Source Code subroutine json_add_string_by_path_value_ascii ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_by_path ( me , path , to_unicode ( value ), found , was_created ) end subroutine json_add_string_by_path_value_ascii","title":"json_add_string_by_path_value_ascii – JSON-Fortran","tags":"","loc":"proc/json_add_string_by_path_value_ascii.html"},{"text":"private subroutine json_add_string_vec_by_path(json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper to json_add_string_by_path for adding a string vector by path. Note The ilen input can be used to specify the actual lengths of the\n      the strings in the array. They must all be <= len(value) . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Source Code json_add_string_vec_by_path Source Code subroutine json_add_string_vec_by_path ( json , me , path , value , found , was_created , ilen , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: p !! pointer to path (which may exist) type ( json_value ), pointer :: var !! new variable that is created integer ( IK ) :: i !! counter character ( kind = CK , len = :), allocatable :: name !! the variable name logical ( LK ) :: p_found !! if the path was successfully found (or created) if ( . not . json % exception_thrown ) then ! validate ilen array if present: if ( present ( ilen )) then if ( size ( ilen ) /= size ( value )) then call json % throw_exception ( 'Error in json_add_string_vec_by_path: ' // & 'Invalid size of ilen input vector.' ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if if ( present ( was_created )) was_created = . false . return else ! also have to validate the specified lengths. ! (must not be greater than input string length) do i = 1 , size ( value ) if ( ilen ( i ) > len ( value )) then call json % throw_exception ( 'Error in json_add_string_vec_by_path: ' // & 'Invalid ilen element.' ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if if ( present ( was_created )) was_created = . false . return end if end do end if end if !get a pointer to the variable !(creating it if necessary) call json % create ( me , path , p , found = p_found ) if ( p_found ) then call json % info ( p , name = name ) ! want to keep the existing name call json % create_array ( var , name ) ! create a new array variable call json % replace ( p , var , destroy = . true .) ! replace p with this array (destroy p) !populate each element of the array: do i = 1 , size ( value ) if ( present ( ilen )) then call json % add ( var , CK_ '' , value ( i )( 1 : ilen ( i )), & trim_str = trim_str , adjustl_str = adjustl_str ) else call json % add ( var , CK_ '' , value ( i ), & trim_str = trim_str , adjustl_str = adjustl_str ) end if end do end if else if ( present ( found ) ) found = . false . if ( present ( was_created ) ) was_created = . false . end if end subroutine json_add_string_vec_by_path","title":"json_add_string_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_add_string_vec_by_path.html"},{"text":"private subroutine json_add_string_vec_by_path_path_ascii(json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper for json_add_string_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Calls proc~~json_add_string_vec_by_path_path_ascii~~CallsGraph proc~json_add_string_vec_by_path_path_ascii json_add_string_vec_by_path_path_ascii interface~to_unicode to_unicode proc~json_add_string_vec_by_path_path_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_add_string_vec_by_path_path_ascii Source Code subroutine json_add_string_vec_by_path_path_ascii ( json , me , path , value ,& found , was_created , ilen ,& trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_vec_by_path ( me , to_unicode ( path ), value ,& found , was_created , ilen ) end subroutine json_add_string_vec_by_path_path_ascii","title":"json_add_string_vec_by_path_path_ascii – JSON-Fortran","tags":"","loc":"proc/json_add_string_vec_by_path_path_ascii.html"},{"text":"private subroutine json_add_string_vec_by_path_value_ascii(json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper for json_add_string_vec_by_path where \"value\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Calls proc~~json_add_string_vec_by_path_value_ascii~~CallsGraph proc~json_add_string_vec_by_path_value_ascii json_add_string_vec_by_path_value_ascii interface~to_unicode to_unicode proc~json_add_string_vec_by_path_value_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_add_string_vec_by_path_value_ascii Source Code subroutine json_add_string_vec_by_path_value_ascii ( json , me , path , value ,& found , was_created , ilen ,& trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_vec_by_path ( me , path , to_unicode ( value ),& found , was_created , ilen , trim_str , adjustl_str ) end subroutine json_add_string_vec_by_path_value_ascii","title":"json_add_string_vec_by_path_value_ascii – JSON-Fortran","tags":"","loc":"proc/json_add_string_vec_by_path_value_ascii.html"},{"text":"private subroutine json_check_all_for_duplicate_keys(json, p, has_duplicate, name, path) Checks a JSON structure for duplicate child names.\n  This one recursively traverses the entire structure\n  (calling json_check_children_for_duplicate_keys recursively for each element). Note This will only check for one duplicate,\n      it will return the first one that it finds. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p the object to search. If p is\n not a json_object , then has_duplicate will be false. logical(kind=LK), intent(out) :: has_duplicate true if there is at least\n one duplicate name key anywhere\n in the structure. character(kind=CK,len=:), intent(out), optional allocatable :: name the duplicate name\n (unallocated if no\n duplicates were found) character(kind=CK,len=:), intent(out), optional allocatable :: path the full path to the\n duplicate name\n (unallocated if no\n duplicate was found) Source Code json_check_all_for_duplicate_keys Source Code subroutine json_check_all_for_duplicate_keys ( json , p , has_duplicate , name , path ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! the object to search. If `p` is !! not a `json_object`, then `has_duplicate` !! will be false. logical ( LK ), intent ( out ) :: has_duplicate !! true if there is at least !! one duplicate `name` key anywhere !! in the structure. character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! the duplicate name !! (unallocated if no !! duplicates were found) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: path !! the full path to the !! duplicate name !! (unallocated if no !! duplicate was found) has_duplicate = . false . if (. not . json % exception_thrown ) then call json % traverse ( p , duplicate_key_func ) end if contains subroutine duplicate_key_func ( json , p , finished ) !! Callback function to check each element !! for duplicate child names. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished #if defined __GFORTRAN__ ! this is a workaround for a gfortran bug (6 and 7), character ( kind = CK , len = :), allocatable :: tmp_name !! temp variable for `name` string character ( kind = CK , len = :), allocatable :: tmp_path !! temp variable for `path` string if ( present ( name ) . and . present ( path )) then call json % check_children_for_duplicate_keys ( p , has_duplicate , name = tmp_name , path = tmp_path ) else if ( present ( name ) . and . . not . present ( path )) then call json % check_children_for_duplicate_keys ( p , has_duplicate , name = tmp_name ) else if (. not . present ( name ) . and . present ( path )) then call json % check_children_for_duplicate_keys ( p , has_duplicate , path = tmp_path ) else call json % check_children_for_duplicate_keys ( p , has_duplicate ) end if if ( has_duplicate ) then if ( present ( name )) name = tmp_name if ( present ( path )) path = tmp_path end if #else call json % check_children_for_duplicate_keys ( p , has_duplicate , name , path ) #endif finished = has_duplicate . or . json % exception_thrown end subroutine duplicate_key_func end subroutine json_check_all_for_duplicate_keys","title":"json_check_all_for_duplicate_keys – JSON-Fortran","tags":"","loc":"proc/json_check_all_for_duplicate_keys.html"},{"text":"private subroutine json_check_children_for_duplicate_keys(json, p, has_duplicate, name, path) Checks a JSON object for duplicate child names. It uses the specified settings for name matching (see name_strings_equal ). Note This will only check for one duplicate,\n      it will return the first one that it finds. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p the object to search. If p is\n not a json_object , then has_duplicate will be false. logical(kind=LK), intent(out) :: has_duplicate true if there is at least\n two children have duplicate name values. character(kind=CK,len=:), intent(out), optional allocatable :: name the duplicate name\n (unallocated if no\n duplicate was found) character(kind=CK,len=:), intent(out), optional allocatable :: path the full path to the\n duplicate name\n (unallocated if no\n duplicate was found) Source Code json_check_children_for_duplicate_keys Source Code subroutine json_check_children_for_duplicate_keys ( json , p , has_duplicate , name , path ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! the object to search. If `p` is !! not a `json_object`, then `has_duplicate` !! will be false. logical ( LK ), intent ( out ) :: has_duplicate !! true if there is at least !! two children have duplicate !! `name` values. character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! the duplicate name !! (unallocated if no !! duplicate was found) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: path !! the full path to the !! duplicate name !! (unallocated if no !! duplicate was found) integer ( IK ) :: i !! counter integer ( IK ) :: j !! counter type ( json_value ), pointer :: child !! pointer to a child of `p` integer ( IK ) :: n_children !! number of children of `p` logical ( LK ) :: found !! flag for `get_child` type :: alloc_str !! so we can have an array of allocatable strings character ( kind = CK , len = :), allocatable :: str !! name string end type alloc_str type ( alloc_str ), dimension (:), allocatable :: names !! array of all the !! child name strings ! initialize: has_duplicate = . false . if (. not . json % exception_thrown ) then if ( associated ( p )) then if ( p % var_type == json_object ) then ! number of items to check: n_children = json % count ( p ) allocate ( names ( n_children )) ! first get a list of all the name keys: do i = 1 , n_children call json % get_child ( p , i , child , found ) ! get by index if (. not . found ) then call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Malformed JSON linked list' ) exit end if if ( allocated ( child % name )) then names ( i )% str = child % name else call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Object child name is not allocated' ) exit end if end do if (. not . json % exception_thrown ) then ! now check the list for duplicates: main : do i = 1 , n_children do j = 1 , i - 1 if ( json % name_strings_equal ( names ( i )% str , names ( j )% str )) then has_duplicate = . true . if ( present ( name )) then name = names ( i )% str end if if ( present ( path )) then call json % get_child ( p , names ( i )% str , child , found ) ! get by name if ( found ) then call json % get_path ( child , path , found ) if (. not . found ) then ! should never happen since we know it is there call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Could not get path' ) end if else ! should never happen since we know it is there call json % throw_exception (& 'Error in json_check_children_for_duplicate_keys: ' // & 'Could not get child: ' // trim ( names ( i )% str )) end if end if exit main end if end do end do main end if ! cleanup do i = 1 , n_children if ( allocated ( names ( i )% str )) deallocate ( names ( i )% str ) end do if ( allocated ( names )) deallocate ( names ) end if end if end if end subroutine json_check_children_for_duplicate_keys","title":"json_check_children_for_duplicate_keys – JSON-Fortran","tags":"","loc":"proc/json_check_children_for_duplicate_keys.html"},{"text":"private subroutine json_check_for_errors(json, status_ok, error_msg) Retrieve error code from the json_core .\n  This should be called after parse to check for errors.\n  If an error is thrown, before using the class again, json_initialize should be called to clean up before it is used again. Example type ( json_file ) :: json logical :: status_ok character ( kind = CK , len = :), allocatable :: error_msg call json % load_file ( filename = 'myfile.json' ) call json % check_for_errors ( status_ok , error_msg ) if (. not . status_ok ) then write ( * , * ) 'Error: ' // error_msg call json % clear_exceptions () call json % destroy () end if See also json_failed Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Source Code json_check_for_errors Source Code subroutine json_check_for_errors ( json , status_ok , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . json % exception_thrown if (. not . status_ok ) then if ( allocated ( json % err_message )) then error_msg = json % err_message else error_msg = 'Unknown error.' end if else error_msg = CK_ '' end if end subroutine json_check_for_errors","title":"json_check_for_errors – JSON-Fortran","tags":"","loc":"proc/json_check_for_errors.html"},{"text":"private pure subroutine json_clear_exceptions(json) Clear exceptions in the json_core . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json Source Code json_clear_exceptions Source Code pure subroutine json_clear_exceptions ( json ) implicit none class ( json_core ), intent ( inout ) :: json !clear the flag and message: json % exception_thrown = . false . json % err_message = CK_ '' end subroutine json_clear_exceptions","title":"json_clear_exceptions – JSON-Fortran","tags":"","loc":"proc/json_clear_exceptions.html"},{"text":"private subroutine json_clone(json, from, to) Create a deep copy of a json_value linked-list structure. Example program test use json_module implicit none type ( json_core ) :: json type ( json_value ), pointer :: j1 , j2 call json % parse ( '../files/inputs/test1.json' , j1 ) call json % clone ( j1 , j2 ) !now have two independent copies call json % destroy ( j1 ) !destroys j1, but j2 remains call json % print ( j2 , 'j2.json' ) call json % destroy ( j2 ) end program test Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: from this is the structure to clone type( json_value ), pointer :: to the clone is put here\n (it must not already be associated) Calls proc~~json_clone~~CallsGraph proc~json_clone json_clone proc~json_value_clone_func json_value_clone_func proc~json_clone->proc~json_value_clone_func proc~json_value_clone_func->proc~json_value_clone_func Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_clone Source Code subroutine json_clone ( json , from , to ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) !call the main function: ! [note: this is not part of json_core class] call json_value_clone_func ( from , to ) end subroutine json_clone","title":"json_clone – JSON-Fortran","tags":"","loc":"proc/json_clone.html"},{"text":"private subroutine json_create_by_path(json, me, path, p, found, was_created) Returns the json_value pointer given the path string,\n  If necessary, by creating the variables as needed. By default, the leaf node and any empty array elements\n  are created as json_null values. It only works for path_mode=1 or path_mode=3 .\n  An error will be thrown for path_mode=2 (RFC 6901). See also json_get_by_path Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), optional pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if there were no errors\n (variable found or created) logical(kind=LK), intent(out), optional :: was_created true if it was actually created\n (as opposed to already being there) Calls proc~~json_create_by_path~~CallsGraph proc~json_create_by_path json_create_by_path proc~integer_to_string integer_to_string proc~json_create_by_path->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_create_by_path Source Code subroutine json_create_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ), optional :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if there were no errors !! (variable found or created) logical ( LK ), intent ( out ), optional :: was_created !! true if it was actually created !! (as opposed to already being there) type ( json_value ), pointer :: tmp character ( kind = CK , len = max_integer_str_len ) :: path_mode_str !! string version !! of `json%path_mode` if ( present ( p )) nullify ( p ) if (. not . json % exception_thrown ) then select case ( json % path_mode ) case ( 1_IK ) call json % json_get_by_path_default ( me , path , tmp , found ,& create_it = . true .,& was_created = was_created ) if ( present ( p )) p => tmp case ( 3_IK ) call json % json_get_by_path_jsonpath_bracket ( me , path , tmp , found ,& create_it = . true .,& was_created = was_created ) if ( present ( p )) p => tmp case default if ( json % path_mode == 2_IK ) then ! the problem here is there isn't really a way to disambiguate ! the array elements, so '/a/0' could be 'a(1)' or 'a.0'. call json % throw_exception ( 'Error in json_create_by_path: ' // & 'Create by path not supported in RFC 6901 path mode.' ) else call integer_to_string ( json % path_mode , int_fmt , path_mode_str ) call json % throw_exception ( 'Error in json_create_by_path: Unsupported path_mode: ' // & trim ( path_mode_str )) end if if ( present ( found )) then call json % clear_exceptions () found = . false . end if if ( present ( was_created )) was_created = . false . end select else if ( present ( was_created )) was_created = . false . if ( present ( found )) found = . false . end if end subroutine json_create_by_path","title":"json_create_by_path – JSON-Fortran","tags":"","loc":"proc/json_create_by_path.html"},{"text":"private subroutine json_get_alloc_string_vec(json, me, vec, ilen) Get a string vector from a json_value . This is an alternate\n  version of json_get_string_vec . This one returns an allocatable\n  length character (where the string length is the maximum length of\n  any element in the array). It also returns an integer array of the\n  actual sizes of the strings in the JSON structure. Note This is somewhat inefficient since it does\n      cycle through the array twice. Warning The allocation of vec doesn't work with\n         gfortran 4.9 or 5 due to compiler bugs Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array Source Code json_get_alloc_string_vec Source Code subroutine json_get_alloc_string_vec ( json , me , vec , ilen ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ) :: initialized !! if the output array has been sized integer ( IK ) :: max_len !! the length of the longest string in the array ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( character ( kind = CK , len = 0 ) :: vec ( 0 )) allocate ( ilen ( 0 )) return end if end select initialized = . false . call json % string_info ( me , ilen = ilen , max_str_len = max_len ) if (. not . json % exception_thrown ) then ! now get each string using the callback function: call json % get ( me , array_callback = get_chars_from_array ) end if contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !! for getting string !size the output array: if (. not . initialized ) then ! string length long enough to hold the longest one ! Note that this doesn't work with gfortran 4.9 or 5. allocate ( character ( kind = CK , len = max_len ) :: vec ( count ) ) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval ilen ( i ) = len ( cval ) ! return the actual length deallocate ( cval ) else vec ( i ) = CK_ '' ilen ( i ) = 0 end if end subroutine get_chars_from_array end subroutine json_get_alloc_string_vec","title":"json_get_alloc_string_vec – JSON-Fortran","tags":"","loc":"proc/json_get_alloc_string_vec.html"},{"text":"private subroutine json_get_alloc_string_vec_by_path(json, me, path, vec, ilen, found) Alternate version of json_get_alloc_string_vec where input is the path. This is an alternate version of json_get_string_vec_by_path .\n  This one returns an allocatable length character (where the string\n  length is the maximum length of any element in the array). It also\n  returns an integer array of the actual sizes of the strings in the JSON structure. Note An alternative to using this routine is to use json_get_array with\n      a callback function that gets the string from each element and populates\n      a user-defined string type. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found Source Code json_get_alloc_string_vec_by_path Source Code subroutine json_get_alloc_string_vec_by_path ( json , me , path , vec , ilen , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec , ilen ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_alloc_string_vec_by_path","title":"json_get_alloc_string_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_alloc_string_vec_by_path.html"},{"text":"private subroutine json_get_array(json, me, array_callback) This routine calls the user-supplied json_array_callback_func subroutine for each element in the array. Note For integer, double, logical, and character arrays,\n      higher-level routines are provided (see get methods), so\n      this routine does not have to be used for those cases. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback Source Code json_get_array Source Code subroutine json_get_array ( json , me , array_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me procedure ( json_array_callback_func ) :: array_callback type ( json_value ), pointer :: element !! temp variable for getting elements integer ( IK ) :: i !! counter integer ( IK ) :: count !! number of elements in the array if ( json % exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json % count ( me ) element => me % children do i = 1 , count ! callback for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_array: ' // & 'Malformed JSON linked list' ) return end if call array_callback ( json , element , i , count ) if ( json % exception_thrown ) exit element => element % next end do case default call json % throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array","title":"json_get_array – JSON-Fortran","tags":"","loc":"proc/json_get_array.html"},{"text":"private subroutine json_get_array_by_path(json, me, path, array_callback, found) This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Source Code json_get_array_by_path Source Code subroutine json_get_array_by_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_by_path","title":"json_get_array_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_array_by_path.html"},{"text":"private subroutine json_get_by_path(json, me, path, p, found) Returns the json_value pointer given the path string. It uses either of two methods: The original JSON -Fortran defaults RFC 6901 Warning if found is present, we should clear any exceptions that are thrown\n         to be consistent with other routines. This is not currently being done. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specified by path logical(kind=LK), intent(out), optional :: found true if it was found Calls proc~~json_get_by_path~~CallsGraph proc~json_get_by_path json_get_by_path proc~integer_to_string integer_to_string proc~json_get_by_path->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_get_by_path Source Code subroutine json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specified by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found character ( kind = CK , len = max_integer_str_len ), allocatable :: path_mode_str !! string version !! of `json%path_mode` nullify ( p ) if (. not . json % exception_thrown ) then ! note: it can only be 1 or 2 (3 not currently enabled) select case ( json % path_mode ) case ( 1_IK ) call json % json_get_by_path_default ( me , path , p , found ) case ( 2_IK ) call json % json_get_by_path_rfc6901 ( me , path , p , found ) case ( 3_IK ) call json % json_get_by_path_jsonpath_bracket ( me , path , p , found ) case default call integer_to_string ( json % path_mode , int_fmt , path_mode_str ) call json % throw_exception ( 'Error in json_get_by_path: Unsupported path_mode: ' // & trim ( path_mode_str )) if ( present ( found )) found = . false . end select else if ( present ( found )) found = . false . end if end subroutine json_get_by_path","title":"json_get_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_by_path.html"},{"text":"private subroutine json_get_by_path_default(json, me, path, p, found, create_it, was_created) Returns the json_value pointer given the path string. Example type ( json_core ) :: json type ( json_value ), pointer :: dat , p logical :: found !... call json % initialize ( path_mode = 1 ) ! this is the default so not strictly necessary. call json % get ( dat , 'data(2).version' , p , found ) Notes The syntax used here is a subset of the http://goessner.net/articles/JsonPath/ \"dot–notation\".\n  The following special characters are used to denote paths: $ - root @ - this . - child object member (note this can be changed using json%path_separator ) [] or () - child array element (note that indices are 1-based) Thus, if any of these characters are present in the name key,\n  this routine cannot be used to get the value.\n  In that case, the get_child methods would need to be used.\n  Or, the alternate json_get_by_path_rfc6901 could be used. See also json_get_by_path_rfc6901 json_get_by_path_jsonpath_bracket Note The syntax is inherited from FSON, and is basically a subset\n      of JSONPath \"dot-notation\", with the additional allowance of\n      () for array elements. Note JSON null values are used here for unknown variables when create_it is True.\n      So, it is possible that an existing null variable can be converted to another\n      type (object or array) if a child is specified in the path. Doing it this way\n      to avoid having to use another type (say json_unknown ) that would have to be\n      converted to null once all the variables have been created (user would have\n      had to do this). Warning See (**) in code. I think we need to protect for memory leaks when\n         changing the type of a variable that already exists. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found logical(kind=LK), intent(in), optional :: create_it if a variable is not present\n in the path, then it is created.\n the leaf node is returned as\n a null json type and can be\n changed by the caller. logical(kind=LK), intent(out), optional :: was_created if create_it is true, this\n will be true if the variable\n was actually created. Otherwise\n it will be false. Calls proc~~json_get_by_path_default~~CallsGraph proc~json_get_by_path_default json_get_by_path_default proc~json_value_create json_value_create proc~json_get_by_path_default->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_get_by_path_default Source Code subroutine json_get_by_path_default ( json , me , path , p , found , create_it , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found logical ( LK ), intent ( in ), optional :: create_it !! if a variable is not present !! in the path, then it is created. !! the leaf node is returned as !! a `null` json type and can be !! changed by the caller. logical ( LK ), intent ( out ), optional :: was_created !! if `create_it` is true, this !! will be true if the variable !! was actually created. Otherwise !! it will be false. integer ( IK ) :: i !! counter of characters in `path` integer ( IK ) :: length !! significant length of `path` integer ( IK ) :: child_i !! index for getting children character ( kind = CK , len = 1 ) :: c !! a character in the `path` logical ( LK ) :: array !! flag when searching for array index in `path` type ( json_value ), pointer :: tmp !! temp variables for getting child objects logical ( LK ) :: child_found !! if the child value was found logical ( LK ) :: create !! if the object is to be created logical ( LK ) :: created !! if `create` is true, then this will be !! true if the leaf object had to be created integer ( IK ) :: j !! counter of children when creating object nullify ( p ) if (. not . json % exception_thrown ) then if ( present ( create_it )) then create = create_it else create = . false . end if ! default to assuming relative to me p => me child_i = 1 array = . false . created = . false . !keep trailing space or not: if ( json % trailing_spaces_significant ) then length = len ( path ) else length = len_trim ( path ) end if do i = 1 , length c = path ( i : i ) select case ( c ) case ( root ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 if ( create ) created = . false . ! should always exist case ( this ) ! this p => me child_i = i + 1 if ( create ) created = . false . ! should always exist case ( start_array , start_array_alt ) ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) if ( create ) then ! Example: !    'aaa.bbb(1)' !     -> and aaa is a null, need to make it an object ! !  What about the case: aaa.bbb(1)(3) ? !  Is that already handled? if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an object here: p % var_type = json_object end if ! don't want to throw exceptions in this case call json % get_child ( p , path ( child_i : i - 1 ), tmp , child_found ) if (. not . child_found ) then ! have to create this child ! [make it an array] call json_value_create ( tmp ) call json % to_array ( tmp , path ( child_i : i - 1 )) call json % add ( p , tmp ) created = . true . else created = . false . end if else ! call the normal way call json % get_child ( p , path ( child_i : i - 1 ), tmp ) end if p => tmp else child_i = i + 1 ! say, '@(' cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path_default:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call json % throw_exception ( 'Error in json_get_by_path_default: Unexpected ' // c ) exit end if array = . false . child_i = json % string_to_int ( path ( child_i : i - 1 )) nullify ( tmp ) if ( create ) then ! don't want to throw exceptions in this case call json % get_child ( p , child_i , tmp , child_found ) if (. not . child_found ) then if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an array here: p % var_type = json_array end if ! have to create this element ! [make it a null] ! (and any missing ones before it) do j = 1 , child_i nullify ( tmp ) call json % get_child ( p , j , tmp , child_found ) if (. not . child_found ) then call json_value_create ( tmp ) call json % to_null ( tmp ) ! array element doesn't need a name call json % add ( p , tmp ) if ( j == child_i ) created = . true . else if ( j == child_i ) created = . false . end if end do else created = . false . end if else ! call the normal way: call json % get_child ( p , child_i , tmp ) end if p => tmp child_i = i + 1 case default if ( c == json % path_separator ) then ! get child member from p if ( child_i < i ) then nullify ( tmp ) if ( create ) then if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an object here: p % var_type = json_object end if ! don't want to throw exceptions in this case call json % get_child ( p , path ( child_i : i - 1 ), tmp , child_found ) if (. not . child_found ) then ! have to create this child ! [make it an object] call json_value_create ( tmp ) call json % to_object ( tmp , path ( child_i : i - 1 )) call json % add ( p , tmp ) created = . true . else created = . false . end if else ! call the normal way call json % get_child ( p , path ( child_i : i - 1 ), tmp ) end if p => tmp else child_i = i + 1 ! say '$.', '@.', or ').' cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path_default:' // & ' Error getting child member.' ) exit end if child_i = i + 1 end if end select end do if ( json % exception_thrown ) then if ( present ( found )) then nullify ( p ) ! just in case found = . false . call json % clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) if ( create ) then if ( p % var_type == json_null ) then ! (**) ! if p was also created, then we need to ! convert it into an object here: p % var_type = json_object end if call json % get_child ( p , path ( child_i : i - 1 ), tmp , child_found ) if (. not . child_found ) then ! have to create this child ! (make it a null since it is the leaf) call json_value_create ( tmp ) call json % to_null ( tmp , path ( child_i : i - 1 )) call json % add ( p , tmp ) created = . true . else created = . false . end if else ! call the normal way call json % get_child ( p , path ( child_i : i - 1 ), tmp ) end if p => tmp else ! we already have p if ( create . and . created ) then ! make leaf p a null, but only ! if it wasn't there call json % to_null ( p ) end if end if ! error checking if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call json % throw_exception ( 'Error in json_get_by_path_default:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if end if ! if it had to be created: if ( present ( was_created )) was_created = created else if ( present ( found )) found = . false . if ( present ( was_created )) was_created = . false . end if end subroutine json_get_by_path_default","title":"json_get_by_path_default – JSON-Fortran","tags":"","loc":"proc/json_get_by_path_default.html"},{"text":"private subroutine json_get_by_path_jsonpath_bracket(json, me, path, p, found, create_it, was_created) Returns the json_value pointer given the path string,\n  using the \" JSON Pointer\" path specification defined by the\n  JSONPath \"bracket-notation\". The first character $ is optional, and signifies the root\n  of the structure. If it is not present, then the first key\n  is taken to be in the me object. Single or double quotes may be used. Example type ( json_core ) :: json type ( json_value ), pointer :: dat , p logical :: found !... call json % initialize ( path_mode = 3 ) call json % get ( dat , \"$['store']['book'][1]['title']\" , p , found ) See also json_get_by_path_default json_get_by_path_rfc6901 Reference JSONPath Note Uses 1-based array indices (same as json_get_by_path_default ,\n      but unlike json_get_by_path_rfc6901 which uses 0-based indices). Note When create_it=True , if the variable already exists and is a type\n      that is not compatible with the usage in the path , then it is\n      destroyed and replaced with what is specified in the path . Note that\n      this applies the all variables in the path as it is created. Currently,\n      this behavior is different from json_get_by_path_default . Note JSON null values are used here for unknown variables\n      when create_it is True. Warning Note that if using single quotes, this routine cannot parse\n         a key containing '] . If using double quotes, this routine\n         cannot parse a key containing \"] . If the key contains both '] and \"] , there is no way to parse it using this routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable\n (using JSONPath\n \"bracket-notation\") type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found logical(kind=LK), intent(in), optional :: create_it if a variable is not present\n in the path, then it is created.\n the leaf node is returned as\n a null json type and can be\n changed by the caller. logical(kind=LK), intent(out), optional :: was_created if create_it is true, this\n will be true if the variable\n was actually created. Otherwise\n it will be false. Calls proc~~json_get_by_path_jsonpath_bracket~~CallsGraph proc~json_get_by_path_jsonpath_bracket json_get_by_path_jsonpath_bracket proc~json_value_create json_value_create proc~json_get_by_path_jsonpath_bracket->proc~json_value_create proc~string_to_integer string_to_integer proc~json_get_by_path_jsonpath_bracket->proc~string_to_integer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_get_by_path_jsonpath_bracket Source Code subroutine json_get_by_path_jsonpath_bracket ( json , me , path , p , found , create_it , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable !! (using JSONPath !! \"bracket-notation\") type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found logical ( LK ), intent ( in ), optional :: create_it !! if a variable is not present !! in the path, then it is created. !! the leaf node is returned as !! a `null` json type and can be !! changed by the caller. logical ( LK ), intent ( out ), optional :: was_created !! if `create_it` is true, this !! will be true if the variable !! was actually created. Otherwise !! it will be false. character ( kind = CK , len = :), allocatable :: token !! a token in the path !! (between the `['']` or !! `[]` characters) integer ( IK ) :: istart !! location of current '[' !! character in the path integer ( IK ) :: iend !! location of current ']' !! character in the path integer ( IK ) :: ival !! integer array index value logical ( LK ) :: status_ok !! error flag type ( json_value ), pointer :: tmp !! temporary variable for !! traversing the structure integer ( IK ) :: i !! counter integer ( IK ) :: ilen !! length of `path` string logical ( LK ) :: double_quotes !! if the keys are enclosed in `\"`, !! rather than `'` tokens. logical ( LK ) :: create !! if the object is to be created logical ( LK ) :: created !! if `create` is true, then this will be !! true if the leaf object had to be created integer ( IK ) :: j !! counter of children when creating object !TODO instead of reallocating `token` all the time, just !     allocate a big size and keep track of the length, !     then just reallocate only if necessary. !     [would probably be inefficient if there was a very large token, !     and then a bunch of small ones... but for similarly-sized ones !     it should be way more efficient since it would avoid most !     reallocations.] nullify ( p ) if (. not . json % exception_thrown ) then if ( present ( create_it )) then create = create_it else create = . false . end if p => me ! initialize created = . false . if ( path == CK_ '' ) then call json % throw_exception ( 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path specification: ' // trim ( path )) else if ( path ( 1 : 1 ) == root . or . path ( 1 : 1 ) == start_array ) then ! the first character must be ! a `$` (root) or a `[` ! (element of `me`) if ( path ( 1 : 1 ) == root ) then ! go to the root do while ( associated ( p % parent )) p => p % parent end do if ( create ) created = . false . ! should always exist end if !path length (don't need trailing spaces:) ilen = len_trim ( path ) if ( ilen > 1 ) then istart = 2 ! initialize first '[' location index do if ( istart > ilen ) exit ! finished ! must be the next start bracket: if ( path ( istart : istart ) /= start_array ) then call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'expecting \"[\", found: \"' // trim ( path ( istart : istart )) // & '\" in path: ' // trim ( path )) exit end if ! get the next token by checking: ! ! * [''] -- is the token after istart a quote? !           if so, then search for the next `']` ! ! * [1] -- if not, then maybe it is a number, !          so search for the next `]` ! verify length of remaining string if ( istart + 2 <= ilen ) then double_quotes = path ( istart + 1 : istart + 1 ) == quotation_mark ! [\" if ( double_quotes . or . path ( istart + 1 : istart + 1 ) == single_quote ) then ! [' ! it might be a key value: ['abc'] istart = istart + 1 ! move counter to ' index if ( double_quotes ) then iend = istart + index ( path ( istart + 1 : ilen ),& quotation_mark // end_array ) ! \"] else iend = istart + index ( path ( istart + 1 : ilen ),& single_quote // end_array ) ! '] end if if ( iend > istart ) then !     istart  iend !       |       | ! ['p']['abcdefg'] if ( iend > istart + 1 ) then token = path ( istart + 1 : iend - 1 ) else token = CK_ '' ! blank string end if ! remove trailing spaces in ! the token here if necessary: if (. not . json % trailing_spaces_significant ) & token = trim ( token ) if ( create ) then ! have a token, create it if necessary ! we need to convert it into an object here ! (e.g., if p was also just created) ! and destroy its data to prevent a memory leak call json % convert ( p , json_object ) ! don't want to throw exceptions in this case call json % get_child ( p , token , tmp , status_ok ) if (. not . status_ok ) then ! have to create this child ! [make it a null since we don't ! know what it is yet] call json_value_create ( tmp ) call json % to_null ( tmp , token ) call json % add ( p , tmp ) status_ok = . true . created = . true . else ! it was already there. created = . false . end if else ! have a token, see if it is valid: call json % get_child ( p , token , tmp , status_ok ) end if if ( status_ok ) then ! it was found p => tmp else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid token found: \"' // token // & '\" in path: ' // trim ( path )) exit end if iend = iend + 1 ! move counter to ] index else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path: ' // trim ( path )) exit end if else ! it might be an integer value: [123] iend = istart + index ( path ( istart + 1 : ilen ), end_array ) ! ] if ( iend > istart + 1 ) then ! this should be an integer: token = path ( istart + 1 : iend - 1 ) ! verify that there are no spaces or other ! characters in the string: do i = 1 , len ( token ) ! It must only contain (0..9) characters ! (it must be unsigned) if ( scan ( token ( i : i ), CK_ '0123456789' ) < 1 ) then status_ok = . false . exit end if end do if ( status_ok ) then call string_to_integer ( token , ival , status_ok ) if ( status_ok ) status_ok = ival > 0 ! assuming 1-based array indices end if if ( status_ok ) then ! have a valid integer to use as an index ! see if this element is really there: call json % get_child ( p , ival , tmp , status_ok ) if ( create . and . . not . status_ok ) then ! have to create it: if (. not .( p % var_type == json_object . or . p % var_type == json_array )) then ! we need to convert it into an array here ! (e.g., if p was also just created) ! and destroy its data to prevent a memory leak call json % convert ( p , json_array ) end if ! have to create this element ! [make it a null] ! (and any missing ones before it) do j = 1 , ival nullify ( tmp ) call json % get_child ( p , j , tmp , status_ok ) if (. not . status_ok ) then call json_value_create ( tmp ) call json % to_null ( tmp ) ! array element doesn't need a name call json % add ( p , tmp ) if ( j == ival ) created = . true . else if ( j == ival ) created = . false . end if end do status_ok = . true . else created = . false . end if if ( status_ok ) then ! found it p => tmp else ! not found call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid array index found: \"' // token // & '\" in path: ' // trim ( path )) exit end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid token: \"' // token // & '\" in path: ' // trim ( path )) exit end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path: ' // trim ( path )) exit end if end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'invalid path: ' // trim ( path )) exit end if ! set up for next token: istart = iend + 1 end do end if else call json % throw_exception (& 'Error in json_get_by_path_jsonpath_bracket: ' // & 'expecting \"' // root // '\", found: \"' // path ( 1 : 1 ) // & '\" in path: ' // trim ( path )) end if end if if ( json % exception_thrown ) then nullify ( p ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if ! if it had to be created: if ( present ( was_created )) was_created = created else if ( present ( found )) found = . false . if ( present ( was_created )) was_created = . false . end if end subroutine json_get_by_path_jsonpath_bracket","title":"json_get_by_path_jsonpath_bracket – JSON-Fortran","tags":"","loc":"proc/json_get_by_path_jsonpath_bracket.html"},{"text":"private subroutine json_get_by_path_rfc6901(json, me, path, p, found) Returns the json_value pointer given the path string,\n  using the \" JSON Pointer\" path specification defined by RFC 6901. Note that trailing whitespace significance and case sensitivity\n  are user-specified. To fully conform to the RFC 6901 standard,\n  should probably set (via initialize ): trailing_spaces_significant = .true. [this is not the default setting] case_sensitive_keys = .true.         [this is the default setting] Example type ( json_core ) :: json type ( json_value ), pointer :: dat , p logical :: found !... call json % initialize ( path_mode = 2 ) call json % get ( dat , '/data/2/version' , p , found ) See also json_get_by_path_default json_get_by_path_jsonpath_bracket Reference JavaScript Object Notation ( JSON ) Pointer Note Not doing anything special about the - character to index an array.\n      This is considered a normal error. Note Unlike in the default path mode, the array indices here are 0-based\n      (in accordance with the RFC 6901 standard) Warning Not checking if the member that is referenced is unique.\n         (according to the standard, evaluation of non-unique references\n         should fail). Like json_get_by_path_default , this one will just return\n         the first instance it encounters. This might be changed in the future. Warning I think the standard indicates that the input paths should use\n         escaped JSON strings (currently we are assuming they are not escaped). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable\n (an RFC 6901 \" JSON Pointer\") type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found Calls proc~~json_get_by_path_rfc6901~~CallsGraph proc~json_get_by_path_rfc6901 json_get_by_path_rfc6901 proc~decode_rfc6901 decode_rfc6901 proc~json_get_by_path_rfc6901->proc~decode_rfc6901 proc~string_to_integer string_to_integer proc~json_get_by_path_rfc6901->proc~string_to_integer proc~replace_string replace_string proc~decode_rfc6901->proc~replace_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_get_by_path_rfc6901 Source Code subroutine json_get_by_path_rfc6901 ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable !! (an RFC 6901 \"JSON Pointer\") type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found character ( kind = CK , len = :), allocatable :: token !! a token in the path (between the `/` characters) integer ( IK ) :: i !! counter integer ( IK ) :: islash_curr !! location of current '/' character in the path integer ( IK ) :: islash_next !! location of next '/' character in the path integer ( IK ) :: ilen !! length of `path` string type ( json_value ), pointer :: tmp !! temporary variable for traversing the structure integer ( IK ) :: ival !! integer array index value (0-based) logical ( LK ) :: status_ok !! error flag logical ( LK ) :: child_found !! for getting child values nullify ( p ) if (. not . json % exception_thrown ) then p => me ! initialize if ( path /= CK_ '' ) then if ( path ( 1 : 1 ) == slash ) then ! the first character must be a slash islash_curr = 1 ! initialize current slash index !keep trailing space or not: if ( json % trailing_spaces_significant ) then ilen = len ( path ) else ilen = len_trim ( path ) end if do ! get the next token by finding the slashes ! !  1   2 3 !  /abc/d/efg if ( islash_curr == ilen ) then !the last token is an empty string token = CK_ '' islash_next = 0 ! will signal to stop else !      . ! '/123/567/' ! index in remaining string: islash_next = index ( path ( islash_curr + 1 : ilen ), slash ) if ( islash_next <= 0 ) then !last token: token = path ( islash_curr + 1 : ilen ) else ! convert to actual index in path: islash_next = islash_curr + index ( path ( islash_curr + 1 : ilen ), slash ) if ( islash_next > islash_curr + 1 ) then token = path ( islash_curr + 1 : islash_next - 1 ) else !empty token: token = CK_ '' end if end if end if ! remove trailing spaces in the token here if necessary: if (. not . json % trailing_spaces_significant ) & token = trim ( token ) ! decode the token: token = decode_rfc6901 ( token ) ! now, parse the token: ! first see if there is a child with this name call json % get_child ( p , token , tmp , child_found ) if ( child_found ) then ! it was found p => tmp else ! No key with this name. ! Is it an integer? If so, ! it might be an array index. status_ok = ( len ( token ) > 0 ) if ( status_ok ) then do i = 1 , len ( token ) ! It must only contain (0..9) characters ! (it must be unsigned) if ( scan ( token ( i : i ), CK_ '0123456789' ) < 1 ) then status_ok = . false . exit end if end do if ( status_ok ) then if ( len ( token ) > 1 . and . token ( 1 : 1 ) == CK_ '0' ) then ! leading zeros not allowed for some reason status_ok = . false . end if end if if ( status_ok ) then ! if we make it this far, it should be ! convertable to an integer, so do it. call string_to_integer ( token , ival , status_ok ) end if end if if ( status_ok ) then ! ival is an array index (0-based) call json % get_child ( p , ival + 1 , tmp , child_found ) if ( child_found ) then p => tmp else ! not found status_ok = . false . end if end if if (. not . status_ok ) then call json % throw_exception ( 'Error in json_get_by_path_rfc6901: ' // & 'invalid path specification: ' // trim ( path )) exit end if end if if ( islash_next <= 0 ) exit ! finished ! set up for next token: islash_curr = islash_next end do else call json % throw_exception ( 'Error in json_get_by_path_rfc6901: ' // & 'invalid path specification: ' // trim ( path )) end if end if if ( json % exception_thrown ) then nullify ( p ) if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path_rfc6901","title":"json_get_by_path_rfc6901 – JSON-Fortran","tags":"","loc":"proc/json_get_by_path_rfc6901.html"},{"text":"private subroutine json_get_double(json, me, value) Get a double value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out) :: value Source Code json_get_double Source Code subroutine json_get_double ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( json % exception_thrown ) return if ( me % var_type == json_double ) then value = me % dbl_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end if end if end subroutine json_get_double","title":"json_get_double – JSON-Fortran","tags":"","loc":"proc/json_get_double.html"},{"text":"private subroutine json_get_double_by_path(json, me, path, value, found) Get a double value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Source Code json_get_double_by_path Source Code subroutine json_get_double_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_by_path","title":"json_get_double_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_double_by_path.html"},{"text":"private subroutine json_get_double_vec(json, me, vec) Get a double vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Source Code json_get_double_vec Source Code subroutine json_get_double_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_double_from_array ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec","title":"json_get_double_vec – JSON-Fortran","tags":"","loc":"proc/json_get_double_vec.html"},{"text":"private subroutine json_get_double_vec_by_path(json, me, path, vec, found) Get a double vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Source Code json_get_double_vec_by_path Source Code subroutine json_get_double_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_double_vec_by_path","title":"json_get_double_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_double_vec_by_path.html"},{"text":"private subroutine json_get_integer(json, me, value) Get an integer value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Source Code json_get_integer Source Code subroutine json_get_integer ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( json % exception_thrown ) return if ( me % var_type == json_integer ) then value = me % int_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end if end if end subroutine json_get_integer","title":"json_get_integer – JSON-Fortran","tags":"","loc":"proc/json_get_integer.html"},{"text":"private subroutine json_get_integer_by_path(json, me, path, value, found) Get an integer value from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Source Code json_get_integer_by_path Source Code subroutine json_get_integer_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_by_path","title":"json_get_integer_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_integer_by_path.html"},{"text":"private subroutine json_get_integer_vec(json, me, vec) Get an integer vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Source Code json_get_integer_vec Source Code subroutine json_get_integer_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_int_from_array ) contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec","title":"json_get_integer_vec – JSON-Fortran","tags":"","loc":"proc/json_get_integer_vec.html"},{"text":"private subroutine json_get_integer_vec_by_path(json, me, path, vec, found) Get an integer vector from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Source Code json_get_integer_vec_by_path Source Code subroutine json_get_integer_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_integer_vec_by_path","title":"json_get_integer_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_integer_vec_by_path.html"},{"text":"private subroutine json_get_logical(json, me, value) Get a logical value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out) :: value Source Code json_get_logical Source Code subroutine json_get_logical ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), intent ( out ) :: value value = . false . if ( json % exception_thrown ) return if ( me % var_type == json_logical ) then value = me % log_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case default call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) end select end if end if end subroutine json_get_logical","title":"json_get_logical – JSON-Fortran","tags":"","loc":"proc/json_get_logical.html"},{"text":"private subroutine json_get_logical_by_path(json, me, path, value, found) Get a logical value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Source Code json_get_logical_by_path Source Code subroutine json_get_logical_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_by_path","title":"json_get_logical_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_logical_by_path.html"},{"text":"private subroutine json_get_logical_vec(json, me, vec) Get a logical vector from json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Source Code json_get_logical_vec Source Code subroutine json_get_logical_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_logical_from_array ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec","title":"json_get_logical_vec – JSON-Fortran","tags":"","loc":"proc/json_get_logical_vec.html"},{"text":"private subroutine json_get_logical_vec_by_path(json, me, path, vec, found) Get a logical vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Source Code json_get_logical_vec_by_path Source Code subroutine json_get_logical_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_logical_vec_by_path","title":"json_get_logical_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_logical_vec_by_path.html"},{"text":"private subroutine json_get_next(json, p, next) Returns a pointer to the next of a json_value .\n  If there is no next, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next Source Code json_get_next Source Code subroutine json_get_next ( json , p , next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: next !! pointer to `next` if ( associated ( p )) then next => p % next else nullify ( next ) call json % throw_exception ( 'Error in json_get_next: ' // & 'pointer is not associated.' ) end if end subroutine json_get_next","title":"json_get_next – JSON-Fortran","tags":"","loc":"proc/json_get_next.html"},{"text":"private subroutine json_get_parent(json, p, parent) Returns a pointer to the parent of a json_value .\n  If there is no parent, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent Source Code json_get_parent Source Code subroutine json_get_parent ( json , p , parent ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: parent !! pointer to `parent` if ( associated ( p )) then parent => p % parent else nullify ( parent ) call json % throw_exception ( 'Error in json_get_parent: ' // & 'pointer is not associated.' ) end if end subroutine json_get_parent","title":"json_get_parent – JSON-Fortran","tags":"","loc":"proc/json_get_parent.html"},{"text":"private subroutine json_get_path(json, p, path, found, use_alt_array_tokens, path_sep) Returns the path to a JSON object that is part\n  of a linked list structure. The path returned would be suitable for input to json_get_by_path and related routines. Note If an error occurs (which in this case means a malformed JSON structure) then an exception will be thrown, unless found is present, which will be set to false . path will be a blank string. Note If json%path_mode/=1 , then the use_alt_array_tokens and path_sep inputs are ignored if present. Note http://goessner.net/articles/JsonPath/ ( path_mode=3 )\n      does not specify whether or not the keys should be escaped (this routine\n      assumes not, as does http://jsonpath.com).\n      Also, we are using Fortran-style 1-based array indices,\n      not 0-based, to agree with the assumption in path_mode=1 Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list object character(kind=CK,len=:), intent(out), allocatable :: path path to the variable logical(kind=LK), intent(out), optional :: found true if there were no problems logical(kind=LK), intent(in), optional :: use_alt_array_tokens if true, then '()' are used for array elements\n otherwise, '[]' are used [default]\n (only used if path_mode=1 ) character(kind=CK,len=1), intent(in), optional :: path_sep character to use for path separator\n (otherwise use json%path_separator )\n (only used if path_mode=1 ) Calls proc~~json_get_path~~CallsGraph proc~json_get_path json_get_path proc~encode_rfc6901 encode_rfc6901 proc~json_get_path->proc~encode_rfc6901 proc~integer_to_string integer_to_string proc~json_get_path->proc~integer_to_string proc~replace_string replace_string proc~encode_rfc6901->proc~replace_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_get_path~~CalledByGraph proc~json_get_path json_get_path proc~wrap_json_get_path wrap_json_get_path proc~wrap_json_get_path->proc~json_get_path Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_get_path Source Code subroutine json_get_path ( json , p , path , found , use_alt_array_tokens , path_sep ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list object character ( kind = CK , len = :), allocatable , intent ( out ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if there were no problems logical ( LK ), intent ( in ), optional :: use_alt_array_tokens !! if true, then '()' are used for array elements !! otherwise, '[]' are used [default] !! (only used if `path_mode=1`) character ( kind = CK , len = 1 ), intent ( in ), optional :: path_sep !! character to use for path separator !! (otherwise use `json%path_separator`) !! (only used if `path_mode=1`) type ( json_value ), pointer :: tmp !! for traversing the structure type ( json_value ), pointer :: element !! for traversing the structure integer ( IK ) :: var_type !! JSON variable type flag character ( kind = CK , len = :), allocatable :: name !! variable name character ( kind = CK , len = :), allocatable :: parent_name !! variable's parent name character ( kind = CK , len = max_integer_str_len ) :: istr !! for integer to string conversion !! (array indices) integer ( IK ) :: i !! counter integer ( IK ) :: n_children !! number of children for parent logical ( LK ) :: use_brackets !! to use '[]' characters for arrays logical ( LK ) :: parent_is_root !! if the parent is the root !optional input: if ( present ( use_alt_array_tokens )) then use_brackets = . not . use_alt_array_tokens else use_brackets = . true . end if if ( associated ( p )) then !traverse the structure via parents up to the root tmp => p do if (. not . associated ( tmp )) exit !finished !get info about the current variable: call json % info ( tmp , name = name ) if ( json % path_mode == 2_IK ) then name = encode_rfc6901 ( name ) end if ! if tmp a child of an object, or an element of an array if ( associated ( tmp % parent )) then !get info about the parent: call json % info ( tmp % parent , var_type = var_type ,& n_children = n_children , name = parent_name ) if ( json % path_mode == 2_IK ) then parent_name = encode_rfc6901 ( parent_name ) end if select case ( var_type ) case ( json_array ) !get array index of this element: element => tmp % parent % children do i = 1 , n_children if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_path: ' // & 'malformed JSON structure. ' ) exit end if if ( associated ( element , tmp )) then exit else element => element % next end if if ( i == n_children ) then ! it wasn't found (should never happen) call json % throw_exception ( 'Error in json_get_path: ' // & 'malformed JSON structure. ' ) exit end if end do select case ( json % path_mode ) case ( 3_IK ) ! JSONPath \"bracket-notation\" ! example: `$['key'][1]` ! [note: this uses 1-based indices] call integer_to_string ( i , int_fmt , istr ) call add_to_path ( start_array // single_quote // parent_name // & single_quote // end_array // & start_array // trim ( adjustl ( istr )) // end_array , CK_ '' ) case ( 2_IK ) ! rfc6901 call integer_to_string ( i - 1 , int_fmt , istr ) ! 0-based index call add_to_path ( parent_name // slash // trim ( adjustl ( istr ))) case ( 1_IK ) ! default call integer_to_string ( i , int_fmt , istr ) if ( use_brackets ) then call add_to_path ( parent_name // start_array // & trim ( adjustl ( istr )) // end_array , path_sep ) else call add_to_path ( parent_name // start_array_alt // & trim ( adjustl ( istr )) // end_array_alt , path_sep ) end if end select tmp => tmp % parent ! already added parent name case ( json_object ) !process parent on the next pass select case ( json % path_mode ) case ( 3_IK ) call add_to_path ( start_array // single_quote // name // & single_quote // end_array , CK_ '' ) case default call add_to_path ( name , path_sep ) end select case default call json % throw_exception ( 'Error in json_get_path: ' // & 'malformed JSON structure. ' // & 'A variable that is not an object ' // & 'or array should not have a child.' ) exit end select else !the last one: select case ( json % path_mode ) case ( 3_IK ) call add_to_path ( start_array // single_quote // name // & single_quote // end_array , CK_ '' ) case default call add_to_path ( name , path_sep ) end select end if if ( associated ( tmp % parent )) then !check if the parent is the root: parent_is_root = (. not . associated ( tmp % parent % parent )) if ( parent_is_root ) exit end if !go to parent: tmp => tmp % parent end do else call json % throw_exception ( 'Error in json_get_path: ' // & 'input pointer is not associated' ) end if !for errors, return blank string: if ( json % exception_thrown . or . . not . allocated ( path )) then path = CK_ '' else select case ( json % path_mode ) case ( 3_IK ) ! add the outer level object identifier: path = root // path case ( 2_IK ) ! add the root slash: path = slash // path end select end if !optional output: if ( present ( found )) then if ( json % exception_thrown ) then found = . false . call json % clear_exceptions () else found = . true . end if end if contains subroutine add_to_path ( str , path_sep ) !! prepend the string to the path implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! string to prepend to `path` character ( kind = CK , len =* ), intent ( in ), optional :: path_sep !! path separator (default is '.'). !! (ignored if `json%path_mode/=1`) select case ( json % path_mode ) case ( 3_IK ) ! in this case, the options are ignored if (. not . allocated ( path )) then path = str else path = str // path end if case ( 2_IK ) ! in this case, the options are ignored if (. not . allocated ( path )) then path = str else path = str // slash // path end if case ( 1_IK ) ! default path format if (. not . allocated ( path )) then path = str else if ( present ( path_sep )) then ! use user specified: path = str // path_sep // path else ! use the default: path = str // json % path_separator // path end if end if end select end subroutine add_to_path end subroutine json_get_path","title":"json_get_path – JSON-Fortran","tags":"","loc":"proc/json_get_path.html"},{"text":"private subroutine json_get_previous(json, p, previous) Returns a pointer to the previous of a json_value .\n  If there is no previous, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous Source Code json_get_previous Source Code subroutine json_get_previous ( json , p , previous ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: previous !! pointer to `previous` if ( associated ( p )) then previous => p % previous else nullify ( previous ) call json % throw_exception ( 'Error in json_get_previous: ' // & 'pointer is not associated.' ) end if end subroutine json_get_previous","title":"json_get_previous – JSON-Fortran","tags":"","loc":"proc/json_get_previous.html"},{"text":"private subroutine json_get_string(json, me, value) Get a character string from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Calls proc~~json_get_string~~CallsGraph proc~json_get_string json_get_string proc~escape_string escape_string proc~json_get_string->proc~escape_string proc~real_to_string real_to_string proc~json_get_string->proc~real_to_string proc~integer_to_string integer_to_string proc~json_get_string->proc~integer_to_string proc~valid_json_hex valid_json_hex proc~escape_string->proc~valid_json_hex proc~compact_real_string compact_real_string proc~real_to_string->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_get_string Source Code subroutine json_get_string ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value value = CK_ '' if (. not . json % exception_thrown ) then if ( me % var_type == json_string ) then if ( allocated ( me % str_value )) then if ( json % unescaped_strings ) then ! default: it is stored already unescaped: value = me % str_value else ! return the escaped version: call escape_string ( me % str_value , value , json % escape_solidus ) end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%str_value not allocated' ) end if else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_string:' // & ' Unable to resolve value to string: ' // me % name ) else select case ( me % var_type ) case ( json_integer ) if ( allocated ( me % int_value )) then value = repeat ( ' ' , max_integer_str_len ) call integer_to_string ( me % int_value , int_fmt , value ) value = trim ( value ) else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%int_value not allocated' ) end if case ( json_double ) if ( allocated ( me % dbl_value )) then value = repeat ( ' ' , max_numeric_str_len ) call real_to_string ( me % dbl_value , json % real_fmt ,& json % compact_real , value ) value = trim ( value ) else call json % throw_exception ( 'Error in dbl_value: ' // & 'me%int_value not allocated' ) end if case ( json_logical ) if ( allocated ( me % log_value )) then if ( me % log_value ) then value = true_str else value = false_str end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%log_value not allocated' ) end if case ( json_null ) value = null_str case default call json % throw_exception ( 'Error in json_get_string: ' // & 'Unable to resolve value to characters: ' // & me % name ) end select end if end if end if end subroutine json_get_string","title":"json_get_string – JSON-Fortran","tags":"","loc":"proc/json_get_string.html"},{"text":"private subroutine json_get_string_by_path(json, me, path, value, found) Get a character string from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Source Code json_get_string_by_path Source Code subroutine json_get_string_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = CK_ '' if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_string_by_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . json % exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_by_path","title":"json_get_string_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_string_by_path.html"},{"text":"private subroutine json_get_string_vec(json, me, vec) Get a string vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Source Code json_get_string_vec Source Code subroutine json_get_string_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized ! check for 0-length arrays first: select case ( me % var_type ) case ( json_array ) if ( json % count ( me ) == 0 ) then allocate ( vec ( 0 )) return end if end select initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_chars_from_array ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = CK_ '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec","title":"json_get_string_vec – JSON-Fortran","tags":"","loc":"proc/json_get_string_vec.html"},{"text":"private subroutine json_get_string_vec_by_path(json, me, path, vec, found) Get a string vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Source Code json_get_string_vec_by_path Source Code subroutine json_get_string_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p call json % get ( me , path , p , found ) if ( present ( found )) then if (. not . found ) return else if ( json % exception_thrown ) return end if call json % get ( p , vec ) if ( present ( found ) . and . json % exception_thrown ) then call json % clear_exceptions () found = . false . end if end subroutine json_get_string_vec_by_path","title":"json_get_string_vec_by_path – JSON-Fortran","tags":"","loc":"proc/json_get_string_vec_by_path.html"},{"text":"private subroutine json_get_tail(json, p, tail) Returns a pointer to the tail of a json_value (the last child of an array of object).\n  If there is no tail, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail Source Code json_get_tail Source Code subroutine json_get_tail ( json , p , tail ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: tail !! pointer to `tail` if ( associated ( p )) then tail => p % tail else nullify ( tail ) call json % throw_exception ( 'Error in json_get_tail: ' // & 'pointer is not associated.' ) end if end subroutine json_get_tail","title":"json_get_tail – JSON-Fortran","tags":"","loc":"proc/json_get_tail.html"},{"text":"private subroutine json_info(json, p, var_type, n_children, name) Returns information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Source Code json_info Source Code subroutine json_info ( json , p , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json % count ( p ) if ( present ( name )) then if ( allocated ( p % name )) then name = p % name else name = CK_ '' end if end if end subroutine json_info","title":"json_info – JSON-Fortran","tags":"","loc":"proc/json_info.html"},{"text":"private subroutine json_info_by_path(json, p, path, found, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Source Code json_info_by_path Source Code subroutine json_info_by_path ( json , p , path , found , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name type ( json_value ), pointer :: p_var !! temporary pointer logical ( LK ) :: ok !! if the variable was found #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: p_name !! temporary variable for getting name #endif call json % get ( p , path , p_var , found ) !check if it was found: if ( present ( found )) then ok = found else ok = . not . json % exception_thrown end if if (. not . ok ) then if ( present ( var_type )) var_type = json_unknown if ( present ( n_children )) n_children = 0 if ( present ( name )) name = CK_ '' else !get info: #if defined __GFORTRAN__ call json % info ( p_var , var_type , n_children ) if ( present ( name )) then !workaround for gfortran bug if ( allocated ( p_var % name )) then p_name = p_var % name name = p_name else name = CK_ '' end if end if #else call json % info ( p_var , var_type , n_children , name ) #endif end if end subroutine json_info_by_path","title":"json_info_by_path – JSON-Fortran","tags":"","loc":"proc/json_info_by_path.html"},{"text":"private subroutine json_initialize(me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Initialize the json_core instance. The routine may be called before any of the json_core methods are used in\n  order to specify certain parameters. If it is not called, then the defaults\n  are used. This routine is also called internally by various routines.\n  It can also be called to clear exceptions, or to reset some\n  of the variables (note that only the arguments present are changed). Modified Izaak Beekman : 02/24/2015 Note initialize_json_core , json_initialize , initialize_json_core_in_file , and initialize_json_file all have a similar interface. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys If True [default] then no special checks\n   are done to check for duplicate keys. If False, then after parsing, if any duplicate\n   keys are found, an error is thrown. A call to json_value_validate will also check for\n   duplicates. logical(kind=LK), intent(in), optional :: escape_solidus If True then the solidus \" / \" is always escaped\n   \" \\/ \" when serializing JSON If False [default], then it is not escaped.\n Note that this option does not affect parsing\n (both escaped and unescaped are still valid in\n all cases). logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Source Code json_initialize Source Code subroutine json_initialize ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ,& no_whitespace ,& unescape_strings ,& comment_char ,& path_mode ,& path_separator ,& compress_vectors ,& allow_duplicate_keys ,& escape_solidus ,& stop_on_error ) implicit none class ( json_core ), intent ( inout ) :: me #include \"json_initialize_arguments.inc\" character ( kind = CDK , len = 10 ) :: w !! max string length character ( kind = CDK , len = 10 ) :: d !! real precision digits character ( kind = CDK , len = 10 ) :: e !! real exponent digits character ( kind = CDK , len = 2 ) :: sgn !! sign flag: `ss` or `sp` character ( kind = CDK , len = 2 ) :: rl_edit_desc !! `G`, `E`, `EN`, or `ES` integer ( IK ) :: istat !! `iostat` flag for !! write statements logical ( LK ) :: sgn_prnt !! print sign flag !reset exception to false: call me % clear_exceptions () !Just in case, clear these global variables also: me % pushed_index = 0 me % pushed_char = CK_ '' me % char_count = 0 me % line_count = 1 me % ipos = 1 #ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) #endif !various optional inputs: if ( present ( spaces_per_tab )) & me % spaces_per_tab = spaces_per_tab if ( present ( stop_on_error )) & me % stop_on_error = stop_on_error if ( present ( verbose )) & me % is_verbose = verbose if ( present ( strict_type_checking )) & me % strict_type_checking = strict_type_checking if ( present ( trailing_spaces_significant )) & me % trailing_spaces_significant = trailing_spaces_significant if ( present ( case_sensitive_keys )) & me % case_sensitive_keys = case_sensitive_keys if ( present ( no_whitespace )) & me % no_whitespace = no_whitespace if ( present ( unescape_strings )) & me % unescaped_strings = unescape_strings if ( present ( path_mode )) then if ( path_mode == 1_IK . or . path_mode == 2_IK . or . path_mode == 3_IK ) then me % path_mode = path_mode else me % path_mode = 1_IK ! just to have a valid value call me % throw_exception ( 'Invalid path_mode.' ) end if end if ! if we are allowing comments in the file: ! [an empty string disables comments] if ( present ( comment_char )) then me % allow_comments = comment_char /= CK_ '' me % comment_char = comment_char end if ! path separator: if ( present ( path_separator )) then me % path_separator = path_separator end if ! printing vectors in compressed form: if ( present ( compress_vectors )) then me % compress_vectors = compress_vectors end if ! checking for duplicate keys: if ( present ( allow_duplicate_keys )) then me % allow_duplicate_keys = allow_duplicate_keys end if ! if escaping the forward slash: if ( present ( escape_solidus )) then me % escape_solidus = escape_solidus end if !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( me % real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then !allow the special case where real format is '*': ! [this overrides the other options] if ( present ( real_format )) then if ( real_format == star ) then if ( present ( compact_reals )) then ! we will also allow for compact reals with ! '*' format, if both arguments are present. me % compact_real = compact_reals else me % compact_real = . false . end if me % real_fmt = star return end if end if if ( present ( compact_reals )) me % compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call me % throw_exception ( 'Invalid real format, \"' // & trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then me % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else me % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & '27.17E4)' !just use this one (should never happen) end if end if end subroutine json_initialize","title":"json_initialize – JSON-Fortran","tags":"","loc":"proc/json_initialize.html"},{"text":"private subroutine json_matrix_info(json, p, is_matrix, var_type, n_sets, set_size, name) Alternate version of json_info that returns matrix\n  information about a json_value . A json_value is a valid rank 2 matrix if all of the following are true: The var_type is json_array Each child is also a json_array , each of which has the same number of elements Each individual element has the same variable type (integer, logical, etc.) The idea here is that if it is a valid matrix, it can be interoperable with\n  a Fortran rank 2 array of the same type. Example The following example is an array with var_type=json_integer , n_sets=3 , and set_size=4 { \"matrix\" : [ [ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ] ] } Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix integer(kind=IK), intent(out), optional :: var_type variable type of data in the matrix\n (if all elements have the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Source Code json_matrix_info Source Code subroutine json_matrix_info ( json , p , is_matrix , var_type , n_sets , set_size , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON linked list logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in the matrix !! (if all elements have the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name type ( json_value ), pointer :: p_row !! for getting a set type ( json_value ), pointer :: p_element !! for getting an element in a set integer ( IK ) :: vartype !! json variable type of `p` integer ( IK ) :: row_vartype !! json variable type of a row integer ( IK ) :: element_vartype !! json variable type of an element in a row integer ( IK ) :: nr !! number of children of `p` integer ( IK ) :: nc !! number of elements in first child of `p` integer ( IK ) :: icount !! number of elements in a set integer :: i !! counter integer :: j !! counter #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: p_name !! temporary variable for getting name #endif !get info about the variable: #if defined __GFORTRAN__ call json % info ( p , vartype , nr ) if ( present ( name )) then !workaround for gfortran bug if ( allocated ( p % name )) then p_name = p % name name = p_name else name = CK_ '' end if end if #else call json % info ( p , vartype , nr , name ) #endif is_matrix = ( vartype == json_array ) if ( is_matrix ) then main : do i = 1 , nr nullify ( p_row ) call json % get_child ( p , i , p_row ) if (. not . associated ( p_row )) then is_matrix = . false . call json % throw_exception ( 'Error in json_matrix_info: ' // & 'Malformed JSON linked list' ) exit main end if call json % info ( p_row , var_type = row_vartype , n_children = icount ) if ( row_vartype == json_array ) then if ( i == 1 ) nc = icount !number of columns in first row if ( icount == nc ) then !make sure each row has the same number of columns !see if all the variables in this row are the same type: do j = 1 , icount nullify ( p_element ) call json % get_child ( p_row , j , p_element ) if (. not . associated ( p_element )) then is_matrix = . false . call json % throw_exception ( 'Error in json_matrix_info: ' // & 'Malformed JSON linked list' ) exit main end if call json % info ( p_element , var_type = element_vartype ) if ( i == 1 . and . j == 1 ) vartype = element_vartype !type of first element !in the row if ( vartype /= element_vartype ) then !not all variables are the same time is_matrix = . false . exit main end if end do else is_matrix = . false . exit main end if else is_matrix = . false . exit main end if end do main end if if ( is_matrix ) then if ( present ( var_type )) var_type = vartype if ( present ( n_sets )) n_sets = nr if ( present ( set_size )) set_size = nc else if ( present ( var_type )) var_type = json_unknown if ( present ( n_sets )) n_sets = 0 if ( present ( set_size )) set_size = 0 end if end subroutine json_matrix_info","title":"json_matrix_info – JSON-Fortran","tags":"","loc":"proc/json_matrix_info.html"},{"text":"private subroutine json_matrix_info_by_path(json, p, path, is_matrix, found, var_type, n_sets, set_size, name) Returns matrix information about a json_value , given the path. See also json_matrix_info Note If found is present, no exceptions will be thrown if an\n      error occurs. Otherwise, an exception will be thrown if the\n      variable is not found. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Source Code json_matrix_info_by_path Source Code subroutine json_matrix_info_by_path ( json , p , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name type ( json_value ), pointer :: p_var logical ( LK ) :: ok #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: p_name !! temporary variable for getting name #endif call json % get ( p , path , p_var , found ) !check if it was found: if ( present ( found )) then ok = found else ok = . not . json % exception_thrown end if if (. not . ok ) then if ( present ( var_type )) var_type = json_unknown if ( present ( n_sets )) n_sets = 0 if ( present ( set_size )) set_size = 0 if ( present ( name )) name = CK_ '' else !get info about the variable: #if defined __GFORTRAN__ call json % matrix_info ( p_var , is_matrix , var_type , n_sets , set_size ) if ( present ( name )) then !workaround for gfortran bug if ( allocated ( p_var % name )) then p_name = p_var % name name = p_name else name = CK_ '' end if end if #else call json % matrix_info ( p_var , is_matrix , var_type , n_sets , set_size , name ) #endif if ( json % exception_thrown . and . present ( found )) then found = . false . call json % clear_exceptions () end if end if end subroutine json_matrix_info_by_path","title":"json_matrix_info_by_path – JSON-Fortran","tags":"","loc":"proc/json_matrix_info_by_path.html"},{"text":"private subroutine json_parse_file(json, file, p, unit) Parse the JSON file and populate the json_value tree. Inputs The inputs can be: file & unit : the specified unit is used to read JSON from file.\n                      [note if unit is already open, then the filename is ignored] file : JSON is read from file using internal unit number Example type ( json_core ) :: json type ( json_value ), pointer :: p call json % parse ( file = 'myfile.json' , p = p ) History Jacob Williams : 01/13/2015 : added read from string option. Izaak Beekman  : 03/08/2015 : moved read from string to separate\n    subroutine, and error annotation to separate subroutine. Note When calling this routine, any exceptions thrown from previous\n      calls will automatically be cleared. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Calls proc~~json_parse_file~~CallsGraph proc~json_parse_file json_parse_file proc~json_value_create json_value_create proc~json_parse_file->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_parse_file Source Code subroutine json_parse_file ( json , file , p , unit ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit !! file unit actually used integer ( IK ) :: istat !! iostat flag logical ( LK ) :: is_open !! if the file is already open logical ( LK ) :: has_duplicate !! if checking for duplicate keys character ( kind = CK , len = :), allocatable :: path !! path to any duplicate key !clear any exceptions and initialize: call json % initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call json % throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call json % parse_value ( unit = iunit , str = CK_ '' , value = p ) ! close the file if necessary close ( unit = iunit , iostat = istat ) ! check for errors: if ( json % exception_thrown ) then call json % annotate_invalid_json ( iunit , CK_ '' ) else if (. not . json % allow_duplicate_keys ) then call json % check_for_duplicate_keys ( p , has_duplicate , path = path ) if (. not . json % exception_thrown ) then if ( has_duplicate ) then call json % throw_exception ( 'Error in json_parse_file: ' // & 'Duplicate key found: ' // path ) end if end if end if end if else call json % throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file","title":"json_parse_file – JSON-Fortran","tags":"","loc":"proc/json_parse_file.html"},{"text":"private subroutine json_parse_string(json, p, str) Parse the JSON string and populate the json_value tree. See also json_parse_file Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Calls proc~~json_parse_string~~CallsGraph proc~json_parse_string json_parse_string proc~json_value_create json_value_create proc~json_parse_string->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_parse_string Source Code subroutine json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !! indicates that json data will be read from buffer logical ( LK ) :: has_duplicate !! if checking for duplicate keys character ( kind = CK , len = :), allocatable :: path !! path to any duplicate key !clear any exceptions and initialize: call json % initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = CK_ '' ! parse as a value call json % parse_value ( unit = iunit , str = str , value = p ) if ( json % exception_thrown ) then call json % annotate_invalid_json ( iunit , str ) else if (. not . json % allow_duplicate_keys ) then call json % check_for_duplicate_keys ( p , has_duplicate , path = path ) if (. not . json % exception_thrown ) then if ( has_duplicate ) then call json % throw_exception ( 'Error in json_parse_string: ' // & 'Duplicate key found: ' // path ) end if end if end if end if end subroutine json_parse_string","title":"json_parse_string – JSON-Fortran","tags":"","loc":"proc/json_parse_string.html"},{"text":"private subroutine json_print_1(json, p, iunit) Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must\n already have been opened, can't be -1). Source Code json_print_1 Source Code subroutine json_print_1 ( json , p , iunit ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must !! already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json % json_value_print ( p , iunit , str = dummy , indent = 1_IK , colon = . true .) else call json % throw_exception ( 'Error in json_print_1: iunit must not be -1.' ) end if end subroutine json_print_1","title":"json_print_1 – JSON-Fortran","tags":"","loc":"proc/json_print_1.html"},{"text":"private subroutine json_print_2(json, p, filename) Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to\n (should not already be open) Source Code json_print_2 Source Code subroutine json_print_2 ( json , p , filename ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to !! (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json % print ( p , iunit ) close ( iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2","title":"json_print_2 – JSON-Fortran","tags":"","loc":"proc/json_print_2.html"},{"text":"private subroutine json_print_error_message(json, io_unit) Print any error message, and then clear the exceptions. Note This routine is used by the unit tests.\n      It was originally in json_example.f90, and was\n      moved here 2/26/2015 by Izaak Beekman. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit Source Code json_print_error_message Source Code subroutine json_print_error_message ( json , io_unit ) implicit none class ( json_core ), intent ( inout ) :: json integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg !! error message logical :: status_ok !! false if there were any errors thrown !get error message: call json % check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( output_unit , '(A)' ) error_msg end if deallocate ( error_msg ) call json % clear_exceptions () end if end subroutine json_print_error_message","title":"json_print_error_message – JSON-Fortran","tags":"","loc":"proc/json_print_error_message.html"},{"text":"private subroutine json_rename_by_path(json, me, path, name, found) Rename a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found Source Code json_rename_by_path Source Code subroutine json_rename_by_path ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: name !! the new name logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_rename_by_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % rename ( p , name ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_rename_by_path","title":"json_rename_by_path – JSON-Fortran","tags":"","loc":"proc/json_rename_by_path.html"},{"text":"private subroutine json_rename_by_path_name_ascii(json, me, path, name, found) Alternate version of json_rename_by_path , where \"name\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(out), optional :: found Calls proc~~json_rename_by_path_name_ascii~~CallsGraph proc~json_rename_by_path_name_ascii json_rename_by_path_name_ascii interface~to_unicode to_unicode proc~json_rename_by_path_name_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_rename_by_path_name_ascii Source Code subroutine json_rename_by_path_name_ascii ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( out ), optional :: found call json % rename ( me , path , to_unicode ( name ), found ) end subroutine json_rename_by_path_name_ascii","title":"json_rename_by_path_name_ascii – JSON-Fortran","tags":"","loc":"proc/json_rename_by_path_name_ascii.html"},{"text":"private subroutine json_rename_by_path_path_ascii(json, me, path, name, found) Alternate version of json_rename_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(out), optional :: found Calls proc~~json_rename_by_path_path_ascii~~CallsGraph proc~json_rename_by_path_path_ascii json_rename_by_path_path_ascii interface~to_unicode to_unicode proc~json_rename_by_path_path_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_rename_by_path_path_ascii Source Code subroutine json_rename_by_path_path_ascii ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( out ), optional :: found call json % rename ( me , to_unicode ( path ), name , found ) end subroutine json_rename_by_path_path_ascii","title":"json_rename_by_path_path_ascii – JSON-Fortran","tags":"","loc":"proc/json_rename_by_path_path_ascii.html"},{"text":"private subroutine json_string_info(json, p, ilen, max_str_len, found) Returns information about character strings returned from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional dimension(:), allocatable :: ilen if p is an array, this\n is the actual length\n of each character\n string in the array.\n if not an array, this\n is returned unallocated. integer(kind=IK), intent(out), optional :: max_str_len The maximum length required to\n hold the string representation returned\n by a call to a get routine. If a scalar,\n this is just the length of the scalar. If\n a vector, this is the maximum length of\n any element. logical(kind=LK), intent(out), optional :: found true if there were no errors.\n if not present, an error will\n throw an exception Source Code json_string_info Source Code subroutine json_string_info ( json , p , ilen , max_str_len , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), dimension (:), allocatable , intent ( out ), optional :: ilen !! if `p` is an array, this !! is the actual length !! of each character !! string in the array. !! if not an array, this !! is returned unallocated. integer ( IK ), intent ( out ), optional :: max_str_len !! The maximum length required to !! hold the string representation returned !! by a call to a `get` routine. If a scalar, !! this is just the length of the scalar. If !! a vector, this is the maximum length of !! any element. logical ( LK ), intent ( out ), optional :: found !! true if there were no errors. !! if not present, an error will !! throw an exception character ( kind = CK , len = :), allocatable :: cval !! for getting values as strings. logical ( LK ) :: initialized !! if the output array has been sized logical ( LK ) :: get_max_len !! if we are returning the `max_str_len` logical ( LK ) :: get_ilen !! if we are returning the `ilen` array integer ( IK ) :: var_type !! variable type get_max_len = present ( max_str_len ) get_ilen = present ( ilen ) if (. not . json % exception_thrown ) then if ( present ( found )) found = . true . initialized = . false . if ( get_max_len ) max_str_len = 0 select case ( p % var_type ) case ( json_array ) ! it's an array ! call routine for each element call json % get ( p , array_callback = get_string_lengths ) case default ! not an array if ( json % strict_type_checking ) then ! only allowing strings to be returned ! as strings, so we can check size directly call json % info ( p , var_type = var_type ) if ( var_type == json_string ) then if ( allocated ( p % str_value ) . and . get_max_len ) & max_str_len = len ( p % str_value ) else ! it isn't a string, so there is no length call json % throw_exception ( 'Error in json_string_info: ' // & 'When strict_type_checking is true ' // & 'the variable must be a character string.' ) end if else ! in this case, we have to get the value ! as a string to know what size it is. call json % get ( p , value = cval ) if (. not . json % exception_thrown ) then if ( allocated ( cval ) . and . get_max_len ) & max_str_len = len ( cval ) end if end if end select end if if ( json % exception_thrown ) then if ( present ( found )) then call json % clear_exceptions () found = . false . end if if ( get_max_len ) max_str_len = 0 if ( get_ilen ) then if ( allocated ( ilen )) deallocate ( ilen ) end if end if contains subroutine get_string_lengths ( json , element , i , count ) !! callback function to call for each element in the array. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval integer ( IK ) :: var_type if ( json % exception_thrown ) return if (. not . initialized ) then if ( get_ilen ) allocate ( ilen ( count )) initialized = . true . end if if ( json % strict_type_checking ) then ! only allowing strings to be returned ! as strings, so we can check size directly call json % info ( element , var_type = var_type ) if ( var_type == json_string ) then if ( allocated ( element % str_value )) then if ( get_max_len ) then if ( len ( element % str_value ) > max_str_len ) & max_str_len = len ( element % str_value ) end if if ( get_ilen ) ilen ( i ) = len ( element % str_value ) else if ( get_ilen ) ilen ( i ) = 0 end if else ! it isn't a string, so there is no length call json % throw_exception ( 'Error in json_string_info: ' // & 'When strict_type_checking is true ' // & 'the array must contain only ' // & 'character strings.' ) end if else ! in this case, we have to get the value ! as a string to know what size it is. call json % get ( element , value = cval ) if ( json % exception_thrown ) return if ( allocated ( cval )) then if ( get_max_len ) then if ( len ( cval ) > max_str_len ) max_str_len = len ( cval ) end if if ( get_ilen ) ilen ( i ) = len ( cval ) else if ( get_ilen ) ilen ( i ) = 0 end if end if end subroutine get_string_lengths end subroutine json_string_info","title":"json_string_info – JSON-Fortran","tags":"","loc":"proc/json_string_info.html"},{"text":"private subroutine json_throw_exception(json, msg) Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. Note If is_verbose is true, this will also print a\n      traceback if the Intel compiler is used. Note If stop_on_error is true, then the program is stopped. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message Source Code json_throw_exception Source Code subroutine json_throw_exception ( json , msg ) #ifdef __INTEL_COMPILER use ifcore , only : tracebackqq #endif implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: msg !! the error message json % exception_thrown = . true . json % err_message = trim ( msg ) if ( json % stop_on_error ) then #ifdef __INTEL_COMPILER ! for Intel, we raise a traceback and quit call tracebackqq ( string = trim ( msg ), user_exit_code = 0 ) #else write ( error_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) error stop 1 #endif elseif ( json % is_verbose ) then write ( output_unit , '(A)' ) '***********************' write ( output_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) !#if defined __GFORTRAN__ !        call backtrace()  ! (have to compile with -fbacktrace -fall-intrinsics flags) !#endif #ifdef __INTEL_COMPILER call tracebackqq ( user_exit_code =- 1 ) ! print a traceback and return #endif write ( output_unit , '(A)' ) '***********************' end if end subroutine json_throw_exception","title":"json_throw_exception – JSON-Fortran","tags":"","loc":"proc/json_throw_exception.html"},{"text":"private subroutine json_traverse(json, p, traverse_callback) Traverse a JSON structure.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure( json_traverse_callback_func ) :: traverse_callback Source Code json_traverse Source Code subroutine json_traverse ( json , p , traverse_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p procedure ( json_traverse_callback_func ) :: traverse_callback logical ( LK ) :: finished !! can be used to stop the process if (. not . json % exception_thrown ) call traverse ( p ) contains recursive subroutine traverse ( p ) !! recursive [[json_value]] traversal. implicit none type ( json_value ), pointer , intent ( in ) :: p type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children if ( json % exception_thrown ) return call traverse_callback ( json , p , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( p % var_type == json_array . or . p % var_type == json_object ) then icount = json % count ( p ) ! number of children if ( icount > 0 ) then element => p % children ! first one do i = 1 , icount ! call for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_traverse: ' // & 'Malformed JSON linked list' ) return end if call traverse ( element ) if ( finished . or . json % exception_thrown ) exit element => element % next end do end if nullify ( element ) end if end subroutine traverse end subroutine json_traverse","title":"json_traverse – JSON-Fortran","tags":"","loc":"proc/json_traverse.html"},{"text":"private subroutine json_update_double(json, p, path, val, found) Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Source Code json_update_double Source Code subroutine json_update_double ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_double ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_double","title":"json_update_double – JSON-Fortran","tags":"","loc":"proc/json_update_double.html"},{"text":"private subroutine json_update_integer(json, p, path, val, found) Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Source Code json_update_integer Source Code subroutine json_update_integer ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_integer ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_integer","title":"json_update_integer – JSON-Fortran","tags":"","loc":"proc/json_update_integer.html"},{"text":"private subroutine json_update_logical(json, p, path, val, found) Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Source Code json_update_logical Source Code subroutine json_update_logical ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_logical ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_logical","title":"json_update_logical – JSON-Fortran","tags":"","loc":"proc/json_update_logical.html"},{"text":"private subroutine json_update_string(json, p, path, val, found, trim_str, adjustl_str) Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) Source Code json_update_string Source Code subroutine json_update_string ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , path , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call json % to_string ( p_var , val , trim_str = trim_str , adjustl_str = adjustl_str ) ! update the value case default found = . false . call json % throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json % add_by_path ( p , path , val ) !add the new element end if end subroutine json_update_string","title":"json_update_string – JSON-Fortran","tags":"","loc":"proc/json_update_string.html"},{"text":"private subroutine json_update_string_name_ascii(json, p, path, val, found, trim_str, adjustl_str) Alternate version of json_update_string , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) Calls proc~~json_update_string_name_ascii~~CallsGraph proc~json_update_string_name_ascii json_update_string_name_ascii interface~to_unicode to_unicode proc~json_update_string_name_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_update_string_name_ascii Source Code subroutine json_update_string_name_ascii ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) call json % update ( p , to_unicode ( path ), val , found , trim_str , adjustl_str ) end subroutine json_update_string_name_ascii","title":"json_update_string_name_ascii – JSON-Fortran","tags":"","loc":"proc/json_update_string_name_ascii.html"},{"text":"private subroutine json_update_string_val_ascii(json, p, path, val, found, trim_str, adjustl_str) Alternate version of json_update_string , where val is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) Calls proc~~json_update_string_val_ascii~~CallsGraph proc~json_update_string_val_ascii json_update_string_val_ascii interface~to_unicode to_unicode proc~json_update_string_val_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_update_string_val_ascii Source Code subroutine json_update_string_val_ascii ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) call json % update ( p , path , to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine json_update_string_val_ascii","title":"json_update_string_val_ascii – JSON-Fortran","tags":"","loc":"proc/json_update_string_val_ascii.html"},{"text":"private subroutine json_value_add_double(json, p, name, val) Add a real value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Source Code json_value_add_double Source Code subroutine json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json % create_double ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_double","title":"json_value_add_double – JSON-Fortran","tags":"","loc":"proc/json_value_add_double.html"},{"text":"private subroutine json_value_add_double_vec(json, p, name, val) Add a real vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Source Code json_value_add_double_vec Source Code subroutine json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_double_vec","title":"json_value_add_double_vec – JSON-Fortran","tags":"","loc":"proc/json_value_add_double_vec.html"},{"text":"private subroutine json_value_add_integer(json, p, name, val) Add an integer value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Source Code json_value_add_integer Source Code subroutine json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json % create_integer ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_integer","title":"json_value_add_integer – JSON-Fortran","tags":"","loc":"proc/json_value_add_integer.html"},{"text":"private subroutine json_value_add_integer_vec(json, p, name, val) Add an integer vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Source Code json_value_add_integer_vec Source Code subroutine json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create a variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_integer_vec","title":"json_value_add_integer_vec – JSON-Fortran","tags":"","loc":"proc/json_value_add_integer_vec.html"},{"text":"private subroutine json_value_add_logical(json, p, name, val) Add a logical value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Source Code json_value_add_logical Source Code subroutine json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json % create_logical ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_logical","title":"json_value_add_logical – JSON-Fortran","tags":"","loc":"proc/json_value_add_logical.html"},{"text":"private subroutine json_value_add_logical_vec(json, p, name, val) Add a logical vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Source Code json_value_add_logical_vec Source Code subroutine json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_logical_vec","title":"json_value_add_logical_vec – JSON-Fortran","tags":"","loc":"proc/json_value_add_logical_vec.html"},{"text":"private subroutine json_value_add_member(json, p, member) Adds member as a child of p . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p type( json_value ), pointer :: member the child member\n to add to p Source Code json_value_add_member Source Code subroutine json_value_add_member ( json , p , member ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: member !! the child member !! to add to `p` if (. not . json % exception_thrown ) then ! associate the parent member % parent => p ! add to linked list if ( associated ( p % children )) then p % tail % next => member member % previous => p % tail else p % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list p % tail => member p % n_children = p % n_children + 1 end if end subroutine json_value_add_member","title":"json_value_add_member – JSON-Fortran","tags":"","loc":"proc/json_value_add_member.html"},{"text":"private subroutine json_value_add_null(json, p, name) Add a NULL value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name Source Code json_value_add_null Source Code subroutine json_value_add_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: var !create the variable: call json % create_null ( var , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_null","title":"json_value_add_null – JSON-Fortran","tags":"","loc":"proc/json_value_add_null.html"},{"text":"private subroutine json_value_add_string(json, p, name, val, trim_str, adjustl_str) Add a character string child to the json_value variable. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val Source Code json_value_add_string Source Code subroutine json_value_add_string ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` type ( json_value ), pointer :: var !create the variable: call json % create_string ( var , val , name , trim_str , adjustl_str ) !add it: call json % add ( p , var ) end subroutine json_value_add_string","title":"json_value_add_string – JSON-Fortran","tags":"","loc":"proc/json_value_add_string.html"},{"text":"private subroutine json_value_add_string_name_ascii(json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val Calls proc~~json_value_add_string_name_ascii~~CallsGraph proc~json_value_add_string_name_ascii json_value_add_string_name_ascii interface~to_unicode to_unicode proc~json_value_add_string_name_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_add_string_name_ascii Source Code subroutine json_value_add_string_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_name_ascii","title":"json_value_add_string_name_ascii – JSON-Fortran","tags":"","loc":"proc/json_value_add_string_name_ascii.html"},{"text":"private subroutine json_value_add_string_val_ascii(json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string where val is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val Calls proc~~json_value_add_string_val_ascii~~CallsGraph proc~json_value_add_string_val_ascii json_value_add_string_val_ascii interface~to_unicode to_unicode proc~json_value_add_string_val_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_add_string_val_ascii Source Code subroutine json_value_add_string_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_val_ascii","title":"json_value_add_string_val_ascii – JSON-Fortran","tags":"","loc":"proc/json_value_add_string_val_ascii.html"},{"text":"private subroutine json_value_add_string_vec(json, p, name, val, trim_str, adjustl_str) Add an array of character strings to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Source Code json_value_add_string_vec Source Code subroutine json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , CK_ '' , val ( i ), trim_str , adjustl_str ) end do !add it: call json % add ( p , var ) end subroutine json_value_add_string_vec","title":"json_value_add_string_vec – JSON-Fortran","tags":"","loc":"proc/json_value_add_string_vec.html"},{"text":"private subroutine json_value_add_string_vec_name_ascii(json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Calls proc~~json_value_add_string_vec_name_ascii~~CallsGraph proc~json_value_add_string_vec_name_ascii json_value_add_string_vec_name_ascii interface~to_unicode to_unicode proc~json_value_add_string_vec_name_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_add_string_vec_name_ascii Source Code subroutine json_value_add_string_vec_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii","title":"json_value_add_string_vec_name_ascii – JSON-Fortran","tags":"","loc":"proc/json_value_add_string_vec_name_ascii.html"},{"text":"private subroutine json_value_add_string_vec_val_ascii(json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string_vec where val is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Calls proc~~json_value_add_string_vec_val_ascii~~CallsGraph proc~json_value_add_string_vec_val_ascii json_value_add_string_vec_val_ascii interface~to_unicode to_unicode proc~json_value_add_string_vec_val_ascii->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_add_string_vec_val_ascii Source Code subroutine json_value_add_string_vec_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii","title":"json_value_add_string_vec_val_ascii – JSON-Fortran","tags":"","loc":"proc/json_value_add_string_vec_val_ascii.html"},{"text":"private recursive subroutine json_value_clone_func(from, to, parent, previous, next, children, tail) Recursive deep copy function called by json_clone . Note If new data is added to the json_value type,\n      then this would need to be updated. Arguments Type Intent Optional Attributes Name type( json_value ), pointer :: from this is the structure to clone type( json_value ), pointer :: to the clone is put here (it\n must not already be associated) type( json_value ), optional pointer :: parent to%parent type( json_value ), optional pointer :: previous to%previous type( json_value ), optional pointer :: next to%next type( json_value ), optional pointer :: children to%children logical, optional :: tail if \"to\" is the tail of\n its parent's children Called By proc~~json_value_clone_func~~CalledByGraph proc~json_value_clone_func json_value_clone_func proc~json_value_clone_func->proc~json_value_clone_func proc~json_clone json_clone proc~json_clone->proc~json_value_clone_func Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_clone_func Source Code recursive subroutine json_value_clone_func ( from , to , parent , previous , next , children , tail ) implicit none type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here (it !! must not already be associated) type ( json_value ), pointer , optional :: parent !! to%parent type ( json_value ), pointer , optional :: previous !! to%previous type ( json_value ), pointer , optional :: next !! to%next type ( json_value ), pointer , optional :: children !! to%children logical , optional :: tail !! if \"to\" is the tail of !! its parent's children nullify ( to ) if ( associated ( from )) then allocate ( to ) !copy over the data variables: ! [note: the allocate() statements don't work here for the !  deferred-length characters in gfortran-4.9] if ( allocated ( from % name )) to % name = from % name if ( allocated ( from % dbl_value )) allocate ( to % dbl_value , source = from % dbl_value ) if ( allocated ( from % log_value )) allocate ( to % log_value , source = from % log_value ) if ( allocated ( from % str_value )) to % str_value = from % str_value if ( allocated ( from % int_value )) allocate ( to % int_value , source = from % int_value ) to % var_type = from % var_type to % n_children = from % n_children !allocate and associate the pointers as necessary: if ( present ( parent )) to % parent => parent if ( present ( previous )) to % previous => previous if ( present ( next )) to % next => next if ( present ( children )) to % children => children if ( present ( tail )) then if ( tail ) to % parent % tail => to end if if ( associated ( from % next )) then allocate ( to % next ) call json_value_clone_func ( from % next ,& to % next ,& previous = to ,& parent = to % parent ,& tail = (. not . associated ( from % next % next ))) end if if ( associated ( from % children )) then allocate ( to % children ) call json_value_clone_func ( from % children ,& to % children ,& parent = to ,& tail = (. not . associated ( from % children % next ))) end if end if end subroutine json_value_clone_func","title":"json_value_clone_func – JSON-Fortran","tags":"","loc":"proc/json_value_clone_func.html"},{"text":"private subroutine json_value_create(p) Allocate a json_value pointer variable.\n  This should be called before adding data to it. Example type ( json_value ), pointer :: var call json_value_create ( var ) call json % to_double ( var , 1.0_RK ) Notes This routine does not check for exceptions. The pointer should not already be allocated, or a memory leak will occur. Arguments Type Intent Optional Attributes Name type( json_value ), pointer :: p Called By proc~~json_value_create~~CalledByGraph proc~json_value_create json_value_create proc~json_value_create_null json_value_create_null proc~json_value_create_null->proc~json_value_create proc~json_value_create_logical json_value_create_logical proc~json_value_create_logical->proc~json_value_create proc~json_value_create_array json_value_create_array proc~json_value_create_array->proc~json_value_create proc~json_parse_string json_parse_string proc~json_parse_string->proc~json_value_create proc~json_get_by_path_jsonpath_bracket json_get_by_path_jsonpath_bracket proc~json_get_by_path_jsonpath_bracket->proc~json_value_create proc~json_value_create_string json_value_create_string proc~json_value_create_string->proc~json_value_create proc~json_value_create_object json_value_create_object proc~json_value_create_object->proc~json_value_create proc~parse_array parse_array proc~parse_array->proc~json_value_create proc~parse_object parse_object proc~parse_object->proc~json_value_create proc~json_parse_file json_parse_file proc~json_parse_file->proc~json_value_create proc~json_get_by_path_default json_get_by_path_default proc~json_get_by_path_default->proc~json_value_create proc~json_value_create_double json_value_create_double proc~json_value_create_double->proc~json_value_create proc~json_value_create_integer json_value_create_integer proc~json_value_create_integer->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create Source Code subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create","title":"json_value_create – JSON-Fortran","tags":"","loc":"proc/json_value_create.html"},{"text":"private subroutine json_value_create_array(json, p, name) Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_array ( p , 'arrayname' ) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name Calls proc~~json_value_create_array~~CallsGraph proc~json_value_create_array json_value_create_array proc~json_value_create json_value_create proc~json_value_create_array->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_array Source Code subroutine json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_array ( p , name ) end subroutine json_value_create_array","title":"json_value_create_array – JSON-Fortran","tags":"","loc":"proc/json_value_create_array.html"},{"text":"private subroutine json_value_create_double(json, p, val, name) Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_double ( p , 'value' , 1.0_RK ) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Calls proc~~json_value_create_double~~CallsGraph proc~json_value_create_double json_value_create_double proc~json_value_create json_value_create proc~json_value_create_double->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_double Source Code subroutine json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p real ( RK ), intent ( in ) :: val character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_double ( p , val , name ) end subroutine json_value_create_double","title":"json_value_create_double – JSON-Fortran","tags":"","loc":"proc/json_value_create_double.html"},{"text":"private subroutine json_value_create_integer(json, p, val, name) Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_integer ( p , 'value' , 1 ) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Calls proc~~json_value_create_integer~~CallsGraph proc~json_value_create_integer json_value_create_integer proc~json_value_create json_value_create proc~json_value_create_integer->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_integer Source Code subroutine json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( in ) :: val character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_integer ( p , val , name ) end subroutine json_value_create_integer","title":"json_value_create_integer – JSON-Fortran","tags":"","loc":"proc/json_value_create_integer.html"},{"text":"private subroutine json_value_create_logical(json, p, val, name) Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_logical ( p , 'value' ,. true .) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Calls proc~~json_value_create_logical~~CallsGraph proc~json_value_create_logical json_value_create_logical proc~json_value_create json_value_create proc~json_value_create_logical->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_logical Source Code subroutine json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ) :: val !! variable value character ( kind = CK , len =* ), intent ( in ) :: name !! variable name call json_value_create ( p ) call json % to_logical ( p , val , name ) end subroutine json_value_create_logical","title":"json_value_create_logical – JSON-Fortran","tags":"","loc":"proc/json_value_create_logical.html"},{"text":"private subroutine json_value_create_null(json, p, name) Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_null ( p , 'value' ) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name Calls proc~~json_value_create_null~~CallsGraph proc~json_value_create_null json_value_create_null proc~json_value_create json_value_create proc~json_value_create_null->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_null Source Code subroutine json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_null ( p , name ) end subroutine json_value_create_null","title":"json_value_create_null – JSON-Fortran","tags":"","loc":"proc/json_value_create_null.html"},{"text":"private subroutine json_value_create_object(json, p, name) Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_object ( p , 'objectname' ) Note The name is not significant for the root structure or an array element.\n      In those cases, an empty string can be used. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name Calls proc~~json_value_create_object~~CallsGraph proc~json_value_create_object json_value_create_object proc~json_value_create json_value_create proc~json_value_create_object->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_object Source Code subroutine json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call json % to_object ( p , name ) end subroutine json_value_create_object","title":"json_value_create_object – JSON-Fortran","tags":"","loc":"proc/json_value_create_object.html"},{"text":"private subroutine json_value_create_string(json, p, val, name, trim_str, adjustl_str) Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p type ( json_core ) :: json call json % create_string ( p , 'value' , 'hello' ) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val Calls proc~~json_value_create_string~~CallsGraph proc~json_value_create_string json_value_create_string proc~json_value_create json_value_create proc~json_value_create_string->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_create_string Source Code subroutine json_value_create_string ( json , p , val , name , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: val character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json_value_create ( p ) call json % to_string ( p , val , name , trim_str , adjustl_str ) end subroutine json_value_create_string","title":"json_value_create_string – JSON-Fortran","tags":"","loc":"proc/json_value_create_string.html"},{"text":"private recursive subroutine json_value_destroy(json, p, destroy_next) Destroy a json_value linked-list structure. Note The original FSON version of this\n      routine was not properly freeing the memory.\n      It was rewritten. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) Calls proc~~json_value_destroy~~CallsGraph proc~json_value_destroy json_value_destroy proc~destroy_json_data destroy_json_data proc~json_value_destroy->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_destroy Source Code recursive subroutine json_value_destroy ( json , p , destroy_next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! variable to destroy logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then `p%next` !! is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: child if ( associated ( p )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( p % name )) deallocate ( p % name ) call destroy_json_data ( p ) if ( associated ( p % children )) then do while ( p % n_children > 0 ) child => p % children if ( associated ( child )) then p % children => p % children % next p % n_children = p % n_children - 1 call json % destroy ( child ,. false .) else call json % throw_exception ( 'Error in json_value_destroy: ' // & 'Malformed JSON linked list' ) exit end if end do nullify ( p % children ) nullify ( child ) end if if ( associated ( p % next ) . and . des_next ) call json % destroy ( p % next ) if ( associated ( p % previous )) nullify ( p % previous ) if ( associated ( p % parent )) nullify ( p % parent ) if ( associated ( p % tail )) nullify ( p % tail ) deallocate ( p ) nullify ( p ) end if end subroutine json_value_destroy","title":"json_value_destroy – JSON-Fortran","tags":"","loc":"proc/json_value_destroy.html"},{"text":"private subroutine json_value_get_child(json, p, child) Returns pointer to the first child of the object\n  (or null() if it is not associated). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), pointer :: child pointer to the child Source Code json_value_get_child Source Code subroutine json_value_get_child ( json , p , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data type ( json_value ), pointer :: child !! pointer to the child if ( associated ( p )) then child => p % children else nullify ( child ) call json % throw_exception ( 'Error in json_value_get_child: ' // & 'pointer is not associated.' ) end if end subroutine json_value_get_child","title":"json_value_get_child – JSON-Fortran","tags":"","loc":"proc/json_value_get_child.html"},{"text":"private subroutine json_value_get_child_by_index(json, p, idx, child, found) Returns a child in the object or array given the index. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child\n (this is a 1-based Fortran\n style array index). type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). Source Code json_value_get_child_by_index Source Code subroutine json_value_get_child_by_index ( json , p , idx , child , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child !! (this is a 1-based Fortran !! style array index). type ( json_value ), pointer :: child !! pointer to the child logical ( LK ), intent ( out ), optional :: found !! true if the value was found !! (if not present, an exception !! will be thrown if it was not !! found.  If present and not !! found, no exception will be !! thrown). integer ( IK ) :: i !! counter nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p % children )) then child => p % children do i = 1 , idx - 1 if ( associated ( child % next )) then child => child % next else call json % throw_exception ( 'Error in json_value_get_child_by_index:' // & ' child%next is not associated.' ) nullify ( child ) exit end if end do else call json % throw_exception ( 'Error in json_value_get_child_by_index:' // & ' p%children is not associated.' ) end if ! found output: if ( json % exception_thrown ) then if ( present ( found )) then call json % clear_exceptions () found = . false . end if else if ( present ( found )) found = . true . end if else if ( present ( found )) found = . false . end if end subroutine json_value_get_child_by_index","title":"json_value_get_child_by_index – JSON-Fortran","tags":"","loc":"proc/json_value_get_child_by_index.html"},{"text":"private subroutine json_value_get_child_by_name(json, p, name, child, found) Returns a child in the object or array given the name string. The name search can be case-sensitive or not, and can have significant trailing\n  whitespace or not, depending on the settings in the json_core class. Note The name input is not a path, and is not parsed like it is in json_get_by_path . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). Source Code json_value_get_child_by_name Source Code subroutine json_value_get_child_by_name ( json , p , name , child , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of `p` type ( json_value ), pointer :: child !! pointer to the child logical ( LK ), intent ( out ), optional :: found !! true if the value was found !! (if not present, an exception !! will be thrown if it was not !! found.  If present and not !! found, no exception will be !! thrown). integer ( IK ) :: i , n_children logical :: error nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p )) then error = . true . ! will be false if it is found if ( p % var_type == json_object ) then n_children = json % count ( p ) child => p % children !start with first one do i = 1 , n_children if (. not . associated ( child )) then call json % throw_exception (& 'Error in json_value_get_child_by_name: ' // & 'Malformed JSON linked list' ) exit end if if ( allocated ( child % name )) then !name string matching routine: if ( json % name_equal ( child , name )) then error = . false . exit end if end if child => child % next end do end if if ( error ) then !did not find anything: call json % throw_exception (& 'Error in json_value_get_child_by_name: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( child ) end if else call json % throw_exception (& 'Error in json_value_get_child_by_name: ' // & 'pointer is not associated.' ) end if ! found output: if ( json % exception_thrown ) then if ( present ( found )) then call json % clear_exceptions () found = . false . end if else if ( present ( found )) found = . true . end if else if ( present ( found )) found = . false . end if end subroutine json_value_get_child_by_name","title":"json_value_get_child_by_name – JSON-Fortran","tags":"","loc":"proc/json_value_get_child_by_name.html"},{"text":"private subroutine json_value_insert_after(json, p, element) Inserts element after p , and updates the JSON structure accordingly. Example program test use json_module implicit none logical ( json_LK ) :: found type ( json_core ) :: json type ( json_value ), pointer :: p , new , element call json % parse ( file = 'myfile.json' , p = p ) call json % get ( p , 'x(3)' , element , found ) ! get pointer to an array element in the file call json % create_integer ( new , 1 , '' ) ! create a new element call json % insert_after ( element , new ) ! insert new element after x(3) call json % print ( p , 'myfile2.json' ) ! write it to a file call json % destroy ( p ) ! cleanup end program test Details This routine can be used to insert a new element (or set of elements)\n    into an array or object at a specific index.\n    See json_value_insert_after_child_by_index Children and subsequent elements of element are carried along. If the inserted elements are part of an existing list, then\n    they are removed from that list. p\n       [1] - [2] - [3] - [4]\n                 |\n                [5] - [6] - [7]        n=3 elements inserted\n              element       last\n\n  Result is:\n\n       [1] - [2] - [5] - [6] - [7] - [3] - [4] Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a value from a JSON structure\n (presumably, this is a child of\n an object or array). type( json_value ), pointer :: element the element to insert after p Source Code json_value_insert_after Source Code subroutine json_value_insert_after ( json , p , element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a value from a JSON structure !! (presumably, this is a child of !! an object or array). type ( json_value ), pointer :: element !! the element to insert after `p` type ( json_value ), pointer :: parent !! the parent of `p` type ( json_value ), pointer :: next !! temp pointer for traversing structure type ( json_value ), pointer :: last !! the last of the items being inserted integer :: n !! number of items being inserted if (. not . json % exception_thrown ) then parent => p % parent ! set first parent of inserted list: element % parent => parent ! Count the number of inserted elements. ! and set their parents. n = 1 ! initialize counter next => element % next last => element do if (. not . associated ( next )) exit n = n + 1 next % parent => parent last => next next => next % next end do if ( associated ( parent )) then ! update parent's child counter: parent % n_children = parent % n_children + n ! if p is last of parents children then ! also have to update parent tail pointer: if ( associated ( parent % tail , p )) then parent % tail => last end if end if if ( associated ( element % previous )) then ! element is apparently part of an existing list, ! so have to update that as well. if ( associated ( element % previous % parent )) then element % previous % parent % n_children = & element % previous % parent % n_children - n element % previous % parent % tail => & element % previous ! now the last one in the list else ! this would be a memory leak if the previous entries ! are not otherwise being pointed too ! [throw an error in this case???] end if !remove element from the other list: element % previous % next => null () end if element % previous => p if ( associated ( p % next )) then ! if there are any in the list after p: last % next => p % next last % next % previous => element else last % next => null () end if p % next => element end if end subroutine json_value_insert_after","title":"json_value_insert_after – JSON-Fortran","tags":"","loc":"proc/json_value_insert_after.html"},{"text":"private subroutine json_value_insert_after_child_by_index(json, p, idx, element) Inserts element after the idx -th child of p ,\n  and updates the JSON structure accordingly. This is just\n  a wrapper for json_value_insert_after . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON object or array. integer(kind=IK), intent(in) :: idx the index of the child of p to\n insert the new element after\n (this is a 1-based Fortran\n style array index) type( json_value ), pointer :: element the element to insert Source Code json_value_insert_after_child_by_index Source Code subroutine json_value_insert_after_child_by_index ( json , p , idx , element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON object or array. integer ( IK ), intent ( in ) :: idx !! the index of the child of `p` to !! insert the new element after !! (this is a 1-based Fortran !! style array index) type ( json_value ), pointer :: element !! the element to insert type ( json_value ), pointer :: tmp !! for getting the `idx`-th child of `p` if (. not . json % exception_thrown ) then ! get the idx-th child of p: call json % get_child ( p , idx , tmp ) ! call json_value_insert_after: if (. not . json % exception_thrown ) call json % insert_after ( tmp , element ) end if end subroutine json_value_insert_after_child_by_index","title":"json_value_insert_after_child_by_index – JSON-Fortran","tags":"","loc":"proc/json_value_insert_after_child_by_index.html"},{"text":"private recursive subroutine json_value_print(json, p, iunit, str, indent, need_comma, colon, is_array_element, is_compressed_vector) Print the JSON structure to a string or a file. Notes This is an internal routine called by the various wrapper routines. The reason the str argument is non-optional is because of a\n    bug in v4.9 of the gfortran compiler. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element logical(kind=LK), intent(in), optional :: is_compressed_vector if True, this is an element\n from an array being printed\n on one line [default is False] Calls proc~~json_value_print~~CallsGraph proc~json_value_print json_value_print proc~escape_string escape_string proc~json_value_print->proc~escape_string proc~real_to_string real_to_string proc~json_value_print->proc~real_to_string proc~integer_to_string integer_to_string proc~json_value_print->proc~integer_to_string proc~valid_json_hex valid_json_hex proc~escape_string->proc~valid_json_hex proc~compact_real_string compact_real_string proc~real_to_string->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code json_value_print Source Code recursive subroutine json_value_print ( json , p , iunit , str , indent ,& need_comma , colon , is_array_element ,& is_compressed_vector ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. logical ( LK ), intent ( in ), optional :: is_compressed_vector !! if True, this is an element !! from an array being printed !! on one line [default is False] character ( kind = CK , len = max_numeric_str_len ) :: tmp !! for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array integer ( IK ) :: var_type , var_type_prev logical ( LK ) :: is_vector !! if all elements of a vector !! are scalars of the same type character ( kind = CK , len = :), allocatable :: str_escaped !! escaped version of !! `name` or `str_value` if (. not . json % exception_thrown ) then if ( present ( is_compressed_vector )) then is_vector = is_compressed_vector else is_vector = . false . end if !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent ) . and . . not . json % no_whitespace ) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * json % spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = CK_ '' else s = repeat ( space , spaces ) end if select case ( p % var_type ) case ( json_object ) count = json % count ( p ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then if ( . not . json % no_whitespace ) tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! print the name if ( allocated ( element % name )) then call escape_string ( element % name , str_escaped , json % escape_solidus ) if ( json % no_whitespace ) then !compact printing - no extra space call write_it ( repeat ( space , spaces ) // quotation_mark // & str_escaped // quotation_mark // colon_char ,& advance = . false .) else call write_it ( repeat ( space , spaces ) // quotation_mark // & str_escaped // quotation_mark // colon_char // space ,& advance = . false .) end if else call json % throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json % count ( p ) if ( json % compress_vectors ) then ! check to see if every child is the same type, ! and a scalar: is_vector = . true . var_type_prev = - 1 ! an invalid value nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! check variable type of all the children. ! They must all be the same, and a scalar. call json % info ( element , var_type = var_type ) if ( var_type == json_object . or . & var_type == json_array . or . & ( i > 1 . and . var_type /= var_type_prev )) then is_vector = . false . exit end if var_type_prev = var_type ! get the next child the list: element => element % next end do else is_vector = . false . end if if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( s // start_array , advance = (. not . is_vector ) ) !if an array is in an array, there is an extra tab: if ( is_array ) then if ( . not . json % no_whitespace ) tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! recursive print of the element if ( is_vector ) then call json % json_value_print ( element , iunit = iunit , indent = 0 ,& need_comma = i < count , is_array_element = . false ., str = str ,& is_compressed_vector = . true .) else call json % json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) end if ! get the next child the list: element => element % next end do !indent the closing array character: if ( is_vector ) then call write_it ( end_array , comma = print_comma ) else call write_it ( repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) // end_array ,& comma = print_comma ) end if nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) case ( json_string ) if ( allocated ( p % str_value )) then ! have to escape the string for printing: call escape_string ( p % str_value , str_escaped , json % escape_solidus ) call write_it ( s // quotation_mark // & str_escaped // quotation_mark , & comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) else call json % throw_exception ( 'Error in json_value_print:' // & ' p%value_string not allocated' ) return end if case ( json_logical ) if ( p % log_value ) then call write_it ( s // true_str , comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) else call write_it ( s // false_str , comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) end if case ( json_integer ) call integer_to_string ( p % int_value , int_fmt , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) case ( json_double ) if ( allocated ( json % real_fmt )) then call real_to_string ( p % dbl_value , json % real_fmt , json % compact_real , tmp ) else !use the default format (user has not called initialize() or specified one): call real_to_string ( p % dbl_value , default_real_fmt , json % compact_real , tmp ) end if call write_it ( s // trim ( tmp ), comma = print_comma , & advance = (. not . is_vector ),& space_after_comma = is_vector ) case default call json % throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains subroutine write_it ( s , advance , comma , space_after_comma ) !! write the string to the file (or the output string) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !! string to print logical ( LK ), intent ( in ), optional :: advance !! to add line break or not logical ( LK ), intent ( in ), optional :: comma !! print comma after the string logical ( LK ), intent ( in ), optional :: space_after_comma !! print a space after the comma logical ( LK ) :: add_comma !! if a delimiter is to be added after string logical ( LK ) :: add_line_break !! if a line break is to be added after string logical ( LK ) :: add_space !! if a space is to be added after the comma character ( kind = CK , len = :), allocatable :: s2 !! temporary string if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( json % no_whitespace ) then add_space = . false . else if ( present ( space_after_comma )) then add_space = space_after_comma else add_space = . false . !default is not to add space end if end if if ( present ( advance )) then if ( json % no_whitespace ) then ! overrides input value: add_line_break = . false . else add_line_break = advance end if else add_line_break = . not . json % no_whitespace ! default is to advance if ! we are printing whitespace end if !string to print: s2 = s if ( add_comma ) then s2 = s2 // delimiter if ( add_space ) s2 = s2 // space end if if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print","title":"json_value_print – JSON-Fortran","tags":"","loc":"proc/json_value_print.html"},{"text":"private subroutine json_value_remove(json, p, destroy) Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. Examples To extract an object from one JSON structure, and add it to another: type ( json_core ) :: json type ( json_value ), pointer :: json1 , json2 , p logical :: found !create and populate json1 and json2 call json % get ( json1 , 'name' , p , found ) ! get pointer to name element of json1 call json % remove ( p , destroy = . false .) ! remove it from json1 (don't destroy) call json % add ( json2 , p ) ! add it to json2 To remove an object from a JSON structure (and destroy it): type ( json_core ) :: json type ( json_value ), pointer :: json1 , p logical :: found !create and populate json1 call json % get ( json1 , 'name' , p , found ) ! get pointer to name element of json1 call json % remove ( p ) ! remove and destroy it History Jacob Williams : 12/28/2014 : added destroy optional argument. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Source Code json_value_remove Source Code subroutine json_value_remove ( json , p , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( p )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( p % parent )) then parent => p % parent if ( associated ( p % next )) then !there are later items in the list: next => p % next nullify ( p % next ) if ( associated ( p % previous )) then !there are earlier items in the list previous => p % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( p % previous )) then !there are earlier items in the list: previous => p % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json % destroy ( p ) end if end subroutine json_value_remove","title":"json_value_remove – JSON-Fortran","tags":"","loc":"proc/json_value_remove.html"},{"text":"private subroutine json_value_remove_if_present(json, p, name) Given the path string, remove the variable from\n  the json_value structure, if it exists. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name Source Code json_value_remove_if_present Source Code subroutine json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json % get ( p , name , p_var , found ) if ( found ) call json % remove ( p_var ) end subroutine json_value_remove_if_present","title":"json_value_remove_if_present – JSON-Fortran","tags":"","loc":"proc/json_value_remove_if_present.html"},{"text":"private subroutine json_value_rename(json, p, name) Rename a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name Source Code json_value_rename Source Code subroutine json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! new variable name if ( json % trailing_spaces_significant ) then p % name = name else p % name = trim ( name ) end if end subroutine json_value_rename","title":"json_value_rename – JSON-Fortran","tags":"","loc":"proc/json_value_rename.html"},{"text":"private subroutine json_value_replace(json, p1, p2, destroy) Replace p1 with p2 in a JSON structure. Note The replacement is done using an insert and remove\n      See json_value_insert_after and json_value_remove for details. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 the item to replace type( json_value ), pointer :: p2 item to take the place of p1 logical(kind=LK), intent(in), optional :: destroy Should p1 also be destroyed\n (default is True). Normally,\n this should be true to avoid\n a memory leak. Source Code json_value_replace Source Code subroutine json_value_replace ( json , p1 , p2 , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 !! the item to replace type ( json_value ), pointer :: p2 !! item to take the place of `p1` logical ( LK ), intent ( in ), optional :: destroy !! Should `p1` also be destroyed !! (default is True). Normally, !! this should be true to avoid !! a memory leak. logical ( LK ) :: destroy_p1 !! if `p1` is to be destroyed if ( present ( destroy )) then destroy_p1 = destroy else destroy_p1 = . true . ! default end if call json % insert_after ( p1 , p2 ) call json % remove ( p1 , destroy_p1 ) end subroutine json_value_replace","title":"json_value_replace – JSON-Fortran","tags":"","loc":"proc/json_value_replace.html"},{"text":"private subroutine json_value_reverse(json, p) Reverse the order of the children of an array or object. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p Source Code json_value_reverse Source Code subroutine json_value_reverse ( json , p ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: tmp !! temp variable for traversing the list type ( json_value ), pointer :: current !! temp variable for traversing the list integer ( IK ) :: var_type !! for getting the variable type if ( associated ( p )) then call json % info ( p , var_type = var_type ) ! can only reverse objects or arrays if ( var_type == json_object . or . var_type == json_array ) then nullify ( tmp ) current => p % children p % tail => current ! Swap next and previous for all nodes: do if (. not . associated ( current )) exit tmp => current % previous current % previous => current % next current % next => tmp current => current % previous end do if ( associated ( tmp )) then p % children => tmp % previous end if end if end if end subroutine json_value_reverse","title":"json_value_reverse – JSON-Fortran","tags":"","loc":"proc/json_value_reverse.html"},{"text":"private subroutine json_value_swap(json, p1, p2) Swap two elements in a JSON structure.\n  All of the children are carried along as well. Note If both are not associated, then an error is thrown. Note The assumption here is that both variables are part of a valid json_value linked list (so the normal parent , previous , next , etc. pointers are properly associated if necessary). Warning This cannot be used to swap a parent/child pair, since that\n         could lead to a circular linkage. An exception is thrown if\n         this is tried. Warning There are also other situations where using this routine may\n         produce a malformed JSON structure, such as moving an array\n         element outside of an array. This is not checked for. Note If p1 and p2 have a common parent, it is always safe to swap them. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 type( json_value ), pointer :: p2 Source Code json_value_swap Source Code subroutine json_value_swap ( json , p1 , p2 ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical :: same_parent , first_last , adjacent type ( json_value ), pointer :: a , b if ( json % exception_thrown ) return !both have to be associated: if ( associated ( p1 ) . and . associated ( p2 )) then !simple check to make sure that they both !aren't pointing to the same thing: if (. not . associated ( p1 , p2 )) then !we will not allow swapping an item with one of its descendants: if ( json % is_child_of ( p1 , p2 ) . or . json % is_child_of ( p2 , p1 )) then call json % throw_exception ( 'Error in json_value_swap: ' // & 'cannot swap an item with one of its descendants' ) else same_parent = ( associated ( p1 % parent ) . and . & associated ( p2 % parent ) . and . & associated ( p1 % parent , p2 % parent ) ) if ( same_parent ) then !if p1,p2 are the first,last or last,first !children of a common parent first_last = ( associated ( p1 % parent % children , p1 ) . and . & associated ( p2 % parent % tail , p2 )) . or . & ( associated ( p1 % parent % tail , p1 ) . and . & associated ( p2 % parent % children , p2 )) else first_last = . false . end if !first, we fix children,tail pointers: if ( same_parent . and . first_last ) then !this is all we have to do for the parent in this case: call swap_pointers ( p1 % parent % children , p2 % parent % tail ) else if ( same_parent . and . . not . first_last ) then if ( associated ( p1 % parent % children , p1 )) then p1 % parent % children => p2 ! p1 is the first child of the parent else if ( associated ( p1 % parent % children , p2 )) then p1 % parent % children => p1 ! p2 is the first child of the parent end if if ( associated ( p1 % parent % tail , p1 )) then p1 % parent % tail => p2 ! p1 is the last child of the parent else if ( associated ( p1 % parent % tail , p2 )) then p1 % parent % tail => p1 ! p2 is the last child of the parent end if else ! general case: different parents if ( associated ( p1 % parent )) then if ( associated ( p1 % parent % children , p1 )) p1 % parent % children => p2 if ( associated ( p1 % parent % tail , p1 )) p1 % parent % tail => p2 end if if ( associated ( p2 % parent )) then if ( associated ( p2 % parent % children , p2 )) p2 % parent % children => p1 if ( associated ( p2 % parent % tail , p2 )) p2 % parent % tail => p1 end if call swap_pointers ( p1 % parent , p2 % parent ) end if !now, have to fix previous,next pointers: !first, see if they are adjacent: adjacent = associated ( p1 % next , p2 ) . or . & associated ( p2 % next , p1 ) if ( associated ( p2 % next , p1 )) then !p2,p1 a => p2 b => p1 else !p1,p2 (or not adjacent) a => p1 b => p2 end if if ( associated ( a % previous )) a % previous % next => b if ( associated ( b % next )) b % next % previous => a if ( adjacent ) then !a comes before b in the original list b % previous => a % previous a % next => b % next a % previous => b b % next => a else if ( associated ( a % next )) a % next % previous => b if ( associated ( b % previous )) b % previous % next => a call swap_pointers ( a % previous , b % previous ) call swap_pointers ( a % next , b % next ) end if end if else call json % throw_exception ( 'Error in json_value_swap: ' // & 'both pointers must be associated' ) end if end if contains pure subroutine swap_pointers ( s1 , s2 ) implicit none type ( json_value ), pointer , intent ( inout ) :: s1 type ( json_value ), pointer , intent ( inout ) :: s2 type ( json_value ), pointer :: tmp !! temporary pointer if (. not . associated ( s1 , s2 )) then tmp => s1 s1 => s2 s2 => tmp end if end subroutine swap_pointers end subroutine json_value_swap","title":"json_value_swap – JSON-Fortran","tags":"","loc":"proc/json_value_swap.html"},{"text":"private subroutine json_value_to_string(json, p, str) Print the json_value structure to an allocatable string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Source Code json_value_to_string Source Code subroutine json_value_to_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = CK_ '' call json % json_value_print ( p , iunit = unit2str , str = str , indent = 1_IK , colon = . true .) end subroutine json_value_to_string","title":"json_value_to_string – JSON-Fortran","tags":"","loc":"proc/json_value_to_string.html"},{"text":"private subroutine json_value_validate(json, p, is_valid, error_msg) Validate a json_value linked list by checking to make sure\n  all the pointers are properly associated, arrays and objects\n  have the correct number of children, and the correct data is\n  allocated for the variable types. It recursively traverses the entire structure and checks every element. History Jacob Williams, 8/26/2017 : added duplicate key check. Note It will return on the first error it encounters. Note This routine does not check or throw any exceptions.\n      If json is currently in a state of exception, it will\n      remain so after calling this routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), intent(out), allocatable :: error_msg if not valid, this will contain\n a description of the problem Source Code json_value_validate Source Code subroutine json_value_validate ( json , p , is_valid , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: is_valid !! True if the structure is valid. character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! if not valid, this will contain !! a description of the problem logical ( LK ) :: has_duplicate !! to check for duplicate keys character ( kind = CK , len = :), allocatable :: path !! path to duplicate key logical ( LK ) :: status_ok !! to check for existing exception character ( kind = CK , len = :), allocatable :: exception_msg !! error message for an existing exception character ( kind = CK , len = :), allocatable :: exception_msg2 !! error message for a new exception if ( associated ( p )) then is_valid = . true . call check_if_valid ( p , require_parent = associated ( p % parent )) if ( is_valid . and . . not . json % allow_duplicate_keys ) then ! if no errors so far, also check the ! entire structure for duplicate keys: ! note: check_for_duplicate_keys does call routines ! that check and throw exceptions, so let's clear any ! first. (save message for later) call json % check_for_errors ( status_ok , exception_msg ) call json % clear_exceptions () call json % check_for_duplicate_keys ( p , has_duplicate , path = path ) if ( json % failed ()) then ! if an exception was thrown during this call, ! then clear it but make that the error message ! returned by this routine. Normally this should ! never actually occur since we have already ! validated the structure. call json % check_for_errors ( is_valid , exception_msg2 ) error_msg = exception_msg2 call json % clear_exceptions () is_valid = . false . else if ( has_duplicate ) then error_msg = 'duplicate key found: ' // path is_valid = . false . end if end if if (. not . status_ok ) then ! restore any existing exception if necessary call json % throw_exception ( exception_msg ) end if ! cleanup: if ( allocated ( path )) deallocate ( path ) if ( allocated ( exception_msg )) deallocate ( exception_msg ) if ( allocated ( exception_msg2 )) deallocate ( exception_msg2 ) end if else error_msg = 'The pointer is not associated' is_valid = . false . end if contains recursive subroutine check_if_valid ( p , require_parent ) implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( in ) :: require_parent !! the first one may be a root (so no parent), !! but all descendants must have a parent. integer :: i !! counter type ( json_value ), pointer :: element type ( json_value ), pointer :: previous if ( is_valid . and . associated ( p )) then ! data type: select case ( p % var_type ) case ( json_null , json_object , json_array ) if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for ' // & 'json_null, json_object, or json_array variable type' is_valid = . false . return end if case ( json_logical ) if (. not . allocated ( p % log_value )) then error_msg = 'log_value should be allocated for json_logical variable type' is_valid = . false . return else if ( allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_logical variable type' is_valid = . false . return end if case ( json_integer ) if (. not . allocated ( p % int_value )) then error_msg = 'int_value should be allocated for json_integer variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_integer variable type' is_valid = . false . return end if case ( json_double ) if (. not . allocated ( p % dbl_value )) then error_msg = 'dbl_value should be allocated for json_double variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_double variable type' is_valid = . false . return end if case ( json_string ) if (. not . allocated ( p % str_value )) then error_msg = 'str_value should be allocated for json_string variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value )) then error_msg = 'incorrect data allocated for json_string variable type' is_valid = . false . return end if case default error_msg = 'invalid JSON variable type' is_valid = . false . return end select if ( require_parent . and . . not . associated ( p % parent )) then error_msg = 'parent pointer is not associated' is_valid = . false . return end if if (. not . allocated ( p % name )) then if ( associated ( p % parent )) then if ( p % parent % var_type /= json_array ) then error_msg = 'JSON variable must have a name if not an ' // & 'array element or the root' is_valid = . false . return end if end if end if if ( associated ( p % children ) . neqv . associated ( p % tail )) then error_msg = 'both children and tail pointers must be associated' is_valid = . false . return end if ! now, check next one: if ( associated ( p % next )) then call check_if_valid ( p % next , require_parent = require_parent ) end if if ( associated ( p % children )) then if ( p % var_type /= json_array . and . p % var_type /= json_object ) then error_msg = 'only arrays and objects can have children' is_valid = . false . return end if ! first validate children pointers: previous => null () element => p % children do i = 1 , p % n_children if (. not . associated ( element % parent , p )) then error_msg = 'child''s parent pointer not properly associated' is_valid = . false . return end if if ( i == 1 . and . associated ( element % previous )) then error_msg = 'first child shouldn''t have a previous' is_valid = . false . return end if if ( i < p % n_children . and . . not . associated ( element % next )) then error_msg = 'not enough children' is_valid = . false . return end if if ( i == p % n_children . and . associated ( element % next )) then error_msg = 'too many children' is_valid = . false . return end if if ( i > 1 ) then if (. not . associated ( previous , element % previous )) then error_msg = 'previous pointer not properly associated' is_valid = . false . return end if end if if ( i == p % n_children . and . & . not . associated ( element % parent % tail , element )) then error_msg = 'parent''s tail pointer not properly associated' is_valid = . false . return end if if ( i < p % n_children ) then !setup next case: previous => element element => element % next end if end do !now check all the children: call check_if_valid ( p % children , require_parent = . true .) end if end if end subroutine check_if_valid end subroutine json_value_validate","title":"json_value_validate – JSON-Fortran","tags":"","loc":"proc/json_value_validate.html"},{"text":"private recursive subroutine parse_array(json, unit, str, array) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: array Calls proc~~parse_array~~CallsGraph proc~parse_array parse_array proc~json_value_create json_value_create proc~parse_array->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code parse_array Source Code recursive subroutine parse_array ( json , unit , str , array ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( json % exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call json % parse_value ( unit , str , element ) if ( json % exception_thrown ) then if ( associated ( element )) call json % destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json % add ( array , element ) ! popped the next character call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then ! The file ended before array was finished: call json % throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call json % throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array","title":"parse_array – JSON-Fortran","tags":"","loc":"proc/parse_array.html"},{"text":"private subroutine parse_for_chars(json, unit, str, chars) Core parsing routine. This is used to verify the strings true , false , and null during parsing. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. Source Code parse_for_chars Source Code subroutine parse_for_chars ( json , unit , str , chars ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . json % exception_thrown ) then length = len_trim ( chars ) do i = 1 , length call json % pop_char ( unit , str = str , eof = eof , skip_ws = . false ., popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing.' ) return else if ( c /= chars ( i : i )) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character: \"' // c // '\" (expecting \"' // & chars ( i : i ) // '\")' ) return end if end do end if end subroutine parse_for_chars","title":"parse_for_chars – JSON-Fortran","tags":"","loc":"proc/parse_for_chars.html"},{"text":"private subroutine parse_number(json, unit, str, value) Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. Note Complete rewrite of the original FSON routine, which had some problems. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: value Source Code parse_number Source Code subroutine parse_number ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer integer ( IK ) :: ip !! index to put next character !! [to speed up by reducing the number !! of character string reallocations] if (. not . json % exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call json % push_char ( c ) !string to value: if ( is_integer ) then ival = json % string_to_int ( tmp ) call json % to_integer ( value , ival ) else rval = json % string_to_dble ( tmp ) call json % to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number","title":"parse_number – JSON-Fortran","tags":"","loc":"proc/parse_number.html"},{"text":"private recursive subroutine parse_object(json, unit, str, parent) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: parent the parsed object will be added as a child of this Calls proc~~parse_object~~CallsGraph proc~parse_object parse_object proc~json_value_create json_value_create proc~parse_object->proc~json_value_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code parse_object Source Code recursive subroutine parse_object ( json , unit , str , parent ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call json % throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) #else call json % parse_string ( unit , str , pair % name ) #endif if ( json % exception_thrown ) then call json % destroy ( pair ) return end if else call json % throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call json % parse_value ( unit , str , pair ) if ( json % exception_thrown ) then call json % destroy ( pair ) return else call json % add ( parent , pair ) end if else call json % throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call json % parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call json % throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object","title":"parse_object – JSON-Fortran","tags":"","loc":"proc/parse_object.html"},{"text":"private subroutine parse_string(json, unit, str, string) Parses a string while reading a JSON file. History Jacob Williams : 6/16/2014 : Added hex validation. Jacob Williams : 12/3/2015 : Fixed some bugs. Jacob Williams : 8/23/2015 : string is now returned unescaped. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string the string (unescaped if necessary) Calls proc~~parse_string~~CallsGraph proc~parse_string parse_string proc~valid_json_hex valid_json_hex proc~parse_string->proc~valid_json_hex proc~unescape_string unescape_string proc~parse_string->proc~unescape_string interface~to_unicode to_unicode proc~unescape_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code parse_string Source Code subroutine parse_string ( json , unit , str , string ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string !! the string (unescaped if necessary) logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. character ( kind = CK , len = :), allocatable :: string_unescaped !! temp variable character ( kind = CK , len = :), allocatable :: error_message !! for string unescaping !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . json % exception_thrown ) then !initialize: ip = 1 is_hex = . false . escape = . false . i = 0 do !get the next character from the file: call json % pop_char ( unit , str = str , eof = eof , skip_ws = . false ., popped = c ) if ( eof ) then call json % throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . . not . escape ) then !end of string if ( is_hex ) call json % throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = CK_ '' is_hex = . false . else call json % throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = CK_ '' else string = string ( 1 : ip - 1 ) end if end if !string is returned unescaped: call unescape_string ( string , string_unescaped , error_message ) if ( allocated ( error_message )) then call json % throw_exception ( error_message ) else string = string_unescaped end if !cleanup: if ( allocated ( error_message )) deallocate ( error_message ) if ( allocated ( string_unescaped )) deallocate ( string_unescaped ) end if end subroutine parse_string","title":"parse_string – JSON-Fortran","tags":"","loc":"proc/parse_string.html"},{"text":"private recursive subroutine parse_value(json, unit, str, value) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), pointer :: value JSON data that is extracted Source Code parse_value Source Code recursive subroutine parse_value ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof !! end-of-file flag character ( kind = CK , len = 1 ) :: c !! character read from file (or string) #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call json % throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file call json % pop_char ( unit , str = str , eof = eof , skip_ws = . true ., & skip_comments = json % allow_comments , popped = c ) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call json % to_object ( value ) !allocate class call json % parse_object ( unit , str , value ) case ( start_array ) ! start array call json % to_array ( value ) !allocate class call json % parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call json % push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call json % to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) #if defined __GFORTRAN__ ! write to a tmp variable because of ! a bug in 4.9 gfortran compiler. call json % parse_string ( unit , str , tmp ) value % str_value = tmp if ( allocated ( tmp )) deallocate ( tmp ) #else call json % parse_string ( unit , str , value % str_value ) #endif end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call json % parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call json % to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call json % parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call json % to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call json % parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . json % exception_thrown ) call json % to_null ( value ) ! allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call json % push_char ( c ) call json % parse_number ( unit , str , value ) case default call json % throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value","title":"parse_value – JSON-Fortran","tags":"","loc":"proc/parse_value.html"},{"text":"private recursive subroutine pop_char(json, unit, str, skip_ws, skip_comments, eof, popped) Get the next character from the file (or string). See also push_char Note This routine ignores non-printing ASCII characters\n      (iachar<=31) that are in strings. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing\n from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a\n string) – only used if unit=0 logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace [default False] logical(kind=LK), intent(in), optional :: skip_comments to ignore comment lines [default False] logical(kind=LK), intent(out) :: eof true if the end of the file has\n been reached. character(kind=CK,len=1), intent(out) :: popped the popped character returned Source Code pop_char Source Code recursive subroutine pop_char ( json , unit , str , skip_ws , skip_comments , eof , popped ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing !! from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a !! string) -- only used if unit=0 logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace [default False] logical ( LK ), intent ( in ), optional :: skip_comments !! to ignore comment lines [default False] logical ( LK ), intent ( out ) :: eof !! true if the end of the file has !! been reached. character ( kind = CK , len = 1 ), intent ( out ) :: popped !! the popped character returned integer ( IK ) :: ios !! `iostat` flag integer ( IK ) :: str_len !! length of `str` character ( kind = CK , len = 1 ) :: c !! a character read from the file (or string) logical ( LK ) :: ignore !! if whitespace is to be ignored logical ( LK ) :: ignore_comments !! if comment lines are to be ignored logical ( LK ) :: parsing_comment !! if we are in the process !! of parsing a comment line if (. not . json % exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if parsing_comment = . false . if (. not . present ( skip_comments )) then ignore_comments = . false . else ignore_comments = skip_comments end if do if ( json % pushed_index > 0 ) then ! there is a character pushed back on, most likely ! from the number parsing. Note: this can only occur if ! reading from a file when use_unformatted_stream=.false. c = json % pushed_char ( json % pushed_index : json % pushed_index ) json % pushed_index = json % pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = json % ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if json % ipos = json % ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( json % ipos <= str_len ) then c = str ( json % ipos : json % ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if json % ipos = json % ipos + 1 end if json % char_count = json % char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file ! no character to return json % char_count = 0 eof = . true . popped = space ! just to set a value exit else if ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record json % char_count = 0 json % line_count = json % line_count + 1 if ( ignore_comments ) parsing_comment = . false . ! done parsing this comment line cycle end if end if if ( ignore_comments . and . ( parsing_comment . or . c == json % comment_char ) ) then ! skipping the comment parsing_comment = . true . cycle else if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then ! ignoring whitespace cycle else ! return the character popped = c exit end if end do end if end subroutine pop_char","title":"pop_char – JSON-Fortran","tags":"","loc":"proc/pop_char.html"},{"text":"private subroutine push_char(json, c) Core routine. See also pop_char History Jacob Williams : 5/3/2015 : replaced original version of this routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=1), intent(in) :: c to character to push Calls proc~~push_char~~CallsGraph proc~push_char push_char proc~integer_to_string integer_to_string proc~push_char->proc~integer_to_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code push_char Source Code subroutine push_char ( json , c ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ), intent ( in ) :: c !! to character to push character ( kind = CK , len = max_numeric_str_len ) :: istr !! for error printing if (. not . json % exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: json % ipos = json % ipos - 1 else json % pushed_index = json % pushed_index + 1 if ( json % pushed_index > 0 . and . json % pushed_index <= len ( json % pushed_char )) then json % pushed_char ( json % pushed_index : json % pushed_index ) = c else call integer_to_string ( json % pushed_index , int_fmt , istr ) call json % throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if !character count in the current line json % char_count = json % char_count - 1 end if end subroutine push_char","title":"push_char – JSON-Fortran","tags":"","loc":"proc/push_char.html"},{"text":"private subroutine to_array(json, p, name) Change the json_value variable to an array. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Calls proc~~to_array~~CallsGraph proc~to_array to_array proc~destroy_json_data destroy_json_data proc~to_array->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_array Source Code subroutine to_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_array !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_array","title":"to_array – JSON-Fortran","tags":"","loc":"proc/to_array.html"},{"text":"private subroutine to_double(json, p, val, name) Change the json_value variable to a double. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in), optional :: val if the value is also to be set\n (if not present, then 0.0_rk is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Calls proc~~to_double~~CallsGraph proc~to_double to_double proc~destroy_json_data destroy_json_data proc~to_double->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_double Source Code subroutine to_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p real ( RK ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_double allocate ( p % dbl_value ) if ( present ( val )) then p % dbl_value = val else p % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_double","title":"to_double – JSON-Fortran","tags":"","loc":"proc/to_double.html"},{"text":"private subroutine to_integer(json, p, val, name) Change the json_value variable to an integer. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in), optional :: val if the value is also to be set\n (if not present, then 0 is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Calls proc~~to_integer~~CallsGraph proc~to_integer to_integer proc~destroy_json_data destroy_json_data proc~to_integer->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_integer Source Code subroutine to_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_integer allocate ( p % int_value ) if ( present ( val )) then p % int_value = val else p % int_value = 0 !default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_integer","title":"to_integer – JSON-Fortran","tags":"","loc":"proc/to_integer.html"},{"text":"private subroutine to_logical(json, p, val, name) Change the json_value variable to a logical. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in), optional :: val if the value is also to be set\n (if not present, then .false. is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Calls proc~~to_logical~~CallsGraph proc~to_logical to_logical proc~destroy_json_data destroy_json_data proc~to_logical->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_logical Source Code subroutine to_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_logical allocate ( p % log_value ) if ( present ( val )) then p % log_value = val else p % log_value = . false . !default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_logical","title":"to_logical – JSON-Fortran","tags":"","loc":"proc/to_logical.html"},{"text":"private subroutine to_null(json, p, name) Change the json_value variable to a null. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Calls proc~~to_null~~CallsGraph proc~to_null to_null proc~destroy_json_data destroy_json_data proc~to_null->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_null Source Code subroutine to_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_null !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_null","title":"to_null – JSON-Fortran","tags":"","loc":"proc/to_null.html"},{"text":"private subroutine to_object(json, p, name) Change the json_value variable to an object. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Calls proc~~to_object~~CallsGraph proc~to_object to_object proc~destroy_json_data destroy_json_data proc~to_object->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_object Source Code subroutine to_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_object !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_object","title":"to_object – JSON-Fortran","tags":"","loc":"proc/to_object.html"},{"text":"private subroutine to_string(json, p, val, name, trim_str, adjustl_str) Change the json_value variable to a string. Modified Izaak Beekman : 02/24/2015 Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: val if the value is also to be set\n (if not present, then '' is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) Calls proc~~to_string~~CallsGraph proc~to_string to_string proc~destroy_json_data destroy_json_data proc~to_string->proc~destroy_json_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code to_string Source Code subroutine to_string ( json , p , val , name , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set !! (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) character ( kind = CK , len = :), allocatable :: str !! temp string for `trim()` and/or `adjustl()` logical :: trim_string !! if the string is to be trimmed logical :: adjustl_string !! if the string is to be adjusted left !set type and value: call destroy_json_data ( p ) p % var_type = json_string if ( present ( val )) then if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if if ( trim_string . or . adjustl_string ) then str = val if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) p % str_value = str else p % str_value = val end if else p % str_value = CK_ '' ! default value end if !name: if ( present ( name )) call json % rename ( p , name ) end subroutine to_string","title":"to_string – JSON-Fortran","tags":"","loc":"proc/to_string.html"},{"text":"private subroutine wrap_json_add_double_by_path(json, me, path, value, found, was_created) Wrapper to json_add_double_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_double_by_path~~CallsGraph proc~wrap_json_add_double_by_path wrap_json_add_double_by_path interface~to_unicode to_unicode proc~wrap_json_add_double_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_double_by_path Source Code subroutine wrap_json_add_double_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_double_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_double_by_path","title":"wrap_json_add_double_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_double_by_path.html"},{"text":"private subroutine wrap_json_add_double_vec_by_path(json, me, path, value, found, was_created) Wrapper for json_add_double_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_double_vec_by_path~~CallsGraph proc~wrap_json_add_double_vec_by_path wrap_json_add_double_vec_by_path interface~to_unicode to_unicode proc~wrap_json_add_double_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_double_vec_by_path Source Code subroutine wrap_json_add_double_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable real ( RK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_double_vec_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_double_vec_by_path","title":"wrap_json_add_double_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_double_vec_by_path.html"},{"text":"private subroutine wrap_json_add_integer_by_path(json, me, path, value, found, was_created) Wrapper to json_add_integer_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_integer_by_path~~CallsGraph proc~wrap_json_add_integer_by_path wrap_json_add_integer_by_path interface~to_unicode to_unicode proc~wrap_json_add_integer_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_integer_by_path Source Code subroutine wrap_json_add_integer_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_integer_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_integer_by_path","title":"wrap_json_add_integer_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_integer_by_path.html"},{"text":"private subroutine wrap_json_add_integer_vec_by_path(json, me, path, value, found, was_created) Wrapper for json_add_integer_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_integer_vec_by_path~~CallsGraph proc~wrap_json_add_integer_vec_by_path wrap_json_add_integer_vec_by_path interface~to_unicode to_unicode proc~wrap_json_add_integer_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_integer_vec_by_path Source Code subroutine wrap_json_add_integer_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_integer_vec_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_integer_vec_by_path","title":"wrap_json_add_integer_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_integer_vec_by_path.html"},{"text":"private subroutine wrap_json_add_logical_by_path(json, me, path, value, found, was_created) Wrapper to json_add_logical_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_logical_by_path~~CallsGraph proc~wrap_json_add_logical_by_path wrap_json_add_logical_by_path interface~to_unicode to_unicode proc~wrap_json_add_logical_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_logical_by_path Source Code subroutine wrap_json_add_logical_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_logical_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_logical_by_path","title":"wrap_json_add_logical_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_logical_by_path.html"},{"text":"private subroutine wrap_json_add_logical_vec_by_path(json, me, path, value, found, was_created) Wrapper for json_add_logical_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_logical_vec_by_path~~CallsGraph proc~wrap_json_add_logical_vec_by_path wrap_json_add_logical_vec_by_path interface~to_unicode to_unicode proc~wrap_json_add_logical_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_logical_vec_by_path Source Code subroutine wrap_json_add_logical_vec_by_path ( json , me , path , value , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable logical ( LK ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_logical_vec_by_path ( me , to_unicode ( path ), value , found , was_created ) end subroutine wrap_json_add_logical_vec_by_path","title":"wrap_json_add_logical_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_logical_vec_by_path.html"},{"text":"private subroutine wrap_json_add_member_by_path(json, me, path, p, found, was_created) Wrapper to json_add_member_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created Calls proc~~wrap_json_add_member_by_path~~CallsGraph proc~wrap_json_add_member_by_path wrap_json_add_member_by_path interface~to_unicode to_unicode proc~wrap_json_add_member_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_member_by_path Source Code subroutine wrap_json_add_member_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( in ) :: p !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created call json % json_add_member_by_path ( me , to_unicode ( path ), p , found , was_created ) end subroutine wrap_json_add_member_by_path","title":"wrap_json_add_member_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_member_by_path.html"},{"text":"private subroutine wrap_json_add_string_by_path(json, me, path, value, found, was_created, trim_str, adjustl_str) Wrapper to json_add_string_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Calls proc~~wrap_json_add_string_by_path~~CallsGraph proc~wrap_json_add_string_by_path wrap_json_add_string_by_path interface~to_unicode to_unicode proc~wrap_json_add_string_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_string_by_path Source Code subroutine wrap_json_add_string_by_path ( json , me , path , value , found ,& was_created , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), intent ( in ) :: value !! the value to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_by_path ( me , to_unicode ( path ), to_unicode ( value ),& found , was_created , trim_str , adjustl_str ) end subroutine wrap_json_add_string_by_path","title":"wrap_json_add_string_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_string_by_path.html"},{"text":"private subroutine wrap_json_add_string_vec_by_path(json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper for json_add_string_vec_by_path where \"path\" and \"value\" are kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Calls proc~~wrap_json_add_string_vec_by_path~~CallsGraph proc~wrap_json_add_string_vec_by_path wrap_json_add_string_vec_by_path interface~to_unicode to_unicode proc~wrap_json_add_string_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_add_string_vec_by_path Source Code subroutine wrap_json_add_string_vec_by_path ( json , me , path , value ,& found , was_created , ilen ,& trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me !! the JSON structure character ( kind = CDK , len =* ), intent ( in ) :: path !! the path to the variable character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: value !! the vector to add logical ( LK ), intent ( out ), optional :: found !! if the variable was found logical ( LK ), intent ( out ), optional :: was_created !! if the variable had to be created integer ( IK ), dimension (:), intent ( in ), optional :: ilen !! the string lengths of each !! element in `value`. If not present, !! the full `len(value)` string is added !! for each element. logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element call json % json_add_string_vec_by_path ( me , to_unicode ( path ), to_unicode ( value ),& found , was_created , ilen , trim_str , adjustl_str ) end subroutine wrap_json_add_string_vec_by_path","title":"wrap_json_add_string_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_add_string_vec_by_path.html"},{"text":"private subroutine wrap_json_create_by_path(json, me, path, p, found, was_created) Alternate version of json_create_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), optional pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if there were no errors\n (variable found or created) logical(kind=LK), intent(out), optional :: was_created true if it was actually created\n (as opposed to already being there) Calls proc~~wrap_json_create_by_path~~CallsGraph proc~wrap_json_create_by_path wrap_json_create_by_path interface~to_unicode to_unicode proc~wrap_json_create_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_create_by_path Source Code subroutine wrap_json_create_by_path ( json , me , path , p , found , was_created ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ), optional :: p !! pointer to the variable !! specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if there were no errors !! (variable found or created) logical ( LK ), intent ( out ), optional :: was_created !! true if it was actually created !! (as opposed to already being there) call json % create ( me , to_unicode ( path ), p , found , was_created ) end subroutine wrap_json_create_by_path","title":"wrap_json_create_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_create_by_path.html"},{"text":"private subroutine wrap_json_get_alloc_string_vec_by_path(json, me, path, vec, ilen, found) Alternate version of json_get_alloc_string_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_alloc_string_vec_by_path~~CallsGraph proc~wrap_json_get_alloc_string_vec_by_path wrap_json_get_alloc_string_vec_by_path interface~to_unicode to_unicode proc~wrap_json_get_alloc_string_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_alloc_string_vec_by_path Source Code subroutine wrap_json_get_alloc_string_vec_by_path ( json , me , path , vec , ilen , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), dimension (:), allocatable , intent ( out ) :: vec integer ( IK ), dimension (:), allocatable , intent ( out ) :: ilen !! the actual length !! of each character !! string in the array logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , ilen , found ) end subroutine wrap_json_get_alloc_string_vec_by_path","title":"wrap_json_get_alloc_string_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_alloc_string_vec_by_path.html"},{"text":"private subroutine wrap_json_get_array_by_path(json, me, path, array_callback, found) Alternate version of json_get_array_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_array_by_path~~CallsGraph proc~wrap_json_get_array_by_path wrap_json_get_array_by_path interface~to_unicode to_unicode proc~wrap_json_get_array_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_array_by_path Source Code subroutine wrap_json_get_array_by_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( json_array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_by_path","title":"wrap_json_get_array_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_array_by_path.html"},{"text":"private subroutine wrap_json_get_by_path(json, me, path, p, found) Alternate version of json_get_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_by_path~~CallsGraph proc~wrap_json_get_by_path wrap_json_get_by_path interface~to_unicode to_unicode proc~wrap_json_get_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_by_path Source Code subroutine wrap_json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path","title":"wrap_json_get_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_by_path.html"},{"text":"private subroutine wrap_json_get_double_by_path(json, me, path, value, found) Alternate version of json_get_double_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_double_by_path~~CallsGraph proc~wrap_json_get_double_by_path wrap_json_get_double_by_path interface~to_unicode to_unicode proc~wrap_json_get_double_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_double_by_path Source Code subroutine wrap_json_get_double_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_by_path","title":"wrap_json_get_double_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_double_by_path.html"},{"text":"private subroutine wrap_json_get_double_vec_by_path(json, me, path, vec, found) Alternate version of json_get_double_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_double_vec_by_path~~CallsGraph proc~wrap_json_get_double_vec_by_path wrap_json_get_double_vec_by_path interface~to_unicode to_unicode proc~wrap_json_get_double_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_double_vec_by_path Source Code subroutine wrap_json_get_double_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_by_path","title":"wrap_json_get_double_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_double_vec_by_path.html"},{"text":"private subroutine wrap_json_get_integer_by_path(json, me, path, value, found) Alternate version of json_get_integer_by_path , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_integer_by_path~~CallsGraph proc~wrap_json_get_integer_by_path wrap_json_get_integer_by_path interface~to_unicode to_unicode proc~wrap_json_get_integer_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_integer_by_path Source Code subroutine wrap_json_get_integer_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_by_path","title":"wrap_json_get_integer_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_integer_by_path.html"},{"text":"private subroutine wrap_json_get_integer_vec_by_path(json, me, path, vec, found) Alternate version of json_get_integer_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_integer_vec_by_path~~CallsGraph proc~wrap_json_get_integer_vec_by_path wrap_json_get_integer_vec_by_path interface~to_unicode to_unicode proc~wrap_json_get_integer_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_integer_vec_by_path Source Code subroutine wrap_json_get_integer_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_by_path","title":"wrap_json_get_integer_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_integer_vec_by_path.html"},{"text":"private subroutine wrap_json_get_logical_by_path(json, me, path, value, found) Alternate version of json_get_logical_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_logical_by_path~~CallsGraph proc~wrap_json_get_logical_by_path wrap_json_get_logical_by_path interface~to_unicode to_unicode proc~wrap_json_get_logical_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_logical_by_path Source Code subroutine wrap_json_get_logical_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_by_path","title":"wrap_json_get_logical_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_logical_by_path.html"},{"text":"private subroutine wrap_json_get_logical_vec_by_path(json, me, path, vec, found) Alternate version of json_get_logical_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_logical_vec_by_path~~CallsGraph proc~wrap_json_get_logical_vec_by_path wrap_json_get_logical_vec_by_path interface~to_unicode to_unicode proc~wrap_json_get_logical_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_logical_vec_by_path Source Code subroutine wrap_json_get_logical_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_by_path","title":"wrap_json_get_logical_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_logical_vec_by_path.html"},{"text":"private subroutine wrap_json_get_path(json, p, path, found, use_alt_array_tokens, path_sep) Wrapper for json_get_path where \"path\" and \"path_sep\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list object character(kind=CDK,len=:), intent(out), allocatable :: path path to the variable logical(kind=LK), intent(out), optional :: found true if there were no problems logical(kind=LK), intent(in), optional :: use_alt_array_tokens if true, then '()' are used for array elements\n otherwise, '[]' are used [default] character(kind=CDK,len=1), intent(in), optional :: path_sep character to use for path separator\n (default is '.') Calls proc~~wrap_json_get_path~~CallsGraph proc~wrap_json_get_path wrap_json_get_path proc~json_get_path json_get_path proc~wrap_json_get_path->proc~json_get_path proc~encode_rfc6901 encode_rfc6901 proc~json_get_path->proc~encode_rfc6901 proc~integer_to_string integer_to_string proc~json_get_path->proc~integer_to_string proc~replace_string replace_string proc~encode_rfc6901->proc~replace_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_path Source Code subroutine wrap_json_get_path ( json , p , path , found , use_alt_array_tokens , path_sep ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list object character ( kind = CDK , len = :), allocatable , intent ( out ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if there were no problems logical ( LK ), intent ( in ), optional :: use_alt_array_tokens !! if true, then '()' are used for array elements !! otherwise, '[]' are used [default] character ( kind = CDK , len = 1 ), intent ( in ), optional :: path_sep !! character to use for path separator !! (default is '.') character ( kind = CK , len = :), allocatable :: ck_path !! path to the variable character ( kind = CK , len = 1 ) :: sep ! from unicode: sep = path_sep ! call the main routine: call json_get_path ( json , p , ck_path , found , use_alt_array_tokens , sep ) ! from unicode: path = ck_path end subroutine wrap_json_get_path","title":"wrap_json_get_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_path.html"},{"text":"private subroutine wrap_json_get_string_by_path(json, me, path, value, found) Alternate version of json_get_string_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_string_by_path~~CallsGraph proc~wrap_json_get_string_by_path wrap_json_get_string_by_path interface~to_unicode to_unicode proc~wrap_json_get_string_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_string_by_path Source Code subroutine wrap_json_get_string_by_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_by_path","title":"wrap_json_get_string_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_string_by_path.html"},{"text":"private subroutine wrap_json_get_string_vec_by_path(json, me, path, vec, found) Alternate version of json_get_string_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_get_string_vec_by_path~~CallsGraph proc~wrap_json_get_string_vec_by_path wrap_json_get_string_vec_by_path interface~to_unicode to_unicode proc~wrap_json_get_string_vec_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_get_string_vec_by_path Source Code subroutine wrap_json_get_string_vec_by_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_by_path","title":"wrap_json_get_string_vec_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_get_string_vec_by_path.html"},{"text":"private subroutine wrap_json_info_by_path(json, p, path, found, var_type, n_children, name) Alternate version of json_info_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Calls proc~~wrap_json_info_by_path~~CallsGraph proc~wrap_json_info_by_path wrap_json_info_by_path interface~to_unicode to_unicode proc~wrap_json_info_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_info_by_path Source Code subroutine wrap_json_info_by_path ( json , p , path , found , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call json % info ( p , to_unicode ( path ), found , var_type , n_children , name ) end subroutine wrap_json_info_by_path","title":"wrap_json_info_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_info_by_path.html"},{"text":"private subroutine wrap_json_matrix_info_by_path(json, p, path, is_matrix, found, var_type, n_sets, set_size, name) Alternate version of json_matrix_info_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Calls proc~~wrap_json_matrix_info_by_path~~CallsGraph proc~wrap_json_matrix_info_by_path wrap_json_matrix_info_by_path interface~to_unicode to_unicode proc~wrap_json_matrix_info_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_matrix_info_by_path Source Code subroutine wrap_json_matrix_info_by_path ( json , p , path , is_matrix , found ,& var_type , n_sets , set_size , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! a JSON linked list character ( kind = CDK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: is_matrix !! true if it is a valid matrix logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ), intent ( out ), optional :: var_type !! variable type of data in !! the matrix (if all elements have !! the same type) integer ( IK ), intent ( out ), optional :: n_sets !! number of data sets (i.e., matrix !! rows if using row-major order) integer ( IK ), intent ( out ), optional :: set_size !! size of each data set (i.e., matrix !! cols if using row-major order) character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name call json % matrix_info ( p , to_unicode ( path ), is_matrix , found , var_type , n_sets , set_size , name ) end subroutine wrap_json_matrix_info_by_path","title":"wrap_json_matrix_info_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_matrix_info_by_path.html"},{"text":"private subroutine wrap_json_parse_string(json, p, str) Alternate version of json_parse_string , where str is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data Calls proc~~wrap_json_parse_string~~CallsGraph proc~wrap_json_parse_string wrap_json_parse_string interface~to_unicode to_unicode proc~wrap_json_parse_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_parse_string Source Code subroutine wrap_json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json % parse ( p , to_unicode ( str )) end subroutine wrap_json_parse_string","title":"wrap_json_parse_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_parse_string.html"},{"text":"private subroutine wrap_json_rename_by_path(json, me, path, name, found) Alternate version of json_rename_by_path , where \"path\" and \"name\" are kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_rename_by_path~~CallsGraph proc~wrap_json_rename_by_path wrap_json_rename_by_path interface~to_unicode to_unicode proc~wrap_json_rename_by_path->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_rename_by_path Source Code subroutine wrap_json_rename_by_path ( json , me , path , name , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( out ), optional :: found call json % rename ( me , to_unicode ( path ), to_unicode ( name ), found ) end subroutine wrap_json_rename_by_path","title":"wrap_json_rename_by_path – JSON-Fortran","tags":"","loc":"proc/wrap_json_rename_by_path.html"},{"text":"private subroutine wrap_json_throw_exception(json, msg) Alternate version of json_throw_exception , where msg is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: msg the error message Calls proc~~wrap_json_throw_exception~~CallsGraph proc~wrap_json_throw_exception wrap_json_throw_exception interface~to_unicode to_unicode proc~wrap_json_throw_exception->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_throw_exception Source Code subroutine wrap_json_throw_exception ( json , msg ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: msg !! the error message call json % throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception","title":"wrap_json_throw_exception – JSON-Fortran","tags":"","loc":"proc/wrap_json_throw_exception.html"},{"text":"private subroutine wrap_json_update_double(json, p, path, val, found) Alternate version of json_update_double , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Calls proc~~wrap_json_update_double~~CallsGraph proc~wrap_json_update_double wrap_json_update_double interface~to_unicode to_unicode proc~wrap_json_update_double->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_update_double Source Code subroutine wrap_json_update_double ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( path ), val , found ) end subroutine wrap_json_update_double","title":"wrap_json_update_double – JSON-Fortran","tags":"","loc":"proc/wrap_json_update_double.html"},{"text":"private subroutine wrap_json_update_integer(json, p, path, val, found) Alternate version of json_update_integer , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Calls proc~~wrap_json_update_integer~~CallsGraph proc~wrap_json_update_integer wrap_json_update_integer interface~to_unicode to_unicode proc~wrap_json_update_integer->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_update_integer Source Code subroutine wrap_json_update_integer ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( path ), val , found ) end subroutine wrap_json_update_integer","title":"wrap_json_update_integer – JSON-Fortran","tags":"","loc":"proc/wrap_json_update_integer.html"},{"text":"private subroutine wrap_json_update_logical(json, p, path, val, found) Alternate version of json_update_logical , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Calls proc~~wrap_json_update_logical~~CallsGraph proc~wrap_json_update_logical wrap_json_update_logical interface~to_unicode to_unicode proc~wrap_json_update_logical->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_update_logical Source Code subroutine wrap_json_update_logical ( json , p , path , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( path ), val , found ) end subroutine wrap_json_update_logical","title":"wrap_json_update_logical – JSON-Fortran","tags":"","loc":"proc/wrap_json_update_logical.html"},{"text":"private subroutine wrap_json_update_string(json, p, path, val, found, trim_str, adjustl_str) Alternate version of json_update_string , where path and value are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) Calls proc~~wrap_json_update_string~~CallsGraph proc~wrap_json_update_string wrap_json_update_string interface~to_unicode to_unicode proc~wrap_json_update_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_update_string Source Code subroutine wrap_json_update_string ( json , p , path , val , found , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` !! (only used if `val` is present) logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` !! (only used if `val` is present) !! (note that ADJUSTL is done before TRIM) call json % update ( p , to_unicode ( path ), to_unicode ( val ), found , trim_str , adjustl_str ) end subroutine wrap_json_update_string","title":"wrap_json_update_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_update_string.html"},{"text":"private subroutine wrap_json_value_add_double(json, p, name, val) Alternate version of json_value_add_double where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Calls proc~~wrap_json_value_add_double~~CallsGraph proc~wrap_json_value_add_double wrap_json_value_add_double interface~to_unicode to_unicode proc~wrap_json_value_add_double->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_double Source Code subroutine wrap_json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double","title":"wrap_json_value_add_double – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_double.html"},{"text":"private subroutine wrap_json_value_add_double_vec(json, p, name, val) Alternate version of json_value_add_double_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Calls proc~~wrap_json_value_add_double_vec~~CallsGraph proc~wrap_json_value_add_double_vec wrap_json_value_add_double_vec interface~to_unicode to_unicode proc~wrap_json_value_add_double_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_double_vec Source Code subroutine wrap_json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec","title":"wrap_json_value_add_double_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_double_vec.html"},{"text":"private subroutine wrap_json_value_add_integer(json, p, name, val) Alternate version of json_value_add_integer where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value Calls proc~~wrap_json_value_add_integer~~CallsGraph proc~wrap_json_value_add_integer wrap_json_value_add_integer interface~to_unicode to_unicode proc~wrap_json_value_add_integer->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_integer Source Code subroutine wrap_json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer","title":"wrap_json_value_add_integer – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_integer.html"},{"text":"private subroutine wrap_json_value_add_integer_vec(json, p, name, val) Alternate version of json_value_add_integer_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Calls proc~~wrap_json_value_add_integer_vec~~CallsGraph proc~wrap_json_value_add_integer_vec wrap_json_value_add_integer_vec interface~to_unicode to_unicode proc~wrap_json_value_add_integer_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_integer_vec Source Code subroutine wrap_json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec","title":"wrap_json_value_add_integer_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_integer_vec.html"},{"text":"private subroutine wrap_json_value_add_logical(json, p, name, val) Alternate version of json_value_add_logical where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Calls proc~~wrap_json_value_add_logical~~CallsGraph proc~wrap_json_value_add_logical wrap_json_value_add_logical interface~to_unicode to_unicode proc~wrap_json_value_add_logical->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_logical Source Code subroutine wrap_json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical","title":"wrap_json_value_add_logical – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_logical.html"},{"text":"private subroutine wrap_json_value_add_logical_vec(json, p, name, val) Alternate version of json_value_add_logical_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value Calls proc~~wrap_json_value_add_logical_vec~~CallsGraph proc~wrap_json_value_add_logical_vec wrap_json_value_add_logical_vec interface~to_unicode to_unicode proc~wrap_json_value_add_logical_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_logical_vec Source Code subroutine wrap_json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec","title":"wrap_json_value_add_logical_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_logical_vec.html"},{"text":"private subroutine wrap_json_value_add_null(json, p, name) Alternate version of json_value_add_null where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable Calls proc~~wrap_json_value_add_null~~CallsGraph proc~wrap_json_value_add_null wrap_json_value_add_null interface~to_unicode to_unicode proc~wrap_json_value_add_null->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_null Source Code subroutine wrap_json_value_add_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable call json % add ( p , to_unicode ( name )) end subroutine wrap_json_value_add_null","title":"wrap_json_value_add_null – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_null.html"},{"text":"private subroutine wrap_json_value_add_string(json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string where name and val are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val Calls proc~~wrap_json_value_add_string~~CallsGraph proc~wrap_json_value_add_string wrap_json_value_add_string interface~to_unicode to_unicode proc~wrap_json_value_add_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_string Source Code subroutine wrap_json_value_add_string ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string","title":"wrap_json_value_add_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_string.html"},{"text":"private subroutine wrap_json_value_add_string_vec(json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string_vec where name and val are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Calls proc~~wrap_json_value_add_string_vec~~CallsGraph proc~wrap_json_value_add_string_vec wrap_json_value_add_string_vec interface~to_unicode to_unicode proc~wrap_json_value_add_string_vec->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_add_string_vec Source Code subroutine wrap_json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec","title":"wrap_json_value_add_string_vec – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_add_string_vec.html"},{"text":"private subroutine wrap_json_value_create_array(json, p, name) A wrapper for json_value_create_array so that create_array method may be\n  called with an actual argument, corresponding to the dummy argument name ,\n  that is either of 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_create_array~~CallsGraph proc~wrap_json_value_create_array wrap_json_value_create_array interface~to_unicode to_unicode proc~wrap_json_value_create_array->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_array Source Code subroutine wrap_json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_array ( p , to_unicode ( name )) end subroutine wrap_json_value_create_array","title":"wrap_json_value_create_array – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_array.html"},{"text":"private subroutine wrap_json_value_create_double(json, p, val, name) A wrapper for json_value_create_double so that create_double method\n  may be called with an actual argument corresponding to the dummy argument, name that may be of 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_create_double~~CallsGraph proc~wrap_json_value_create_double wrap_json_value_create_double interface~to_unicode to_unicode proc~wrap_json_value_create_double->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_double Source Code subroutine wrap_json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p real ( RK ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_double ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_double","title":"wrap_json_value_create_double – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_double.html"},{"text":"private subroutine wrap_json_value_create_integer(json, p, val, name) A wrapper procedure for json_value_create_integer so that create_integer method may be called with either a 'DEFAULT' or 'ISO_10646' character kind name actual argument. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_create_integer~~CallsGraph proc~wrap_json_value_create_integer wrap_json_value_create_integer interface~to_unicode to_unicode proc~wrap_json_value_create_integer->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_integer Source Code subroutine wrap_json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_integer ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer","title":"wrap_json_value_create_integer – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_integer.html"},{"text":"private subroutine wrap_json_value_create_logical(json, p, val, name) Wrapper for json_value_create_logical so create_logical method can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_create_logical~~CallsGraph proc~wrap_json_value_create_logical wrap_json_value_create_logical interface~to_unicode to_unicode proc~wrap_json_value_create_logical->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_logical Source Code subroutine wrap_json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_logical ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical","title":"wrap_json_value_create_logical – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_logical.html"},{"text":"private subroutine wrap_json_value_create_null(json, p, name) Wrap json_value_create_null so that create_null method may be called with\n  an actual argument corresponding to the dummy argument name that is either\n  of 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_create_null~~CallsGraph proc~wrap_json_value_create_null wrap_json_value_create_null interface~to_unicode to_unicode proc~wrap_json_value_create_null->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_null Source Code subroutine wrap_json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_null ( p , to_unicode ( name )) end subroutine wrap_json_value_create_null","title":"wrap_json_value_create_null – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_null.html"},{"text":"private subroutine wrap_json_value_create_object(json, p, name) Wrap json_value_create_object so that create_object method may be called\n  with an actual argument corresponding to the dummy argument name that is of\n  either 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_create_object~~CallsGraph proc~wrap_json_value_create_object wrap_json_value_create_object interface~to_unicode to_unicode proc~wrap_json_value_create_object->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_object Source Code subroutine wrap_json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_object ( p , to_unicode ( name )) end subroutine wrap_json_value_create_object","title":"wrap_json_value_create_object – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_object.html"},{"text":"private subroutine wrap_json_value_create_string(json, p, val, name, trim_str, adjustl_str) Wrap json_value_create_string so that create_string method may be called\n  with actual character string arguments for name and val that are BOTH of\n  'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val Calls proc~~wrap_json_value_create_string~~CallsGraph proc~wrap_json_value_create_string wrap_json_value_create_string interface~to_unicode to_unicode proc~wrap_json_value_create_string->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_create_string Source Code subroutine wrap_json_value_create_string ( json , p , val , name , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: val character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for the `val` logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for the `val` call json % create_string ( p , to_unicode ( val ), to_unicode ( name ), trim_str , adjustl_str ) end subroutine wrap_json_value_create_string","title":"wrap_json_value_create_string – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_create_string.html"},{"text":"private subroutine wrap_json_value_get_child_by_name(json, p, name, child, found) Alternate version of json_value_get_child_by_name where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name type( json_value ), pointer :: child logical(kind=LK), intent(out), optional :: found Calls proc~~wrap_json_value_get_child_by_name~~CallsGraph proc~wrap_json_value_get_child_by_name wrap_json_value_get_child_by_name interface~to_unicode to_unicode proc~wrap_json_value_get_child_by_name->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_get_child_by_name Source Code subroutine wrap_json_value_get_child_by_name ( json , p , name , child , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: child logical ( LK ), intent ( out ), optional :: found call json % get ( p , to_unicode ( name ), child , found ) end subroutine wrap_json_value_get_child_by_name","title":"wrap_json_value_get_child_by_name – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_get_child_by_name.html"},{"text":"private subroutine wrap_json_value_remove_if_present(json, p, name) Alternate version of json_value_remove_if_present , where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name Calls proc~~wrap_json_value_remove_if_present~~CallsGraph proc~wrap_json_value_remove_if_present wrap_json_value_remove_if_present interface~to_unicode to_unicode proc~wrap_json_value_remove_if_present->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_remove_if_present Source Code subroutine wrap_json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present","title":"wrap_json_value_remove_if_present – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_remove_if_present.html"},{"text":"private subroutine wrap_json_value_rename(json, p, name) Alternate version of json_value_rename , where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name new variable name Calls proc~~wrap_json_value_rename~~CallsGraph proc~wrap_json_value_rename wrap_json_value_rename interface~to_unicode to_unicode proc~wrap_json_value_rename->interface~to_unicode proc~to_uni_vec to_uni_vec interface~to_unicode->proc~to_uni_vec proc~to_uni to_uni interface~to_unicode->proc~to_uni Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code wrap_json_value_rename Source Code subroutine wrap_json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! new variable name call json % rename ( p , to_unicode ( name )) end subroutine wrap_json_value_rename","title":"wrap_json_value_rename – JSON-Fortran","tags":"","loc":"proc/wrap_json_value_rename.html"},{"text":"public interface json_core Structure constructor to initialize a json_core object Example type ( json_file ) :: json_core json_core = json_core () Calls interface~~json_core~~CallsGraph interface~json_core json_core proc~initialize_json_core initialize_json_core interface~json_core->proc~initialize_json_core Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Module Procedures initialize_json_core Module Procedures private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(json_core_object) Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_core )","title":"json_core – JSON-Fortran","tags":"","loc":"interface/json_core.html"},{"text":"Uses: iso_fortran_env json_kinds json_parameters json_string_utilities json_value_module module~~json_file_module~~UsesGraph module~json_file_module json_file_module module~json_string_utilities json_string_utilities module~json_string_utilities->module~json_file_module module~json_value_module json_value_module module~json_string_utilities->module~json_value_module module~json_kinds json_kinds module~json_kinds->module~json_file_module module~json_kinds->module~json_string_utilities module~json_kinds->module~json_value_module module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_value_module->module~json_file_module module~json_parameters->module~json_file_module module~json_parameters->module~json_string_utilities module~json_parameters->module~json_value_module iso_fortran_env iso_fortran_env iso_fortran_env->module~json_file_module iso_fortran_env->module~json_kinds iso_fortran_env->module~json_value_module var panmodulejson_file_moduleUsesGraph = svgPanZoom('#modulejson_file_moduleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Higher-level json_file interface for the json_value type. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_file_module~~UsedByGraph module~json_file_module json_file_module module~json_module json_module module~json_file_module->module~json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces json_file Derived Types json_file Functions initialize_json_file initialize_json_file_v2 json_file_failed json_file_valid_path json_file_valid_path_op wrap_json_file_valid_path wrap_json_file_valid_path_op Subroutines get_json_core_in_file initialize_json_core_in_file json_file_add_double json_file_add_double_vec json_file_add_integer json_file_add_integer_vec json_file_add_logical json_file_add_logical_vec json_file_add_object json_file_add_string json_file_add_string_path_ascii json_file_add_string_value_ascii json_file_add_string_vec json_file_add_string_vec_path_ascii json_file_add_string_vec_vec_ascii json_file_check_for_errors json_file_clear_exceptions json_file_destroy json_file_get_alloc_string_vec json_file_get_double json_file_get_double_vec json_file_get_integer json_file_get_integer_vec json_file_get_logical json_file_get_logical_vec json_file_get_object json_file_get_root json_file_get_string json_file_get_string_vec json_file_load json_file_load_from_string json_file_move_pointer json_file_print_1 json_file_print_2 json_file_print_error_message json_file_print_to_console json_file_print_to_string json_file_rename json_file_rename_name_ascii json_file_rename_path_ascii json_file_traverse json_file_update_integer json_file_update_logical json_file_update_real json_file_update_string json_file_update_string_name_ascii json_file_update_string_val_ascii json_file_variable_info json_file_variable_matrix_info set_json_core_in_file wrap_json_file_add_double wrap_json_file_add_double_vec wrap_json_file_add_integer wrap_json_file_add_integer_vec wrap_json_file_add_logical wrap_json_file_add_logical_vec wrap_json_file_add_object wrap_json_file_add_string wrap_json_file_add_string_vec wrap_json_file_get_alloc_string_vec wrap_json_file_get_double wrap_json_file_get_double_vec wrap_json_file_get_integer wrap_json_file_get_integer_vec wrap_json_file_get_logical wrap_json_file_get_logical_vec wrap_json_file_get_object wrap_json_file_get_string wrap_json_file_get_string_vec wrap_json_file_load_from_string wrap_json_file_rename wrap_json_file_update_integer wrap_json_file_update_logical wrap_json_file_update_real wrap_json_file_update_string wrap_json_file_variable_info wrap_json_file_variable_matrix_info Interfaces public interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(file_object) Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_file ) private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Derived Types type, public :: json_file The json_file is the main public class that is\n  used to open a file and get data from it. Components Type Visibility Attributes Name Initial type( json_core ), private :: core The instance of the json_core factory used for this file. type( json_value ), private, pointer :: p => null() the JSON structure read from the file Constructor Structure constructor to initialize a json_file object\n  with an existing json_value object, and either the json_core settings or a json_core instance. private  function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Cast a json_value object as a json_file object.\n  It also calls the initialize() method. private  function initialize_json_file_v2 (json_value_object, json_core_object) Cast a json_value pointer and a json_core object\n  as a json_file object. Type-Bound Procedures generic, public :: add => json_file_add_object, json_file_add_integer, json_file_add_double, json_file_add_logical, json_file_add_string, json_file_add_integer_vec, json_file_add_double_vec, json_file_add_logical_vec, json_file_add_string_vec Add a variable to a json_file , by specifying the path. procedure, public :: check_for_errors => json_file_check_for_errors procedure, public :: clear_exceptions => json_file_clear_exceptions procedure, public :: destroy => json_file_destroy procedure, public :: failed => json_file_failed generic, public :: get => json_file_get_object, json_file_get_integer, json_file_get_double, json_file_get_logical, json_file_get_string, json_file_get_integer_vec, json_file_get_double_vec, json_file_get_logical_vec, json_file_get_string_vec, json_file_get_alloc_string_vec, json_file_get_root Get a variable from a json_file , by specifying the path. procedure, public :: get_core => get_json_core_in_file generic, public :: info => json_file_variable_info generic, public :: initialize => initialize_json_core_in_file, set_json_core_in_file procedure, public :: initialize_json_core_in_file procedure, public :: json_file_add_double procedure, public :: json_file_add_double_vec procedure, public :: json_file_add_integer procedure, public :: json_file_add_integer_vec procedure, public :: json_file_add_logical procedure, public :: json_file_add_logical_vec procedure, public :: json_file_add_object procedure, public :: json_file_add_string procedure, public :: json_file_add_string_vec procedure, public :: json_file_get_alloc_string_vec procedure, public :: json_file_get_double procedure, public :: json_file_get_double_vec procedure, public :: json_file_get_integer procedure, public :: json_file_get_integer_vec procedure, public :: json_file_get_logical procedure, public :: json_file_get_logical_vec procedure, public :: json_file_get_object procedure, public :: json_file_get_root procedure, public :: json_file_get_string procedure, public :: json_file_get_string_vec procedure, public :: json_file_load_from_string procedure, public :: json_file_print_1 procedure, public :: json_file_print_2 procedure, public :: json_file_print_to_console procedure, public :: json_file_rename procedure, public :: json_file_update_integer procedure, public :: json_file_update_logical procedure, public :: json_file_update_real procedure, public :: json_file_update_string procedure, public :: json_file_valid_path procedure, public, pass(me) :: json_file_valid_path_op procedure, public :: json_file_variable_info procedure, public :: json_file_variable_matrix_info procedure, public :: load_file => json_file_load generic, public :: load_from_string => json_file_load_from_string generic, public :: matrix_info => json_file_variable_matrix_info procedure, public :: move => json_file_move_pointer generic, public :: operator(.in.) => json_file_valid_path_op procedure, public :: print_error_message => json_file_print_error_message generic, public :: print_file => json_file_print_to_console, json_file_print_1, json_file_print_2 procedure, public :: print_to_string => json_file_print_to_string generic, public :: rename => json_file_rename Rename a variable, specifying it by path procedure, public :: set_json_core_in_file procedure, public :: traverse => json_file_traverse generic, public :: update => json_file_update_integer, json_file_update_logical, json_file_update_real, json_file_update_string Update a scalar variable in a json_file ,\n  by specifying the path. generic, public :: valid_path => json_file_valid_path Verify that a path is valid\n  (i.e., a variable with this path exists in the file). Functions private function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(file_object) Author Izaak Beekman Date 07/23/2015 Cast a json_value object as a json_file object.\n  It also calls the initialize() method. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_file ) private function initialize_json_file_v2 (json_value_object, json_core_object) result(file_object) Author Jacob Williams Date 4/26/2016 Cast a json_value pointer and a json_core object\n  as a json_file object. Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) private pure function json_file_failed (me) result(failed) Check error status in the file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. private function json_file_valid_path (me, path) result(found) Author Jacob Williams Returns true if the path is present in the JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable Return Value logical(kind=LK) if the variable was found private function json_file_valid_path_op (path, me) result(found) Author Jacob Williams A wrapper for json_file_valid_path for the .in. operator Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: path the path to the variable class( json_file ), intent(in) :: me the JSON file Return Value logical(kind=LK) if the variable was found private function wrap_json_file_valid_path (me, path) result(found) Author Jacob Williams Alternate version of json_file_valid_path , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable Return Value logical(kind=LK) if the variable was found private function wrap_json_file_valid_path_op (path, me) result(found) Author Jacob Williams Alternate version of json_file_valid_path_op , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: path the path to the variable class( json_file ), intent(in) :: me the JSON file Return Value logical(kind=LK) if the variable was found Subroutines private subroutine get_json_core_in_file (me, core) Get a copy of the json_core in this json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me type( json_core ), intent(out) :: core private subroutine initialize_json_core_in_file (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Initialize the json_core for this json_file .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). private subroutine json_file_add_double (me, path, val, found, was_created) Author Jacob Williams Add a real(RK) variable value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_double_vec (me, path, vec, found, was_created) Author Jacob Williams Add a real(RK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_integer (me, path, val, found, was_created) Author Jacob Williams Add an integer value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_integer_vec (me, path, vec, found, was_created) Author Jacob Williams Add an integer vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_logical (me, path, val, found, was_created) Author Jacob Williams Add a logical(LK) value to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_logical_vec (me, path, vec, found, was_created) Author Jacob Williams Add a logical(LK) vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_object (me, path, p, found, was_created) Author Jacob Williams Add a json_value pointer to an object to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p pointer to the variable to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_file_add_string (me, path, val, found, was_created, trim_str, adjustl_str) Author Jacob Williams Add a character string to a json file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_add_string_path_ascii (me, path, val, found, was_created, trim_str, adjustl_str) Author Jacob Williams Wrapper for json_file_add_string where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_add_string_value_ascii (me, path, val, found, was_created, trim_str, adjustl_str) Author Jacob Williams Wrapper for json_file_add_string where \"val\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_add_string_vec (me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Author Jacob Williams Add a string vector to a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) private subroutine json_file_add_string_vec_path_ascii (me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Author Jacob Williams Alternate version of json_file_add_string_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) private subroutine json_file_add_string_vec_vec_ascii (me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Author Jacob Williams Alternate version of json_file_add_string_vec , where \"vec\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) private subroutine json_file_check_for_errors (me, status_ok, error_msg) Retrieve error status and message from the class. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) private pure subroutine json_file_clear_exceptions (me) Clear exceptions in the class. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me private subroutine json_file_destroy (me, destroy_core) Author Jacob Williams Destroy the json_value data in a json_file .\n  This must be done when the variable is no longer needed,\n  or will be reused to open a different file.\n  Otherwise a memory leak will occur. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. private subroutine json_file_get_alloc_string_vec (me, path, vec, ilen, found) Author Jacob Williams Date 12/17/2016 Get an (allocatable length) string vector from a JSON file.\n  This is just a wrapper for json_get_alloc_string_vec_by_path . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec value vector integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_double (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a real(RK) variable value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_double_vec (me, path, vec, found) Author Jacob Williams Date 1/19/2014 Get a real(RK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_integer (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get an integer value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_integer_vec (me, path, vec, found) Author Jacob Williams Date 1/20/2014 Get an integer vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_logical (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a logical(LK) value from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_logical_vec (me, path, vec, found) Author Jacob Williams Date 1/20/2014 Get a logical(LK) vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_object (me, path, p, found) Author Jacob Williams Date 2/3/2014 Get a json_value pointer to an object from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_root (me, p) Author Izaak Beekman Date 7/23/2015 Get a json_value pointer to the JSON file root. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable private subroutine json_file_get_string (me, path, val, found) Author Jacob Williams Date 12/9/2013 Get a character string from a json file.\n  The output val is an allocatable character string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), allocatable :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_string_vec (me, path, vec, found) Author Jacob Williams Date 1/19/2014 Get a string vector from a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_load (me, filename, unit) Author Jacob Williams Date 12/9/2013 Load the JSON data from a file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use\n (if not present, a newunit\n is used) private subroutine json_file_load_from_string (me, str) Author Jacob Williams Date 1/13/2015 Load the JSON data from a string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from private subroutine json_file_move_pointer (to, from) Author Jacob Williams Date 12/5/2014 Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from private subroutine json_file_print_1 (me, iunit) Author Jacob Williams Date 12/9/2013 Prints the JSON file to the specified file unit number. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) private subroutine json_file_print_2 (me, filename) Author Jacob Williams Date 1/11/2015 Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to private subroutine json_file_print_error_message (me, io_unit) This is a wrapper for json_print_error_message . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit private subroutine json_file_print_to_console (me) Author Jacob Williams Date 1/11/2015 Print the JSON file to the console. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me private subroutine json_file_print_to_string (me, str) Author Jacob Williams Date 1/11/2015 Print the JSON file to a string. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to private subroutine json_file_rename (me, path, name, found) Author Jacob Williams Rename a variable in a JSON file. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found private subroutine json_file_rename_name_ascii (me, path, name, found) Author Jacob Williams Wrapper for json_file_rename where \"name\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found private subroutine json_file_rename_path_ascii (me, path, name, found) Author Jacob Williams Wrapper for json_file_rename where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found private subroutine json_file_traverse (me, traverse_callback) Author Jacob Williams Date 6/11/2016 Traverse the JSON structure in the file.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure( json_traverse_callback_func ) :: traverse_callback private subroutine json_file_update_integer (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_logical (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_real (me, path, val, found) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_string (me, path, val, found, trim_str, adjustl_str) Author Jacob Williams Date 1/10/2015 Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_update_string_name_ascii (me, path, val, found, trim_str, adjustl_str) Alternate version of json_file_update_string , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_update_string_val_ascii (me, path, val, found, trim_str, adjustl_str) Alternate version of json_file_update_string , where \"val\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine json_file_variable_info (me, path, found, var_type, n_children, name) Author Jacob Williams Date 2/3/2014 Returns information about a variable in a json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found the variable exists in the structure integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_file_variable_matrix_info (me, path, is_matrix, found, var_type, n_sets, set_size, name) Author Jacob Williams Date 6/26/2016 Returns matrix information about a variable in a json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine set_json_core_in_file (me, core) Set the json_core for this json_file . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_core ), intent(in) :: core private subroutine wrap_json_file_add_double (me, path, val, found, was_created) Author Jacob Williams Alternate version of json_file_add_double , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_double_vec (me, path, vec, found, was_created) Author Jacob Williams Alternate version of json_file_add_double_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_integer (me, path, val, found, was_created) Author Jacob Williams Alternate version of json_file_add_integer , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_integer_vec (me, path, vec, found, was_created) Author Jacob Williams Alternate version of json_file_add_integer_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_logical (me, path, val, found, was_created) Author Jacob Williams Alternate version of json_file_add_logical , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_logical_vec (me, path, vec, found, was_created) Author Jacob Williams Alternate version of json_file_add_logical_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_object (me, path, p, found, was_created) Author Jacob Williams Alternate version of json_file_add_object , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p pointer to the variable to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_file_add_string (me, path, val, found, was_created, trim_str, adjustl_str) Author Jacob Williams Alternate version of json_file_add_string , where \"path\" and \"val\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine wrap_json_file_add_string_vec (me, path, vec, found, was_created, ilen, trim_str, adjustl_str) Author Jacob Williams Alternate version of json_file_add_string_vec , where \"path\" and \"vec\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: vec the value vector logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element\n (note that ADJUSTL is done before TRIM) private subroutine wrap_json_file_get_alloc_string_vec (me, path, vec, ilen, found) Alternate version of json_file_get_alloc_string_vec , where \"path\" is kind=CDK.\n  This is just a wrapper for wrap_json_get_alloc_string_vec_by_path . Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec value vector integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_file_get_double (me, path, val, found) Alternate version of json_file_get_double , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_double_vec (me, path, vec, found) Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_integer (me, path, val, found) Alternate version of json_file_get_integer , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_integer_vec (me, path, vec, found) Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_logical (me, path, val, found) Alternate version of json_file_get_logical , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_logical_vec (me, path, vec, found) Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_object (me, path, p, found) Alternate version of json_file_get_object , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_string (me, path, val, found) Alternate version of json_file_get_string , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=:), intent(out), allocatable :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_get_string_vec (me, path, vec, found) Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine wrap_json_file_load_from_string (me, str) Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str private subroutine wrap_json_file_rename (me, path, name, found) Author Jacob Williams Alternate version of json_file_rename , where \"path\" and \"name\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found if the variable was found private subroutine wrap_json_file_update_integer (me, path, val, found) Alternate version of json_file_update_integer , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine wrap_json_file_update_logical (me, path, val, found) Alternate version of json_file_update_logical , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine wrap_json_file_update_real (me, path, val, found) Alternate version of json_file_update_real , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine wrap_json_file_update_string (me, path, val, found, trim_str, adjustl_str) Alternate version of json_file_update_string , where \"path\" and \"val\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (note that ADJUSTL is done before TRIM) private subroutine wrap_json_file_variable_info (me, path, found, var_type, n_children, name) Alternate version of json_file_variable_info , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), optional :: found integer(kind=IK), intent(out), optional :: var_type integer(kind=IK), intent(out), optional :: n_children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine wrap_json_file_variable_matrix_info (me, path, is_matrix, found, var_type, n_sets, set_size, name) Alternate version of json_file_variable_matrix_info , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name","title":"json_file_module – JSON-Fortran","tags":"","loc":"module/json_file_module.html"},{"text":"Uses: iso_fortran_env module~~json_kinds~~UsesGraph module~json_kinds json_kinds iso_fortran_env iso_fortran_env iso_fortran_env->module~json_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. JSON -Fortran kind definitions. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Note -DUSE_UCS4 is an optional preprocessor flag.\n      When present, Unicode support is enabled. Note that this\n      is currently only supported with the gfortran compiler.\n      Example: gfortran -DUSE_UCS4 ... The documentation given here assumes USE_UCS4 is not defined. Warning CK and CDK are the JSON -Fortran character kind and JSON -Fortran default\n         character kind respectively. Client code MUST ensure characters of kind=CK are used for all character variables and strings passed to the JSON -Fortran\n         library EXCEPT for file names which must be of 'DEFAULT' character kind,\n         provided here as CDK . In particular, any variable that is a: json path, string\n         value or object name passed to the JSON -Fortran library MUST be of type CK . Note Most string literal constants of default kind are fine to pass as arguments to JSON -Fortran procedures since they have been overloaded to accept intent(in) character arguments of the default ( CDK ) kind. If you find a procedure which does\n      not accept an intent(in) literal string argument of default kind, please file an issue on GitHub. Note The default real kind ( RK ) and the default integer kind ( IK ) can be\n      changed using optional preprocessor flags. This library was built with kinds:\n      real(kind=real64) [8 bytes]\n      and\n      integer(kind=int32) [4 bytes]\n      . Used By module~~json_kinds~~UsedByGraph module~json_kinds json_kinds module~json_file_module json_file_module module~json_kinds->module~json_file_module module~json_value_module json_value_module module~json_kinds->module~json_value_module module~json_module json_module module~json_kinds->module~json_module module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_string_utilities json_string_utilities module~json_kinds->module~json_string_utilities module~json_file_module->module~json_module module~json_value_module->module~json_file_module module~json_value_module->module~json_module module~json_parameters->module~json_file_module module~json_parameters->module~json_value_module module~json_parameters->module~json_module module~json_parameters->module~json_string_utilities module~json_string_utilities->module~json_file_module module~json_string_utilities->module~json_value_module var panmodulejson_kindsUsedByGraph = svgPanZoom('#modulejson_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables CDK CK IK LK RK json_fortran_string_kind Variables Type Visibility Attributes Name Initial integer, public, parameter :: CDK = selected_char_kind('DEFAULT') Processor dependendant 'DEFAULT' character kind.\n  This is 1 byte for the Intel and Gfortran compilers. integer, public, parameter :: CK = selected_char_kind(json_fortran_string_kind) Default character kind used by JSON -Fortran.\n  If ISO 10646 (UCS4) support is available, use that,\n  otherwise, gracefully fall back on 'DEFAULT' characters.\n  Currently only gfortran >= 4.9.2 will correctly support\n  UCS4 which is stored in 4 bytes.\n  (and perhaps others). integer, public, parameter :: IK = int32 Default integer kind if not specified [4 bytes] integer, public, parameter :: LK = logical_kinds(min(3, size(logical_kinds))) Default logical kind.\n  This is 4 bytes for the Intel and Gfortran compilers\n  (and perhaps others).\n  The declaration ensures a valid kind\n  if the compiler doesn't have a logical_kinds(3). integer, public, parameter :: RK = real64 Default real kind if not specified [8 bytes] character(kind=CDK,len=*), private, parameter :: json_fortran_string_kind = 'DEFAULT' String kind preprocessor macro.\n this is the string kind to use unless compiling with GFortran AND\n UCS4/ISO 10646 support is requested","title":"json_kinds – JSON-Fortran","tags":"","loc":"module/json_kinds.html"},{"text":"Uses: json_kinds json_parameters json_value_module json_file_module module~~json_module~~UsesGraph module~json_module json_module module~json_file_module json_file_module module~json_file_module->module~json_module module~json_kinds json_kinds module~json_kinds->module~json_module module~json_kinds->module~json_file_module module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_value_module json_value_module module~json_kinds->module~json_value_module module~json_string_utilities json_string_utilities module~json_kinds->module~json_string_utilities module~json_parameters->module~json_module module~json_parameters->module~json_file_module module~json_parameters->module~json_value_module module~json_parameters->module~json_string_utilities module~json_value_module->module~json_module module~json_value_module->module~json_file_module module~json_string_utilities->module~json_file_module module~json_string_utilities->module~json_value_module iso_fortran_env iso_fortran_env iso_fortran_env->module~json_file_module iso_fortran_env->module~json_kinds iso_fortran_env->module~json_value_module var panmodulejson_moduleUsesGraph = svgPanZoom('#modulejson_moduleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. A Fortran 2008 JSON (JavaScript Object Notation) API . This module provides access to json_value_module and json_file_module . For normal JSON -Fortran use, using this module\n  is all that is necessary. Note that this module renames the kind definition variables from json_kinds from [ RK , IK , LK , CK , and CDK ] to [ json_RK , json_IK , json_LK , json_CK , and json_CDK ] so as to avoid namespace pollution with short\n  variable names. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. History Joseph A. Levin : March 2012 : Original FSON code [retrieved on 12/2/2013]. Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code.\n    The original F95 code was split into four files:\n    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95.\n    The new code has been extensively updated, refactored and combined into this\n    one module (json_module.f90).\n    Various Fortran 2003/2008 features are now used\n    (e.g., allocatable strings, newunit, generic, class, and abstract interface). Development continues at: Github See also json-fortran development site json-fortran online documentation JSON website JSON validator Note Originally JSON -Fortran was entirely contained within this module.","title":"json_module – JSON-Fortran","tags":"","loc":"module/json_module.html"},{"text":"Uses: json_kinds module~~json_parameters~~UsesGraph module~json_parameters json_parameters module~json_kinds json_kinds module~json_kinds->module~json_parameters iso_fortran_env iso_fortran_env iso_fortran_env->module~json_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Other parameters used by JSON -Fortran.\n  This is a low-level module not meant to be used by a JSON -Fortran user. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_parameters~~UsedByGraph module~json_parameters json_parameters module~json_file_module json_file_module module~json_parameters->module~json_file_module module~json_module json_module module~json_parameters->module~json_module module~json_string_utilities json_string_utilities module~json_parameters->module~json_string_utilities module~json_value_module json_value_module module~json_parameters->module~json_value_module module~json_file_module->module~json_module module~json_string_utilities->module~json_file_module module~json_string_utilities->module~json_value_module module~json_value_module->module~json_file_module module~json_value_module->module~json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables backslash bspace carriage_return chunk_size colon_char control_chars default_real_fmt delimiter dot end_array end_array_alt end_object false_str formfeed horizontal_tab i_ int_fmt json_array json_double json_ext json_integer json_logical json_null json_object json_string json_unknown lower max_integer_str_len max_numeric_str_len maxexp minexp newline null_str percent pushed_char_size quotation_mark real_exponent_digits real_precision root rp_addl_safety rp_safety_factor seq_chunk_size single_quote slash space star start_array start_array_alt start_object this tilde true_str unit2str upper Variables Type Visibility Attributes Name Initial character(kind=CK,len=*), public, parameter :: backslash = achar(92, kind=CK) character(kind=CK,len=*), public, parameter :: bspace = achar(8, kind=CK) character(kind=CK,len=*), public, parameter :: carriage_return = achar(13, kind=CK) integer(kind=IK), public, parameter :: chunk_size = 100_IK for allocatable strings: allocate chunks of this size character(kind=CK,len=*), public, parameter :: colon_char = CK_':' character(kind=CK,len=*), public, parameter, dimension(32) :: control_chars = [(achar(i_, kind=CK), i_=1, 31), achar(127, kind=CK)] Control characters, possibly in unicode character(kind=CDK,len=*), public, parameter :: default_real_fmt = '(ss,E27.17E4)' default real number format statement (for writing real values to strings and files).\n Note that this can be overridden by calling json_initialize . character(kind=CK,len=*), public, parameter :: delimiter = CK_',' character(kind=CK,len=*), public, parameter :: dot = CK_'.' for json_get_by_path character(kind=CK,len=*), public, parameter :: end_array = CK_']' character(kind=CK,len=*), public, parameter :: end_array_alt = CK_')' for json_get_by_path character(kind=CK,len=*), public, parameter :: end_object = CK_'}' character(kind=CK,len=5), protected :: false_str = CK_'false' JSON logical False string character(kind=CK,len=*), public, parameter :: formfeed = achar(12, kind=CK) character(kind=CK,len=*), public, parameter :: horizontal_tab = achar(9, kind=CK) integer, private :: i_ just a counter for control_chars array character(kind=CDK,len=*), public, parameter :: int_fmt = '(ss,I0)' minimum width format for integers integer(kind=IK), public, parameter :: json_array = 3 Array JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_double = 6 Double JSON data type\n (see json_file_variable_info and json_info ) character(kind=CDK,len=*), public, parameter :: json_ext = '.json' JSON file extension integer(kind=IK), public, parameter :: json_integer = 5 Integer JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_logical = 4 Logical JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_null = 1 Null JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_object = 2 Object JSON data type\n (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_string = 7 String JSON data type integer(kind=IK), public, parameter :: json_unknown = 0 Unknown JSON data type\n (see json_file_variable_info and json_info ) character(kind=CK,len=26), protected :: lower = CK_'abcdefghijklmnopqrstuvwxyz' lowercase characters integer(kind=IK), public, parameter :: max_integer_str_len = 256 maximum string length of an integer.\n This is totally arbitrary (any way\n to get the compiler to tell us this?) integer(kind=IK), public, parameter :: max_numeric_str_len = real_precision+real_exponent_digits+6 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra integer(kind=IK), public, parameter :: maxexp = maxexponent(1.0_RK) integer(kind=IK), public, parameter :: minexp = minexponent(1.0_RK) character(kind=CK,len=*), public, parameter :: newline = achar(10, kind=CK) character(kind=CK,len=4), protected :: null_str = CK_'null' JSON Null variable string character(kind=CK,len=*), public, parameter :: percent = CK_'%' Fortran path separator integer(kind=IK), public, parameter :: pushed_char_size = 10_IK size for pushed_char array in json_core character(kind=CK,len=*), public, parameter :: quotation_mark = achar(34, kind=CK) integer(kind=IK), public, parameter :: real_exponent_digits = floor(1+log10(real(max(maxexp, abs(maxexp)), kind=RK))) integer(kind=IK), public, parameter :: real_precision = rp_safety_factor*precision(1.0_RK)+rp_addl_safety character(kind=CK,len=*), public, parameter :: root = CK_'$' for json_get_by_path integer(kind=IK), public, parameter :: rp_addl_safety = 2_IK integer(kind=IK), public, parameter :: rp_safety_factor = 1_IK integer(kind=IK), public, parameter :: seq_chunk_size = 256_IK chunk size for reading sequential files character(kind=CK,len=*), public, parameter :: single_quote = CK_\"'\" for JSONPath bracket-notation character(kind=CK,len=*), public, parameter :: slash = achar(47, kind=CK) character(kind=CK,len=*), public, parameter :: space = CK_' ' character(kind=CK,len=*), public, parameter :: star = CK_'*' for invalid numbers and\n list-directed real output character(kind=CK,len=*), public, parameter :: start_array = CK_'[' character(kind=CK,len=*), public, parameter :: start_array_alt = CK_'(' for json_get_by_path character(kind=CK,len=*), public, parameter :: start_object = CK_'{' character(kind=CK,len=*), public, parameter :: this = CK_'@' for json_get_by_path character(kind=CK,len=*), public, parameter :: tilde = CK_'~' RFC 6901 escape character character(kind=CK,len=4), protected :: true_str = CK_'true' JSON logical True string integer(kind=IK), public, parameter :: unit2str = -1_IK unit number to cause stuff to be\n output to strings rather than files.\n See 9.5.6.12 in the F2003/08 standard character(kind=CK,len=26), protected :: upper = CK_'ABCDEFGHIJKLMNOPQRSTUVWXYZ' uppercase characters","title":"json_parameters – JSON-Fortran","tags":"","loc":"module/json_parameters.html"},{"text":"Uses: json_kinds json_parameters module~~json_string_utilities~~UsesGraph module~json_string_utilities json_string_utilities module~json_kinds json_kinds module~json_kinds->module~json_string_utilities module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_parameters->module~json_string_utilities iso_fortran_env iso_fortran_env iso_fortran_env->module~json_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. JSON -Fortran support module for string manipulation. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_string_utilities~~UsedByGraph module~json_string_utilities json_string_utilities module~json_file_module json_file_module module~json_string_utilities->module~json_file_module module~json_value_module json_value_module module~json_string_utilities->module~json_value_module module~json_module json_module module~json_file_module->module~json_module module~json_value_module->module~json_file_module module~json_value_module->module~json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces to_unicode Functions decode_rfc6901 default_comp_ucs4 default_join_ucs4 default_neq_ucs4 encode_rfc6901 lowercase_string to_uni to_uni_vec ucs4_comp_default ucs4_join_default ucs4_neq_default valid_json_hex Subroutines compact_real_string escape_string integer_to_string real_to_string replace_string string_to_integer string_to_real unescape_string Interfaces public interface to_unicode Convert a 'DEFAULT' kind character input to\n  'ISO_10646' kind and return it private pure function to_uni (str) Author Izaak Beekman Convert string to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) private pure function to_uni_vec (str) Author Izaak Beekman Convert array of strings to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Functions public pure function decode_rfc6901 (str) result(str_out) Decode a string from the \" JSON Pointer\" RFC 6901 format. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str Return Value character(kind=CK,len=:),\n  allocatable private pure elemental function default_comp_ucs4 (def_str, ucs4_str) result(res) Author Izaak Beekman CDK == CK operator. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) private pure function default_join_ucs4 (def_str, ucs4_str) result(res) Author Izaak Beekman CDK // CK operator. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) private pure elemental function default_neq_ucs4 (def_str, ucs4_str) result(res) Author Jacob Williams CDK /= CK operator. Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) public pure function encode_rfc6901 (str) result(str_out) Encode a string into the \" JSON Pointer\" RFC 6901 format. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str Return Value character(kind=CK,len=:),\n  allocatable public pure elemental function lowercase_string (str) result(s_lower) Author Jacob Williams Returns lowercase version of the CK string. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str input string Return Value character(kind=CK,len=(len(str))) lowercase version of the string private pure function to_uni (str) Author Izaak Beekman Convert string to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) private pure function to_uni_vec (str) Author Izaak Beekman Convert array of strings to unicode (CDK to CK). Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) private pure elemental function ucs4_comp_default (ucs4_str, def_str) result(res) Author Izaak Beekman CK == CDK operator. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) private pure function ucs4_join_default (ucs4_str, def_str) result(res) Author Izaak Beekman CK // CDK operator. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) private pure elemental function ucs4_neq_default (ucs4_str, def_str) result(res) Author Jacob Williams CK /= CDK operator. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) public pure function valid_json_hex (str) result(valid) Author Jacob Williams Date 6/14/2014 Returns true if the string is a valid 4-digit hex string. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Subroutines private subroutine compact_real_string (str) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that\n  the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(inout) :: str string representation of a real number. public subroutine escape_string (str_in, str_out, escape_solidus) Author Jacob Williams Date 1/21/2014 Add the escape characters to a string for adding to JSON . Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out logical(kind=LK), intent(in) :: escape_solidus if the solidus (forward slash)\n is also to be escaped public pure subroutine integer_to_string (ival, int_fmt, str) Author Jacob Williams Date 12/4/2013 Convert an integer to a string. Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CDK,len=*), intent(in) :: int_fmt format for integers character(kind=CK,len=*), intent(out) :: str ival converted to a string. public subroutine real_to_string (rval, real_fmt, compact_real, str) Author Jacob Williams Date 12/4/2013 Convert a real value to a string. Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CDK,len=*), intent(in) :: real_fmt format for real numbers logical(kind=LK), intent(in) :: compact_real compact the string so that it is\n displayed with fewer characters character(kind=CK,len=*), intent(out) :: str rval converted to a string. public pure subroutine replace_string (str, s1, s2) Replace all occurrences of s1 in str with s2 . Arguments Type Intent Optional Attributes Name character(kind=CK,len=:), intent(inout), allocatable :: str character(kind=CK,len=*), intent(in) :: s1 character(kind=CK,len=*), intent(in) :: s2 public subroutine string_to_integer (str, ival, status_ok) Convert a string into an integer. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to conver to an integer integer(kind=IK), intent(out) :: ival the integer value logical(kind=LK), intent(out) :: status_ok true if there were no errors public subroutine string_to_real (str, rval, status_ok) Author Jacob Williams Date 1/19/2014 Convert a string into a real(RK) . Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str real(kind=RK), intent(out) :: rval logical(kind=LK), intent(out) :: status_ok true if there were no errors public subroutine unescape_string (str_in, str_out, error_message) Remove the escape characters from a JSON string and return it. Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in string as stored in a json_value character(kind=CK,len=:), intent(out), allocatable :: str_out decoded string character(kind=CK,len=:), intent(out), allocatable :: error_message will be allocated if there was an error","title":"json_string_utilities – JSON-Fortran","tags":"","loc":"module/json_string_utilities.html"},{"text":"Uses: iso_fortran_env json_kinds json_parameters json_string_utilities module~~json_value_module~~UsesGraph module~json_value_module json_value_module module~json_string_utilities json_string_utilities module~json_string_utilities->module~json_value_module module~json_kinds json_kinds module~json_kinds->module~json_value_module module~json_kinds->module~json_string_utilities module~json_parameters json_parameters module~json_kinds->module~json_parameters module~json_parameters->module~json_value_module module~json_parameters->module~json_string_utilities iso_fortran_env iso_fortran_env iso_fortran_env->module~json_value_module iso_fortran_env->module~json_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This module provides a low-level interface for manipulation of JSON data.\n  The two public entities are json_value , and json_core .\n  The json_file_module provides a higher-level interface to some\n  of these routines. License JSON -Fortran is released under a BSD-style license.\n    See the LICENSE file for details. Used By module~~json_value_module~~UsedByGraph module~json_value_module json_value_module module~json_file_module json_file_module module~json_value_module->module~json_file_module module~json_module json_module module~json_value_module->module~json_module module~json_file_module->module~json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables access_spec form_spec use_unformatted_stream Interfaces json_core Abstract Interfaces json_array_callback_func json_traverse_callback_func Derived Types json_core json_value Functions initialize_json_core json_count json_failed json_valid_path json_value_is_child_of name_equal name_strings_equal string_to_dble string_to_int wrap_json_valid_path Subroutines annotate_invalid_json convert destroy_json_core destroy_json_data get_current_line_from_file_sequential get_current_line_from_file_stream json_add_double_by_path json_add_double_vec_by_path json_add_integer_by_path json_add_integer_vec_by_path json_add_logical_by_path json_add_logical_vec_by_path json_add_member_by_path json_add_string_by_path json_add_string_by_path_path_ascii json_add_string_by_path_value_ascii json_add_string_vec_by_path json_add_string_vec_by_path_path_ascii json_add_string_vec_by_path_value_ascii json_check_all_for_duplicate_keys json_check_children_for_duplicate_keys json_check_for_errors json_clear_exceptions json_clone json_create_by_path json_get_alloc_string_vec json_get_alloc_string_vec_by_path json_get_array json_get_array_by_path json_get_by_path json_get_by_path_default json_get_by_path_jsonpath_bracket json_get_by_path_rfc6901 json_get_double json_get_double_by_path json_get_double_vec json_get_double_vec_by_path json_get_integer json_get_integer_by_path json_get_integer_vec json_get_integer_vec_by_path json_get_logical json_get_logical_by_path json_get_logical_vec json_get_logical_vec_by_path json_get_next json_get_parent json_get_path json_get_previous json_get_string json_get_string_by_path json_get_string_vec json_get_string_vec_by_path json_get_tail json_info json_info_by_path json_initialize json_matrix_info json_matrix_info_by_path json_parse_file json_parse_string json_print_1 json_print_2 json_print_error_message json_rename_by_path json_rename_by_path_name_ascii json_rename_by_path_path_ascii json_string_info json_throw_exception json_traverse json_update_double json_update_integer json_update_logical json_update_string json_update_string_name_ascii json_update_string_val_ascii json_value_add_double json_value_add_double_vec json_value_add_integer json_value_add_integer_vec json_value_add_logical json_value_add_logical_vec json_value_add_member json_value_add_null json_value_add_string json_value_add_string_name_ascii json_value_add_string_val_ascii json_value_add_string_vec json_value_add_string_vec_name_ascii json_value_add_string_vec_val_ascii json_value_clone_func json_value_create json_value_create_array json_value_create_double json_value_create_integer json_value_create_logical json_value_create_null json_value_create_object json_value_create_string json_value_destroy json_value_get_child json_value_get_child_by_index json_value_get_child_by_name json_value_insert_after json_value_insert_after_child_by_index json_value_print json_value_remove json_value_remove_if_present json_value_rename json_value_replace json_value_reverse json_value_swap json_value_to_string json_value_validate parse_array parse_for_chars parse_number parse_object parse_string parse_value pop_char push_char to_array to_double to_integer to_logical to_null to_object to_string wrap_json_add_double_by_path wrap_json_add_double_vec_by_path wrap_json_add_integer_by_path wrap_json_add_integer_vec_by_path wrap_json_add_logical_by_path wrap_json_add_logical_vec_by_path wrap_json_add_member_by_path wrap_json_add_string_by_path wrap_json_add_string_vec_by_path wrap_json_create_by_path wrap_json_get_alloc_string_vec_by_path wrap_json_get_array_by_path wrap_json_get_by_path wrap_json_get_double_by_path wrap_json_get_double_vec_by_path wrap_json_get_integer_by_path wrap_json_get_integer_vec_by_path wrap_json_get_logical_by_path wrap_json_get_logical_vec_by_path wrap_json_get_path wrap_json_get_string_by_path wrap_json_get_string_vec_by_path wrap_json_info_by_path wrap_json_matrix_info_by_path wrap_json_parse_string wrap_json_rename_by_path wrap_json_throw_exception wrap_json_update_double wrap_json_update_integer wrap_json_update_logical wrap_json_update_string wrap_json_value_add_double wrap_json_value_add_double_vec wrap_json_value_add_integer wrap_json_value_add_integer_vec wrap_json_value_add_logical wrap_json_value_add_logical_vec wrap_json_value_add_null wrap_json_value_add_string wrap_json_value_add_string_vec wrap_json_value_create_array wrap_json_value_create_double wrap_json_value_create_integer wrap_json_value_create_logical wrap_json_value_create_null wrap_json_value_create_object wrap_json_value_create_string wrap_json_value_get_child_by_name wrap_json_value_remove_if_present wrap_json_value_rename Variables Type Visibility Attributes Name Initial character(kind=CDK,len=*), private, parameter :: access_spec = 'STREAM' If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. character(kind=CDK,len=*), private, parameter :: form_spec = 'UNFORMATTED' If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. logical, private, parameter :: use_unformatted_stream = .true. If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. Interfaces public interface json_core Structure constructor to initialize a json_core object private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(json_core_object) Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_core ) Abstract Interfaces abstract interface public subroutine json_array_callback_func (json, element, i, count) Array element callback function.  Used by json_get_array Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i index integer(kind=IK), intent(in) :: count size of array abstract interface public subroutine json_traverse_callback_func (json, p, finished) Callback function used by json_traverse Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: finished set true to stop traversing Derived Types type, public :: json_core To access the core routines for manipulation\n  of json_value pointer variables. This class allows\n  for thread safe use of the module. Components Type Visibility Attributes Name Initial logical(kind=LK), private :: allow_comments = .true. if true, any comments will be ignored when\n parsing a file. The comment token is defined\n by the comment_char character variable. logical(kind=LK), private :: allow_duplicate_keys = .true. If False, then after parsing, if any\n duplicate keys are found, an error is\n thrown. A call to json_value_validate will also check for duplicates. If True\n [default] then no special checks are done logical(kind=LK), private :: case_sensitive_keys = .true. if name and path comparisons\n are case sensitive. integer(kind=IK), private :: char_count = 0 character position in the current line character(kind=CK,len=1), private :: comment_char = CK_'!' comment token when allow_comments is true.\n Examples: ' ! ' or ' # '. logical(kind=LK), private :: compact_real = .true. to use the \"compact\" form of real\n numbers for output logical(kind=LK), private :: compress_vectors = .false. If true, then arrays of integers,\n nulls, doubles, & logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary] character(kind=CK,len=:), private, allocatable :: err_message the error message logical(kind=LK), private :: escape_solidus = .false. If True then the solidus \" / \" is always escaped\n (\" \\/ \") when serializing JSON .\n If False [default], then it is not escaped.\n Note that this option does not affect parsing\n (both escaped and unescaped versions are still\n valid in all cases). logical(kind=LK), private :: exception_thrown = .false. The error flag. Will be set to true\n when an error is thrown in the class.\n Many of the methods will check this\n and return immediately if it is true. integer(kind=IK), private :: ipos = 1 for allocatable strings: next character to read logical(kind=LK), private :: is_verbose = .false. if true, all exceptions are\n immediately printed to console. integer(kind=IK), private :: line_count = 1 lines read counter logical(kind=LK), private :: no_whitespace = .false. when printing a JSON string, don't include\n non-significant spaces or line breaks.\n If true, the entire structure will be\n printed on one line. integer(kind=IK), private :: path_mode = 1_IK How the path strings are interpreted in the get_by_path routines: character(kind=CK,len=1), private :: path_separator = dot The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Note: if path_mode/=1 then this is ignored. character(kind=CK,len=pushed_char_size), private :: pushed_char = CK_'' used when parsing\n lines in file integer(kind=IK), private :: pushed_index = 0 used when parsing lines in file character(kind=CDK,len=:), private, allocatable :: real_fmt the format string to use\n for converting real numbers to strings.\n It can be set in json_initialize ,\n and used in json_value_print If not set, then default_real_fmt is used instead. integer(kind=IK), private :: spaces_per_tab = 2 number of spaces for indenting logical(kind=LK), private :: stop_on_error = .false. if true, then the program is\n stopped immediately when an\n exception is raised. logical(kind=LK), private :: strict_type_checking = .false. if true, then no type conversions are done\n in the get routines if the actual variable\n type is different from the return type (for\n example, integer to double). logical(kind=LK), private :: trailing_spaces_significant = .false. for name and path comparisons, if trailing\n space is to be considered significant. logical(kind=LK), private :: unescaped_strings = .true. If false, then the escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. Constructor Structure constructor to initialize a json_core object private  function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Type-Bound Procedures generic, public :: add => json_value_add_member, json_value_add_null, json_value_add_integer, json_value_add_integer_vec, json_value_add_double, json_value_add_double_vec, json_value_add_logical, json_value_add_logical_vec, json_value_add_string, json_value_add_string_vec Add objects to a linked list of json_value s. generic, public :: add_by_path => json_add_member_by_path, json_add_integer_by_path, json_add_double_by_path, json_add_logical_by_path, json_add_string_by_path, json_add_integer_vec_by_path, json_add_double_vec_by_path, json_add_logical_vec_by_path, json_add_string_vec_by_path Add variables to a json_value linked list\n  by specifying their paths. procedure, private :: annotate_invalid_json procedure, public :: check_children_for_duplicate_keys => json_check_children_for_duplicate_keys Check a json_value object's\n children for duplicate keys procedure, public :: check_for_duplicate_keys => json_check_all_for_duplicate_keys Check entire JSON structure\n for duplicate keys (recursively) procedure, public :: check_for_errors => json_check_for_errors check for error and get error message procedure, public :: clear_exceptions => json_clear_exceptions clear exceptions procedure, public :: clone => json_clone clone a JSON structure (deep copy) procedure, private :: convert procedure, public :: count => json_count count the number of children generic, public :: create => json_create_by_path Create a json_value linked list using the\n  path to the variables. Optionally return a\n  pointer to the variable. generic, public :: create_array => json_value_create_array Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. generic, public :: create_double => json_value_create_double Allocate a json_value pointer and make it a double variable.\n  The pointer should not already be allocated. generic, public :: create_integer => json_value_create_integer Allocate a json_value pointer and make it an integer variable.\n  The pointer should not already be allocated. generic, public :: create_logical => json_value_create_logical Allocate a json_value pointer and make it a logical variable.\n  The pointer should not already be allocated. generic, public :: create_null => json_value_create_null Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. generic, public :: create_object => json_value_create_object Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. generic, public :: create_string => json_value_create_string Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. generic, public :: destroy => json_value_destroy, destroy_json_core Destructor routine for a json_value pointer.\n  This must be called explicitly if it is no longer needed,\n  before it goes out of scope.  Otherwise, a memory leak will result. procedure, private :: destroy_json_core procedure, public :: failed => json_failed check for error generic, public :: get => json_get_by_path, json_get_integer, json_get_integer_by_path, json_get_integer_vec, json_get_integer_vec_by_path, json_get_double, json_get_double_by_path, json_get_double_vec, json_get_double_vec_by_path, json_get_logical, json_get_logical_by_path, json_get_logical_vec, json_get_logical_vec_by_path, json_get_string, json_get_string_by_path, json_get_string_vec, json_get_string_vec_by_path, json_get_alloc_string_vec, json_get_alloc_string_vec_by_path, json_get_array, json_get_array_by_path Get data from a json_value linked list. generic, public :: get_child => json_value_get_child_by_index, json_value_get_child, json_value_get_child_by_name Return a child of a json_value structure. procedure, private :: get_current_line_from_file_sequential procedure, private :: get_current_line_from_file_stream procedure, public :: get_next => json_get_next get pointer to json_value next procedure, public :: get_parent => json_get_parent get pointer to json_value parent generic, public :: get_path => json_get_path get the path to a JSON variable in a structure: procedure, public :: get_previous => json_get_previous get pointer to json_value previous procedure, public :: get_tail => json_get_tail get pointer to json_value tail generic, public :: info => json_info, json_info_by_path get info about a json_value procedure, public :: initialize => json_initialize to initialize some parsing parameters generic, public :: insert_after => json_value_insert_after, json_value_insert_after_child_by_index insert a new element after an existing one,\n  updating the JSON structure accordingly procedure, public :: is_child_of => json_value_is_child_of Check if a json_value is a\n descendant of another. procedure, private :: json_add_double_by_path procedure, private :: json_add_double_vec_by_path procedure, private :: json_add_integer_by_path procedure, private :: json_add_integer_vec_by_path procedure, private :: json_add_logical_by_path procedure, private :: json_add_logical_vec_by_path procedure, private :: json_add_member_by_path procedure, private :: json_add_string_by_path procedure, private :: json_add_string_vec_by_path procedure, private :: json_create_by_path procedure, private :: json_get_alloc_string_vec procedure, private :: json_get_alloc_string_vec_by_path procedure, private :: json_get_array procedure, private :: json_get_array_by_path procedure, private :: json_get_by_path procedure, private :: json_get_by_path_default procedure, private :: json_get_by_path_jsonpath_bracket procedure, private :: json_get_by_path_rfc6901 procedure, private :: json_get_double procedure, private :: json_get_double_by_path procedure, private :: json_get_double_vec procedure, private :: json_get_double_vec_by_path procedure, private :: json_get_integer procedure, private :: json_get_integer_by_path procedure, private :: json_get_integer_vec procedure, private :: json_get_integer_vec_by_path procedure, private :: json_get_logical procedure, private :: json_get_logical_by_path procedure, private :: json_get_logical_vec procedure, private :: json_get_logical_vec_by_path procedure, private :: json_get_path procedure, private :: json_get_string procedure, private :: json_get_string_by_path procedure, private :: json_get_string_vec procedure, private :: json_get_string_vec_by_path procedure, private :: json_info procedure, private :: json_info_by_path procedure, private :: json_matrix_info procedure, private :: json_matrix_info_by_path procedure, private :: json_parse_file procedure, private :: json_parse_string procedure, private :: json_print_1 procedure, private :: json_print_2 procedure, private :: json_rename_by_path procedure, private :: json_string_info procedure, private :: json_throw_exception procedure, private :: json_update_double procedure, private :: json_update_integer procedure, private :: json_update_logical procedure, private :: json_update_string procedure, private :: json_valid_path procedure, private :: json_value_add_double procedure, private :: json_value_add_double_vec procedure, private :: json_value_add_integer procedure, private :: json_value_add_integer_vec procedure, private :: json_value_add_logical procedure, private :: json_value_add_logical_vec procedure, private :: json_value_add_member procedure, private :: json_value_add_null procedure, private :: json_value_add_string procedure, private :: json_value_add_string_vec procedure, private :: json_value_create_array procedure, private :: json_value_create_double procedure, private :: json_value_create_integer procedure, private :: json_value_create_logical procedure, private :: json_value_create_null procedure, private :: json_value_create_object procedure, private :: json_value_create_string procedure, private :: json_value_destroy procedure, private :: json_value_get_child procedure, private :: json_value_get_child_by_index procedure, private :: json_value_get_child_by_name procedure, private :: json_value_insert_after procedure, private :: json_value_insert_after_child_by_index procedure, private :: json_value_print procedure, private :: json_value_remove_if_present procedure, private :: json_value_rename generic, public :: matrix_info => json_matrix_info, json_matrix_info_by_path get matrix info about a json_value procedure, private :: name_equal procedure, private :: name_strings_equal generic, public :: parse => json_parse_file, json_parse_string Parse the JSON file and populate the json_value tree. procedure, private :: parse_array procedure, private :: parse_for_chars procedure, private :: parse_number procedure, private :: parse_object procedure, private :: parse_string procedure, private :: parse_value procedure, private :: pop_char generic, public :: print => json_print_1, json_print_2 Print the json_value to a file. procedure, public :: print_error_message => json_print_error_message simply routine to print error\n messages procedure, public :: print_to_string => json_value_to_string Print the json_value structure to an allocatable\n string procedure, private :: push_char procedure, public :: remove => json_value_remove Remove a json_value from a\n linked-list structure. generic, public :: remove_if_present => json_value_remove_if_present If the child variable is present, then remove it. generic, public :: rename => json_value_rename, json_rename_by_path Rename a json_value variable. procedure, public :: replace => json_value_replace Replace a json_value in a\n linked-list structure. procedure, public :: reverse => json_value_reverse Reverse the order of the children\n of an array of object. generic, public :: string_info => json_string_info get string info about a json_value procedure, private :: string_to_dble procedure, private :: string_to_int procedure, public :: swap => json_value_swap Swap two json_value pointers\n in a structure (or two different\n structures). generic, public :: throw_exception => json_throw_exception Throw an exception. procedure, private :: to_array procedure, private :: to_double procedure, private :: to_integer procedure, private :: to_logical procedure, private :: to_null procedure, private :: to_object procedure, private :: to_string procedure, public :: traverse => json_traverse to traverse all elements of a JSON structure generic, public :: update => json_update_logical, json_update_double, json_update_integer, json_update_string These are like the add methods, except if a variable with the\n  same path is already present, then its value is simply updated.\n  Note that currently, these only work for scalar variables.\n  These routines can also change the variable's type (but an error will be\n  thrown if the existing variable is not a scalar). generic, public :: valid_path => json_valid_path verify if a path is valid\n  (i.e., a variable with this path exists in the file). procedure, public :: validate => json_value_validate Check that a json_value linked\n list is valid (i.e., is properly\n constructed). This may be useful\n if it has been constructed externally. type, public, sequence  :: json_value Type used to construct the linked-list JSON structure.\n  Normally, this should always be a pointer variable.\n  This type should only be used by an instance of json_core . Components Type Visibility Attributes Name Initial type( json_value ), private, pointer :: children => null() first child item of this real(kind=RK), private, allocatable :: dbl_value real data for this variable integer(kind=IK), private, allocatable :: int_value integer data for this variable logical(kind=LK), private, allocatable :: log_value logical data for this variable integer(kind=IK), private :: n_children = 0 number of children character(kind=CK,len=:), private, allocatable :: name variable name (unescaped) type( json_value ), private, pointer :: next => null() next item in the list type( json_value ), private, pointer :: parent => null() parent item of this type( json_value ), private, pointer :: previous => null() previous item in the list character(kind=CK,len=:), private, allocatable :: str_value string data for this variable\n (unescaped) type( json_value ), private, pointer :: tail => null() last child item of this integer(kind=IK), private :: var_type = json_unknown variable type Functions private function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) result(json_core_object) Author Jacob Williams Date 4/26/2016 Function constructor for a json_core .\n  This is just a wrapper for json_initialize . Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). Return Value type( json_core ) private function json_count (json, p) result(count) Count the number of children. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) number of children private pure function json_failed (json) result(failed) Author Jacob Williams Date 12/5/2013 Logical function to indicate if an exception has been thrown in a json_core . Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. private function json_valid_path (json, p, path) result(found) Returns true if the path is present in the p JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable Return Value logical(kind=LK) true if it was found private function json_value_is_child_of (json, p1, p2) result(is_child_of) Author Jacob Williams Date 4/28/2016 Returns True if p2 is a descendant of p1 (i.e, a child, or a child of child, etc.) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 type( json_value ), pointer :: p2 Return Value logical(kind=LK) private function name_equal (json, p, name) result(is_equal) Author Jacob Williams Returns true if name is equal to p%name , using the specified\n  settings for case sensitivity and trailing whitespace. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in) :: p the json object character(kind=CK,len=*), intent(in) :: name the name to check for Return Value logical(kind=LK) true if the string are\n lexically equal private function name_strings_equal (json, name1, name2) result(is_equal) Author Jacob Williams Date 8/25/2017 Returns true if the name strings name1 is equal to name2 , using\n  the specified settings for case sensitivity and trailing whitespace. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: name1 the name to check character(kind=CK,len=*), intent(in) :: name2 the name to check Return Value logical(kind=LK) true if the string are\n lexically equal private function string_to_dble (json, str) result(rval) Convert a string into a double. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) private function string_to_int (json, str) result(ival) Convert a string into an integer. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) private function wrap_json_valid_path (json, p, path) result(found) Alternate version of json_valid_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable Return Value logical(kind=LK) true if it was found Subroutines private subroutine annotate_invalid_json (json, iunit, str) Generate a warning message if there was an error parsing a JSON file or string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data private subroutine convert (json, p, var_type) Convert an existing JSON variable p to a different variable type.\n  The existing variable (and its children) is destroyed. It is replaced\n  in the structure by a new variable of type var_type (which can be a json_null , json_object or json_array ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p the variable to convert integer(kind=IK), intent(in) :: var_type the variable type to convert p to private subroutine destroy_json_core (me) Author Jacob Williams Date 4/17/2016 Destructor for the json_core type. Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me private subroutine destroy_json_data (d) Author Jacob Williams Destroy the data within a json_value , and reset type to json_unknown . Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: d private subroutine get_current_line_from_file_sequential (json, iunit, line) Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line private subroutine get_current_line_from_file_stream (json, iunit, line) Author Jacob Williams Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line private subroutine json_add_double_by_path (json, me, path, value, found, was_created) Add an double value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_double_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_double_by_path for adding a double vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_integer_by_path (json, me, path, value, found, was_created) Add an integer value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_integer_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_integer_by_path for adding an integer vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_logical_by_path (json, me, path, value, found, was_created) Add a logical value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_logical_vec_by_path (json, me, path, value, found, was_created) Wrapper to json_add_logical_by_path for adding a logical vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_member_by_path (json, me, path, p, found, was_created) Add a new member ( json_value pointer) to a JSON structure, given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine json_add_string_by_path (json, me, path, value, found, was_created, trim_str, adjustl_str) Add a string value to a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_add_string_by_path_path_ascii (json, me, path, value, found, was_created, trim_str, adjustl_str) Wrapper for json_add_string_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_add_string_by_path_value_ascii (json, me, path, value, found, was_created, trim_str, adjustl_str) Wrapper for json_add_string_by_path where \"value\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_add_string_vec_by_path (json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper to json_add_string_by_path for adding a string vector by path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_add_string_vec_by_path_path_ascii (json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper for json_add_string_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_add_string_vec_by_path_value_ascii (json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper for json_add_string_vec_by_path where \"value\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_check_all_for_duplicate_keys (json, p, has_duplicate, name, path) Author Jacob Williams Date 8/25/2017 Checks a JSON structure for duplicate child names.\n  This one recursively traverses the entire structure\n  (calling json_check_children_for_duplicate_keys recursively for each element). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p the object to search. If p is\n not a json_object , then has_duplicate will be false. logical(kind=LK), intent(out) :: has_duplicate true if there is at least\n one duplicate name key anywhere\n in the structure. character(kind=CK,len=:), intent(out), optional allocatable :: name the duplicate name\n (unallocated if no\n duplicates were found) character(kind=CK,len=:), intent(out), optional allocatable :: path the full path to the\n duplicate name\n (unallocated if no\n duplicate was found) private subroutine json_check_children_for_duplicate_keys (json, p, has_duplicate, name, path) Author Jacob Williams Date 8/25/2017 Checks a JSON object for duplicate child names. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p the object to search. If p is\n not a json_object , then has_duplicate will be false. logical(kind=LK), intent(out) :: has_duplicate true if there is at least\n two children have duplicate name values. character(kind=CK,len=:), intent(out), optional allocatable :: name the duplicate name\n (unallocated if no\n duplicate was found) character(kind=CK,len=:), intent(out), optional allocatable :: path the full path to the\n duplicate name\n (unallocated if no\n duplicate was found) private subroutine json_check_for_errors (json, status_ok, error_msg) Author Jacob Williams Date 12/4/2013 Retrieve error code from the json_core .\n  This should be called after parse to check for errors.\n  If an error is thrown, before using the class again, json_initialize should be called to clean up before it is used again. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) private pure subroutine json_clear_exceptions (json) Author Jacob Williams Date 12/4/2013 Clear exceptions in the json_core . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json private subroutine json_clone (json, from, to) Author Jacob Williams Date 10/31/2015 Create a deep copy of a json_value linked-list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: from this is the structure to clone type( json_value ), pointer :: to the clone is put here\n (it must not already be associated) private subroutine json_create_by_path (json, me, path, p, found, was_created) Returns the json_value pointer given the path string,\n  If necessary, by creating the variables as needed. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), optional pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if there were no errors\n (variable found or created) logical(kind=LK), intent(out), optional :: was_created true if it was actually created\n (as opposed to already being there) private subroutine json_get_alloc_string_vec (json, me, vec, ilen) Author Jacob Williams Date 12/16/2016 Get a string vector from a json_value . This is an alternate\n  version of json_get_string_vec . This one returns an allocatable\n  length character (where the string length is the maximum length of\n  any element in the array). It also returns an integer array of the\n  actual sizes of the strings in the JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array private subroutine json_get_alloc_string_vec_by_path (json, me, path, vec, ilen, found) Alternate version of json_get_alloc_string_vec where input is the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found private subroutine json_get_array (json, me, array_callback) This routine calls the user-supplied json_array_callback_func subroutine for each element in the array. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure( json_array_callback_func ) :: array_callback private subroutine json_get_array_by_path (json, me, path, array_callback, found) This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found private subroutine json_get_by_path (json, me, path, p, found) Returns the json_value pointer given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specified by path logical(kind=LK), intent(out), optional :: found true if it was found private subroutine json_get_by_path_default (json, me, path, p, found, create_it, was_created) Returns the json_value pointer given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found logical(kind=LK), intent(in), optional :: create_it if a variable is not present\n in the path, then it is created.\n the leaf node is returned as\n a null json type and can be\n changed by the caller. logical(kind=LK), intent(out), optional :: was_created if create_it is true, this\n will be true if the variable\n was actually created. Otherwise\n it will be false. private subroutine json_get_by_path_jsonpath_bracket (json, me, path, p, found, create_it, was_created) Author Jacob Williams Date 9/2/2017 Returns the json_value pointer given the path string,\n  using the \" JSON Pointer\" path specification defined by the\n  JSONPath \"bracket-notation\". Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable\n (using JSONPath\n \"bracket-notation\") type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found logical(kind=LK), intent(in), optional :: create_it if a variable is not present\n in the path, then it is created.\n the leaf node is returned as\n a null json type and can be\n changed by the caller. logical(kind=LK), intent(out), optional :: was_created if create_it is true, this\n will be true if the variable\n was actually created. Otherwise\n it will be false. private subroutine json_get_by_path_rfc6901 (json, me, path, p, found) Author Jacob Williams Date 2/4/2017 Returns the json_value pointer given the path string,\n  using the \" JSON Pointer\" path specification defined by RFC 6901. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable\n (an RFC 6901 \" JSON Pointer\") type( json_value ), intent(out), pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if it was found private subroutine json_get_double (json, me, value) Get a double value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out) :: value private subroutine json_get_double_by_path (json, me, path, value, found) Get a double value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_double_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a double vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_double_vec_by_path (json, me, path, vec, found) Get a double vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_integer (json, me, value) Get an integer value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value private subroutine json_get_integer_by_path (json, me, path, value, found) Get an integer value from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_integer_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get an integer vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_integer_vec_by_path (json, me, path, vec, found) Get an integer vector from a json_value , given the path string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_logical (json, me, value) Get a logical value from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out) :: value private subroutine json_get_logical_by_path (json, me, path, value, found) Get a logical value from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_logical_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a logical vector from json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_logical_vec_by_path (json, me, path, vec, found) Get a logical vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_next (json, p, next) Author Jacob Williams Date 10/31/2015 Returns a pointer to the next of a json_value .\n  If there is no next, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next private subroutine json_get_parent (json, p, parent) Author Jacob Williams Date 10/16/2015 Returns a pointer to the parent of a json_value .\n  If there is no parent, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent private subroutine json_get_path (json, p, path, found, use_alt_array_tokens, path_sep) Returns the path to a JSON object that is part\n  of a linked list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list object character(kind=CK,len=:), intent(out), allocatable :: path path to the variable logical(kind=LK), intent(out), optional :: found true if there were no problems logical(kind=LK), intent(in), optional :: use_alt_array_tokens if true, then '()' are used for array elements\n otherwise, '[]' are used [default]\n (only used if path_mode=1 ) character(kind=CK,len=1), intent(in), optional :: path_sep character to use for path separator\n (otherwise use json%path_separator )\n (only used if path_mode=1 ) private subroutine json_get_previous (json, p, previous) Author Jacob Williams Date 10/31/2015 Returns a pointer to the previous of a json_value .\n  If there is no previous, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous private subroutine json_get_string (json, me, value) Get a character string from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value private subroutine json_get_string_by_path (json, me, path, value, found) Get a character string from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_string_vec (json, me, vec) Author Jacob Williams Date 5/14/2014 Get a string vector from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_get_string_vec_by_path (json, me, path, vec, found) Get a string vector from a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_tail (json, p, tail) Author Jacob Williams Date 10/31/2015 Returns a pointer to the tail of a json_value (the last child of an array of object).\n  If there is no tail, then a null() pointer is returned. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail private subroutine json_info (json, p, var_type, n_children, name) Author Jacob Williams Date 2/13/2014 Returns information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_info_by_path (json, p, path, found, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_initialize (me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys, no_whitespace, unescape_strings, comment_char, path_mode, path_separator, compress_vectors, allow_duplicate_keys, escape_solidus, stop_on_error) Author Jacob Williams Date 12/4/2013 Initialize the json_core instance. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant.\n (default is false) logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. (default is true) logical(kind=LK), intent(in), optional :: no_whitespace if true, printing the JSON structure is\n done without adding any non-significant\n spaces or linebreaks (default is false) logical(kind=LK), intent(in), optional :: unescape_strings If false, then the raw escaped\n string is returned from json_get_string and similar routines. If true [default],\n then the string is returned unescaped. character(kind=CK,len=1), intent(in), optional :: comment_char If present, this character is used\n to denote comments in the JSON file,\n which will be ignored if present.\n Example: ! or # . Setting this\n to a blank string disables the\n ignoring of comments. (Default is ! ). integer(kind=IK), intent(in), optional :: path_mode How the path strings are interpreted in the get_by_path routines:\n * 1 – Default mode (see json_get_by_path_default )\n * 2 – as RFC 6901 \" JSON Pointer\" paths\n   (see json_get_by_path_rfc6901 )\n * 3 – JSONPath \"bracket-notation\"\n   see json_get_by_path_jsonpath_bracket ) character(kind=CK,len=1), intent(in), optional :: path_separator The path separator to use\n in the \"default\" mode for\n the paths in the various get_by_path routines.\n Example: . [default] or % .\n Note: if path_mode/=1 then this is ignored. logical(kind=LK), intent(in), optional :: compress_vectors If true, then arrays of integers,\n nulls, doubles, and logicals are\n printed all on one line.\n [Note: no_whitespace will\n override this option if necessary].\n (Default is False). logical(kind=LK), intent(in), optional :: allow_duplicate_keys logical(kind=LK), intent(in), optional :: escape_solidus logical(kind=LK), intent(in), optional :: stop_on_error If an exception is raised, then immediately quit.\n (Default is False). private subroutine json_matrix_info (json, p, is_matrix, var_type, n_sets, set_size, name) Author Jacob Williams Date 10/16/2015 Alternate version of json_info that returns matrix\n  information about a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix integer(kind=IK), intent(out), optional :: var_type variable type of data in the matrix\n (if all elements have the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_matrix_info_by_path (json, p, path, is_matrix, found, var_type, n_sets, set_size, name) Returns matrix information about a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine json_parse_file (json, file, p, unit) Parse the JSON file and populate the json_value tree. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) private subroutine json_parse_string (json, p, str) Parse the JSON string and populate the json_value tree. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data private subroutine json_print_1 (json, p, iunit) Author Jacob Williams Date 6/20/2014 Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must\n already have been opened, can't be -1). private subroutine json_print_2 (json, p, filename) Author Jacob Williams Date 12/23/2014 Print the json_value structure to a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to\n (should not already be open) private subroutine json_print_error_message (json, io_unit) Author Jacob Williams Print any error message, and then clear the exceptions. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit private subroutine json_rename_by_path (json, me, path, name, found) Rename a json_value , given the path. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: name the new name logical(kind=LK), intent(out), optional :: found private subroutine json_rename_by_path_name_ascii (json, me, path, name, found) Alternate version of json_rename_by_path , where \"name\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(out), optional :: found private subroutine json_rename_by_path_path_ascii (json, me, path, name, found) Alternate version of json_rename_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(out), optional :: found private subroutine json_string_info (json, p, ilen, max_str_len, found) Author Jacob Williams Date 12/18/2016 Returns information about character strings returned from a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(out), optional dimension(:), allocatable :: ilen if p is an array, this\n is the actual length\n of each character\n string in the array.\n if not an array, this\n is returned unallocated. integer(kind=IK), intent(out), optional :: max_str_len The maximum length required to\n hold the string representation returned\n by a call to a get routine. If a scalar,\n this is just the length of the scalar. If\n a vector, this is the maximum length of\n any element. logical(kind=LK), intent(out), optional :: found true if there were no errors.\n if not present, an error will\n throw an exception private subroutine json_throw_exception (json, msg) Author Jacob Williams Date 12/4/2013 Throw an exception in the json_core .\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message private subroutine json_traverse (json, p, traverse_callback) Author Jacob Williams Date 4/28/2016 Traverse a JSON structure.\n  This routine calls the user-specified json_traverse_callback_func for each element of the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure( json_traverse_callback_func ) :: traverse_callback private subroutine json_update_double (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_integer (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_logical (json, p, path, val, found) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_string (json, p, path, val, found, trim_str, adjustl_str) Author Jacob Williams Date 12/6/2014 Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) private subroutine json_update_string_name_ascii (json, p, path, val, found, trim_str, adjustl_str) Alternate version of json_update_string , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) private subroutine json_update_string_val_ascii (json, p, path, val, found, trim_str, adjustl_str) Alternate version of json_update_string , where val is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) private subroutine json_value_add_double (json, p, name, val) Author Jacob Williams Date 1/19/2014 Add a real value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value private subroutine json_value_add_double_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a real vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val private subroutine json_value_add_integer (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add an integer value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val private subroutine json_value_add_integer_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add an integer vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value private subroutine json_value_add_logical (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a logical value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value private subroutine json_value_add_logical_vec (json, p, name, val) Author Jacob Williams Date 1/20/2014 Add a logical vector to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value private subroutine json_value_add_member (json, p, member) Adds member as a child of p . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p type( json_value ), pointer :: member the child member\n to add to p private subroutine json_value_add_null (json, p, name) Add a NULL value child to the json_value variable Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name private subroutine json_value_add_string (json, p, name, val, trim_str, adjustl_str) Author Jacob Williams Date 1/19/2014 Add a character string child to the json_value variable. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private subroutine json_value_add_string_name_ascii (json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private subroutine json_value_add_string_val_ascii (json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string where val is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private subroutine json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Author Jacob Williams Date 1/19/2014 Add an array of character strings to the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine json_value_add_string_vec_name_ascii (json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str private subroutine json_value_add_string_vec_val_ascii (json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string_vec where val is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str private recursive subroutine json_value_clone_func (from, to, parent, previous, next, children, tail) Author Jacob Williams Date 10/31/2015 Recursive deep copy function called by json_clone . Arguments Type Intent Optional Attributes Name type( json_value ), pointer :: from this is the structure to clone type( json_value ), pointer :: to the clone is put here (it\n must not already be associated) type( json_value ), optional pointer :: parent to%parent type( json_value ), optional pointer :: previous to%previous type( json_value ), optional pointer :: next to%next type( json_value ), optional pointer :: children to%children logical, optional :: tail if \"to\" is the tail of\n its parent's children private subroutine json_value_create (p) Allocate a json_value pointer variable.\n  This should be called before adding data to it. Arguments Type Intent Optional Attributes Name type( json_value ), pointer :: p private subroutine json_value_create_array (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name private subroutine json_value_create_double (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name private subroutine json_value_create_integer (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name private subroutine json_value_create_logical (json, p, val, name) Author Jacob Williams Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name private subroutine json_value_create_null (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name private subroutine json_value_create_object (json, p, name) Author Jacob Williams Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name private subroutine json_value_create_string (json, p, val, name, trim_str, adjustl_str) Author Jacob Williams Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private recursive subroutine json_value_destroy (json, p, destroy_next) Author Jacob Williams Date 1/22/2014 Destroy a json_value linked-list structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) private subroutine json_value_get_child (json, p, child) Returns pointer to the first child of the object\n  (or null() if it is not associated). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), pointer :: child pointer to the child private subroutine json_value_get_child_by_index (json, p, idx, child, found) Returns a child in the object or array given the index. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child\n (this is a 1-based Fortran\n style array index). type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). private subroutine json_value_get_child_by_name (json, p, name, child, found) Returns a child in the object or array given the name string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), pointer :: child pointer to the child logical(kind=LK), intent(out), optional :: found true if the value was found\n (if not present, an exception\n will be thrown if it was not\n found.  If present and not\n found, no exception will be\n thrown). private subroutine json_value_insert_after (json, p, element) Inserts element after p , and updates the JSON structure accordingly. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a value from a JSON structure\n (presumably, this is a child of\n an object or array). type( json_value ), pointer :: element the element to insert after p private subroutine json_value_insert_after_child_by_index (json, p, idx, element) Inserts element after the idx -th child of p ,\n  and updates the JSON structure accordingly. This is just\n  a wrapper for json_value_insert_after . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON object or array. integer(kind=IK), intent(in) :: idx the index of the child of p to\n insert the new element after\n (this is a 1-based Fortran\n style array index) type( json_value ), pointer :: element the element to insert private recursive subroutine json_value_print (json, p, iunit, str, indent, need_comma, colon, is_array_element, is_compressed_vector) Print the JSON structure to a string or a file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element logical(kind=LK), intent(in), optional :: is_compressed_vector if True, this is an element\n from an array being printed\n on one line [default is False] private subroutine json_value_remove (json, p, destroy) Author Jacob Williams Date 9/9/2014 Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. private subroutine json_value_remove_if_present (json, p, name) Author Jacob Williams Date 12/6/2014 Given the path string, remove the variable from\n  the json_value structure, if it exists. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in) :: name private subroutine json_value_rename (json, p, name) Author Jacob Williams Date 4/29/2016 Rename a json_value . Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name private subroutine json_value_replace (json, p1, p2, destroy) Replace p1 with p2 in a JSON structure. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 the item to replace type( json_value ), pointer :: p2 item to take the place of p1 logical(kind=LK), intent(in), optional :: destroy Should p1 also be destroyed\n (default is True). Normally,\n this should be true to avoid\n a memory leak. private subroutine json_value_reverse (json, p) Author Jacob Williams Date 4/11/2017 Reverse the order of the children of an array or object. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p private subroutine json_value_swap (json, p1, p2) Author Jacob Williams Date 4/26/2016 Swap two elements in a JSON structure.\n  All of the children are carried along as well. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p1 type( json_value ), pointer :: p2 private subroutine json_value_to_string (json, p, str) Author Jacob Williams Date 2/12/2014 Print the json_value structure to an allocatable string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string private subroutine json_value_validate (json, p, is_valid, error_msg) Author Jacob Williams Date 5/2/2016 Validate a json_value linked list by checking to make sure\n  all the pointers are properly associated, arrays and objects\n  have the correct number of children, and the correct data is\n  allocated for the variable types. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), intent(out), allocatable :: error_msg if not valid, this will contain\n a description of the problem private recursive subroutine parse_array (json, unit, str, array) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: array private subroutine parse_for_chars (json, unit, str, chars) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. private subroutine parse_number (json, unit, str, value) Author Jacob Williams Date 1/20/2014 Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: value private recursive subroutine parse_object (json, unit, str, parent) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), pointer :: parent the parsed object will be added as a child of this private subroutine parse_string (json, unit, str, string) Parses a string while reading a JSON file. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string the string (unescaped if necessary) private recursive subroutine parse_value (json, unit, str, value) Core parsing routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), pointer :: value JSON data that is extracted private recursive subroutine pop_char (json, unit, str, skip_ws, skip_comments, eof, popped) Get the next character from the file (or string). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer(kind=IK), intent(in) :: unit file unit number (if parsing\n from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a\n string) – only used if unit=0 logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace [default False] logical(kind=LK), intent(in), optional :: skip_comments to ignore comment lines [default False] logical(kind=LK), intent(out) :: eof true if the end of the file has\n been reached. character(kind=CK,len=1), intent(out) :: popped the popped character returned private subroutine push_char (json, c) Core routine. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=1), intent(in) :: c to character to push private subroutine to_array (json, p, name) Author Jacob Williams Change the json_value variable to an array. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. private subroutine to_double (json, p, val, name) Author Jacob Williams Change the json_value variable to a double. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in), optional :: val if the value is also to be set\n (if not present, then 0.0_rk is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. private subroutine to_integer (json, p, val, name) Author Jacob Williams Change the json_value variable to an integer. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in), optional :: val if the value is also to be set\n (if not present, then 0 is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. private subroutine to_logical (json, p, val, name) Author Jacob Williams Change the json_value variable to a logical. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in), optional :: val if the value is also to be set\n (if not present, then .false. is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. private subroutine to_null (json, p, name) Author Jacob Williams Change the json_value variable to a null. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. private subroutine to_object (json, p, name) Author Jacob Williams Change the json_value variable to an object. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. private subroutine to_string (json, p, val, name, trim_str, adjustl_str) Author Jacob Williams Change the json_value variable to a string. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CK,len=*), intent(in), optional :: val if the value is also to be set\n (if not present, then '' is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) private subroutine wrap_json_add_double_by_path (json, me, path, value, found, was_created) Wrapper to json_add_double_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_double_vec_by_path (json, me, path, value, found, was_created) Wrapper for json_add_double_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable real(kind=RK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_integer_by_path (json, me, path, value, found, was_created) Wrapper to json_add_integer_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_integer_vec_by_path (json, me, path, value, found, was_created) Wrapper for json_add_integer_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_logical_by_path (json, me, path, value, found, was_created) Wrapper to json_add_logical_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_logical_vec_by_path (json, me, path, value, found, was_created) Wrapper for json_add_logical_vec_by_path where \"path\" is kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable logical(kind=LK), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_member_by_path (json, me, path, p, found, was_created) Wrapper to json_add_member_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(in), pointer :: p the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created private subroutine wrap_json_add_string_by_path (json, me, path, value, found, was_created, trim_str, adjustl_str) Wrapper to json_add_string_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in) :: value the value to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine wrap_json_add_string_vec_by_path (json, me, path, value, found, was_created, ilen, trim_str, adjustl_str) Wrapper for json_add_string_vec_by_path where \"path\" and \"value\" are kind=CDK). Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me the JSON structure character(kind=CDK,len=*), intent(in) :: path the path to the variable character(kind=CDK,len=*), intent(in), dimension(:) :: value the vector to add logical(kind=LK), intent(out), optional :: found if the variable was found logical(kind=LK), intent(out), optional :: was_created if the variable had to be created integer(kind=IK), intent(in), optional dimension(:) :: ilen the string lengths of each\n element in value . If not present,\n the full len(value) string is added\n for each element. logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element private subroutine wrap_json_create_by_path (json, me, path, p, found, was_created) Alternate version of json_create_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), optional pointer :: p pointer to the variable\n specify by path logical(kind=LK), intent(out), optional :: found true if there were no errors\n (variable found or created) logical(kind=LK), intent(out), optional :: was_created true if it was actually created\n (as opposed to already being there) private subroutine wrap_json_get_alloc_string_vec_by_path (json, me, path, vec, ilen, found) Alternate version of json_get_alloc_string_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), dimension(:), allocatable :: vec integer(kind=IK), intent(out), dimension(:), allocatable :: ilen the actual length\n of each character\n string in the array logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_array_by_path (json, me, path, array_callback, found) Alternate version of json_get_array_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( json_array_callback_func ) :: array_callback logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_by_path (json, me, path, p, found) Alternate version of json_get_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_double_by_path (json, me, path, value, found) Alternate version of json_get_double_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_double_vec_by_path (json, me, path, vec, found) Alternate version of json_get_double_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_integer_by_path (json, me, path, value, found) Alternate version of json_get_integer_by_path , where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_integer_vec_by_path (json, me, path, vec, found) Alternate version of json_get_integer_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_logical_by_path (json, me, path, value, found) Alternate version of json_get_logical_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_logical_vec_by_path (json, me, path, vec, found) Alternate version of json_get_logical_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_path (json, p, path, found, use_alt_array_tokens, path_sep) Wrapper for json_get_path where \"path\" and \"path_sep\" are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list object character(kind=CDK,len=:), intent(out), allocatable :: path path to the variable logical(kind=LK), intent(out), optional :: found true if there were no problems logical(kind=LK), intent(in), optional :: use_alt_array_tokens if true, then '()' are used for array elements\n otherwise, '[]' are used [default] character(kind=CDK,len=1), intent(in), optional :: path_sep character to use for path separator\n (default is '.') private subroutine wrap_json_get_string_by_path (json, me, path, value, found) Alternate version of json_get_string_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_get_string_vec_by_path (json, me, path, vec, found) Alternate version of json_get_string_vec_by_path , where \"path\" is kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_info_by_path (json, p, path, found, var_type, n_children, name) Alternate version of json_info_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine wrap_json_matrix_info_by_path (json, p, path, is_matrix, found, var_type, n_sets, set_size, name) Alternate version of json_matrix_info_by_path where \"path\" is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p a JSON linked list character(kind=CDK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: is_matrix true if it is a valid matrix logical(kind=LK), intent(out), optional :: found true if it was found integer(kind=IK), intent(out), optional :: var_type variable type of data in\n the matrix (if all elements have\n the same type) integer(kind=IK), intent(out), optional :: n_sets number of data sets (i.e., matrix\n rows if using row-major order) integer(kind=IK), intent(out), optional :: set_size size of each data set (i.e., matrix\n cols if using row-major order) character(kind=CK,len=:), intent(out), optional allocatable :: name variable name private subroutine wrap_json_parse_string (json, p, str) Alternate version of json_parse_string , where str is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data private subroutine wrap_json_rename_by_path (json, me, path, name, found) Alternate version of json_rename_by_path , where \"path\" and \"name\" are kind=CDK Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_throw_exception (json, msg) Alternate version of json_throw_exception , where msg is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: msg the error message private subroutine wrap_json_update_double (json, p, path, val, found) Alternate version of json_update_double , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine wrap_json_update_integer (json, p, path, val, found) Alternate version of json_update_integer , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine wrap_json_update_logical (json, p, path, val, found) Alternate version of json_update_logical , where path is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine wrap_json_update_string (json, p, path, val, found, trim_str, adjustl_str) Alternate version of json_update_string , where path and value are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: path character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val (only used if val is present) logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val (only used if val is present)\n (note that ADJUSTL is done before TRIM) private subroutine wrap_json_value_add_double (json, p, name, val) Alternate version of json_value_add_double where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value private subroutine wrap_json_value_add_double_vec (json, p, name, val) Alternate version of json_value_add_double_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val private subroutine wrap_json_value_add_integer (json, p, name, val) Alternate version of json_value_add_integer where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value private subroutine wrap_json_value_add_integer_vec (json, p, name, val) Alternate version of json_value_add_integer_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value private subroutine wrap_json_value_add_logical (json, p, name, val) Alternate version of json_value_add_logical where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value private subroutine wrap_json_value_add_logical_vec (json, p, name, val) Alternate version of json_value_add_logical_vec where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value private subroutine wrap_json_value_add_null (json, p, name) Alternate version of json_value_add_null where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable private subroutine wrap_json_value_add_string (json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string where name and val are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private subroutine wrap_json_value_add_string_vec (json, p, name, val, trim_str, adjustl_str) Alternate version of json_value_add_string_vec where name and val are kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str private subroutine wrap_json_value_create_array (json, p, name) Author Izaak Beekman A wrapper for json_value_create_array so that create_array method may be\n  called with an actual argument, corresponding to the dummy argument name ,\n  that is either of 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_create_double (json, p, val, name) Author Izaak Beekman A wrapper for json_value_create_double so that create_double method\n  may be called with an actual argument corresponding to the dummy argument, name that may be of 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_create_integer (json, p, val, name) Author Izaak Beekman A wrapper procedure for json_value_create_integer so that create_integer method may be called with either a 'DEFAULT' or 'ISO_10646' character kind name actual argument. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_create_logical (json, p, val, name) Author Izaak Beekman Wrapper for json_value_create_logical so create_logical method can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_create_null (json, p, name) Author Izaak Beekman Wrap json_value_create_null so that create_null method may be called with\n  an actual argument corresponding to the dummy argument name that is either\n  of 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_create_object (json, p, name) Author Izaak Beekman Wrap json_value_create_object so that create_object method may be called\n  with an actual argument corresponding to the dummy argument name that is of\n  either 'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_create_string (json, p, val, name, trim_str, adjustl_str) Author Izaak Beekman Wrap json_value_create_string so that create_string method may be called\n  with actual character string arguments for name and val that are BOTH of\n  'DEFAULT' or 'ISO_10646' character kind. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for the val logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for the val private subroutine wrap_json_value_get_child_by_name (json, p, name, child, found) Alternate version of json_value_get_child_by_name where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name type( json_value ), pointer :: child logical(kind=LK), intent(out), optional :: found private subroutine wrap_json_value_remove_if_present (json, p, name) Alternate version of json_value_remove_if_present , where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), pointer :: p character(kind=CDK,len=*), intent(in) :: name private subroutine wrap_json_value_rename (json, p, name) Author Jacob Williams Date 4/29/2016 Alternate version of json_value_rename , where name is kind=CDK. Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: name new variable name","title":"json_value_module – JSON-Fortran","tags":"","loc":"module/json_value_module.html"}]}