var tipuesearch = {"pages":[{"text":"Fortran Program project: JSON -Fortran\nfavicon: ./media/json-fortran-32x32.png\nproject_dir: ./src\noutput_dir: ./doc\nmedia_dir: ./media\nproject_github: https://github.com/jacobwilliams/json-fortran\nproject_download: https://github.com/jacobwilliams/json-fortran/releases/latest\nsummary: JSON -Fortran -- A Fortran 2008 JSON API author: Jacob Williams\ngithub: https://github.com/jacobwilliams\nwebsite: http://degenerateconic.com\ntwitter: https://twitter.com/degenerateconic\npredocmark_alt: >\npredocmark: <\ndocmark_alt:\ndocmark: !\ndisplay: public\n         protected\n         private\nsource: true\ngraph: true\nexclude_dir: tests\nextra_mods: iso_fortran_env:https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html\nmd_extensions: markdown.extensions.toc(anchorlink=False)\n               markdown.extensions.smarty(smart_quotes=False) [TOC] Brief description A user-friendly, thread-safe, and object-oriented API for reading and writing JSON files, written in modern Fortran. License The JSON -Fortran source code and related files and documentation are\ndistributed under a permissive free software license (BSD-style).  See\nthe LICENSE file for more details. Official Releases The current stable release is 5.0.0 and can be downloaded\non GitHub or installed with Homebrew on Mac OSX. The\ndocumentation for the current version, 5.0.0 , can be\nfound here 1 , and a\nlist of changes from the previous version are here . A list of all past releases, links to their documentation, and the\nchange log can be found on the releases page . Miscellaneous For more information about JSON , see: http://www.json.org/ Documentation for a particular release does not contain links\nback to general documentation; use the browser's back button to\nnavigate back to http://jacobwilliams.github.io/json-fortran/ ↩","tags":"","loc":"index.html","title":" Fortran Program "},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Higher-level [[json_file]] interface for the [[json_value]] type. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_file_module use , intrinsic :: iso_fortran_env use json_kinds use json_parameters , only : unit2str use json_string_utilities use json_value_module implicit none private #include \"json_macros.inc\" !********************************************************* !> author: Jacob Williams !  date: 12/9/2013 ! !  The `json_file` is the main public class that is !  used to open a file and get data from it. ! !  A `json_file` contains only two items: an instance of a [[json_core]], !  which use used for all data manipulation, and a [[json_value]], !  which is used to construct the linked-list data structure. !  Note that most methods in the `json_file` class are simply wrappers !  to the lower-level routines in the [[json_value_module]]. ! !# Example ! !```fortran !    program test !    use json_module !    implicit none !    type(json_file) :: json !    integer :: ival !    real(real64) :: rval !    character(len=:),allocatable :: cval !    logical :: found !    call json%initialize(compact_reals=.true.) !    call json%load_file(filename='myfile.json') !    call json%print_file() !print to the console !    call json%get('var.i',ival,found) !    call json%get('var.r(3)',rval,found) !    call json%get('var.c',cval,found) !    call json%destroy() !    end program test !``` type , public :: json_file private type ( json_core ) :: json !! the instance of the [[json_core]] factory used for this file type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains procedure , public :: initialize => initialize_json_core_in_file procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) !error checking: procedure , public :: failed => json_file_failed procedure , public :: print_error_message => json_file_print_error_message procedure , public :: check_for_errors => json_file_check_for_errors procedure , public :: clear_exceptions => json_file_clear_exceptions procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & json_file_get_root generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #endif !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !git info: procedure :: MAYBEWRAP ( json_file_variable_info ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: json_file_get_root !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file !********************************************************* !********************************************************* !> author: Izaak Beekman !  date: 07/23/2015 ! !  Structure constructor to initialize a [[json_file(type)]] object !  with an existing [[json_value]] object, and either the [[json_core]] !  settings or a [[json_core]] instance. ! !# Example ! !```fortran ! ... ! type(json_file)  :: my_file ! type(json_value),pointer :: json_object ! type(json_core) :: json_core_object ! ... ! ! Construct a json_object: ! !could do this: !   my_file = json_file(json_object) ! !or: !   my_file = json_file(json_object,verbose=.true.) ! !or: !   my_file = json_file(json_object,json_core_object) !``` interface json_file module procedure initialize_json_file , initialize_json_file_v2 end interface !************************************************************************************* contains !***************************************************************************************** !***************************************************************************************** !> !  Check error status in the file. pure function json_file_failed ( me ) result ( failed ) implicit none class ( json_file ), intent ( in ) :: me logical ( LK ) :: failed !! will be true if there has been an error. failed = me % json % failed () end function json_file_failed !***************************************************************************************** !***************************************************************************************** !> !  Retrieve error status and message from the class. subroutine json_file_check_for_errors ( me , status_ok , error_msg ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) call me % json % check_for_errors ( status_ok , error_msg ) end subroutine json_file_check_for_errors !***************************************************************************************** !***************************************************************************************** !> !  Clear exceptions in the class. pure subroutine json_file_clear_exceptions ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % json % clear_exceptions () end subroutine json_file_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> !  This is a wrapper for [[json_print_error_message]]. subroutine json_file_print_error_message ( me , io_unit ) implicit none class ( json_file ), intent ( inout ) :: me integer , intent ( in ), optional :: io_unit call me % json % print_error_message ( io_unit ) end subroutine json_file_print_error_message !***************************************************************************************** !***************************************************************************************** !> !  Initialize the [[json_core]] for this [[json_file]]. !  This is just a wrapper for [[json_initialize]]. ! !@note: This does not destroy the data in the file. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. subroutine initialize_json_core_in_file ( me , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) implicit none class ( json_file ), intent ( inout ) :: me logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call me % json % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) end subroutine initialize_json_core_in_file !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 07/23/2015 ! !  Cast a [[json_value]] object as a [[json_file(type)]] object. !  It also calls the `initialize()` method. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. function initialize_json_file ( p , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call file_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) if ( present ( p )) file_object % p => p end function initialize_json_file !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Cast a [[json_value]] pointer and a [[json_core]] object !  as a [[json_file(type)]] object. function initialize_json_file_v2 ( json_value_object , json_core_object ) & result ( file_object ) implicit none type ( json_file ) :: file_object type ( json_value ), pointer , intent ( in ) :: json_value_object type ( json_core ), intent ( in ) :: json_core_object file_object % p => json_value_object file_object % json = json_core_object end function initialize_json_file_v2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the [[json_value]] data in a [[json_file(type)]]. !  This must be done when the variable is no longer needed, !  or will be reused to open a different file. !  Otherwise a memory leak will occur. ! !  Optionally, also destroy the [[json_core]] instance (this !  is not necessary to prevent memory leaks, since a [[json_core]] !  does not use pointers). ! !### History !  * 12/9/2013 : Created !  * 4/26/2016 : Added optional `destroy_core` argument subroutine json_file_destroy ( me , destroy_core ) implicit none class ( json_file ), intent ( inout ) :: me logical , intent ( in ), optional :: destroy_core !! to also destroy the [[json_core]]. !! default is to leave it as is. if ( associated ( me % p )) call me % json % destroy ( me % p ) if ( present ( destroy_core )) then if ( destroy_core ) call me % json % destroy () end if end subroutine json_file_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2014 ! !  Move the [[json_value]] pointer from one [[json_file(type)]] to another. !  The \"from\" pointer is then nullified, but not destroyed. ! !@note If \"from%p\" is not associated, then an error is thrown. subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then if ( from % failed ()) then !Don't get the data if the FROM file has an !active exception, since it may not be valid. call to % json % throw_exception ( 'Error in json_file_move_pointer: ' // & 'error exception in FROM file.' ) else call to % initialize () !initialize and clear any exceptions that may be present to % p => from % p nullify ( from % p ) end if else call to % json % throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Load the JSON data from a file. ! !# Example ! !```fortran !     program main !      use json_module !      implicit none !      type(json_file) :: f !      call f%load_file('my_file.json') !      !... !      call f%destroy() !     end program main !``` subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use (if not present, a newunit is used) call me % json % parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/13/2015 ! !  Load the JSON data from a string. ! !# Example ! !  Load JSON from a string: !```fortran !     type(json_file) :: f !     call f%load_from_string('{ \"name\": \"Leonidas\" }') !``` subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call me % json % parse ( str = str , p = me % p ) end subroutine json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_load_from_string]], where \"str\" is kind=CDK. subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call me % load_from_string ( to_unicode ( str )) end subroutine wrap_json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to the console. subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me call me % json % print ( me % p , iunit = output_unit ) end subroutine json_file_print_to_console !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Prints the JSON file to the specified file unit number. subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) if ( iunit /= unit2str ) then call me % json % print ( me % p , iunit = iunit ) else call me % json % throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON structure to the specified filename. !  The file is opened, printed, and then closed. ! !# Example !  Example loading a JSON file, changing a value, and then printing !  result to a new file: !```fortran !     type(json_file) :: f !     logical :: found !     call f%load_file('my_file.json')    !open the original file !     call f%update('version',4,found)    !change the value of a variable !     call f%print_file('my_file_2.json') !save file as new name !``` subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to call me % json % print ( me % p , filename ) end subroutine json_file_print_2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to a string. ! !# Example ! !  Open a JSON file, and then print the contents to a string: !```fortran !     type(json_file) :: f !     character(kind=CK,len=:),allocatable :: str !     call f%load_file('my_file.json') !     call f%print_file(str) !``` subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call me % json % print_to_string ( me % p , str ) end subroutine json_file_print_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Returns information about a variable in a [[json_file(type)]]. subroutine json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: found !! the variable exists in the structure integer ( IK ), intent ( out ) :: var_type !! variable type integer ( IK ), intent ( out ) :: n_children !! number of children type ( json_value ), pointer :: p !initialize: nullify ( p ) !get a pointer to the variable (if it is there): call me % get ( path , p , found ) if ( found ) then !get info: call me % json % info ( p , var_type , n_children ) else !set to dummy values: var_type = json_unknown n_children = 0 end if !cleanup: nullify ( p ) end subroutine json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_variable_info]], where \"path\" is kind=CDK. subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: found integer ( IK ), intent ( out ) :: var_type integer ( IK ), intent ( out ) :: n_children call me % info ( to_unicode ( path ), found , var_type , n_children ) end subroutine wrap_json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 7/23/2015 ! !  Get a [[json_value]] pointer to the JSON file root. ! !@note This is equivalent to calling ```[[json_file]]%get('$',p)``` subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Get a [[json_value]] pointer to an object from a JSON file. subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % json % get ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_object]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get an integer value from a JSON file. subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % json % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get an integer vector from a JSON file. subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call me % json % get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a real(RK) variable value from a JSON file. subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % json % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a real(RK) vector from a JSON file. subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % json % get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a logical(LK) value from a JSON file. subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % json % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get a logical(LK) vector from a JSON file. subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % json % get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a character string from a json file. !  The output val is an allocatable character string. subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % json % get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a string vector from a JSON file. subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % json % get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call me % get ( to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_integer]] subroutine json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % json % failed ()) call me % json % update ( me % p , name , val , found ) end subroutine json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_integer]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_logical]] subroutine json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % json % failed ()) call me % json % update ( me % p , name , val , found ) end subroutine json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_logical]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_double]] subroutine json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % json % failed ()) call me % json % update ( me % p , name , val , found ) end subroutine json_file_update_real !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_real]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_real !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_string]] subroutine json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . me % json % failed ()) call me % json % update ( me % p , name , val , found ) end subroutine json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"name\" and \"val\" are kind=CDK. subroutine wrap_json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"name\" is kind=CDK. subroutine json_file_update_string_name_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( to_unicode ( name ), val , found ) end subroutine json_file_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"val\" is kind=CDK. subroutine json_file_update_string_val_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call me % update ( name , to_unicode ( val ), found ) end subroutine json_file_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** end module json_file_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_file_module.f90.html","title":"json_file_module.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  JSON-Fortran kind definitions. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. ! !@note ```-DUSE_UCS4``` is an optional preprocessor flag. !      When present, Unicode support is enabled. Note that this !      is currently only supported with the gfortran compiler. !      Example: ```gfortran -DUSE_UCS4 ... ``` #ifdef USE_UCS4 #  pragma push_macro(\"USE_UCS4\") #  undef USE_UCS4 !      The documentation given here assumes ```USE_UCS4``` **is** defined. #  pragma pop_macro(\"USE_UCS4\") #else !      The documentation given here assumes ```USE_UCS4``` **is not** defined. #endif ! !@warning ```CK``` and ```CDK``` are the JSON-Fortran character kind and JSON-Fortran default !         character kind respectively. Client code **MUST** ensure characters of ```kind=CK``` !         are used for all character variables and strings passed to the JSON-Fortran !         library *EXCEPT* for file names which must be of ```'DEFAULT'``` character kind, !         provided here as ```CDK```. In particular, any variable that is a: json path, string !         value or object name passed to the JSON-Fortran library **MUST** be of type ```CK```. ! !@note Most string literal constants of default kind are fine to pass as arguments to !      JSON-Fortran procedures since they have been overloaded to accept ```intent(in)``` !      character arguments of the default (```CDK```) kind. If you find a procedure which does !      not accept an ```intent(in)``` literal string argument of default kind, please !      [file an issue](https://github.com/jacobwilliams/json-fortran/issues/new) on GitHub. module json_kinds use , intrinsic :: iso_fortran_env , only : real64 , int32 , logical_kinds implicit none private integer , parameter , public :: RK = real64 !! Default real kind [8 bytes] integer , parameter , public :: IK = int32 !! Default integer kind [4 bytes]. !********************************************************* !> !  Processor dependendant 'DEFAULT' character kind. !  This is 1 byte for the Intel and Gfortran compilers. integer , parameter , public :: CDK = selected_char_kind ( 'DEFAULT' ) !********************************************************* !********************************************************* !> !  Default logical kind. !  This is 4 bytes for the Intel and Gfortran compilers !  (and perhaps others). !  The declaration ensures a valid kind !  if the compiler doesn't have a logical_kinds(3). ! integer , parameter , public :: LK = logical_kinds ( min ( 3 , size ( logical_kinds ))) !********************************************************* !********************************************************* !> !  String kind preprocessor macro. ! #if defined __GFORTRAN__ && defined USE_UCS4 ! gfortran compiler AND UCS4 support requested: character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'ISO_10646' #else ! this is the string kind to use unless compiling with GFortran AND ! UCS4/ISO 10646 support is requested character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'DEFAULT' #endif !********************************************************* !********************************************************* !> !  Default character kind used by JSON-Fortran. !  If ISO 10646 (UCS4) support is available, use that, !  otherwise, gracefully fall back on 'DEFAULT' characters. !  Currently only gfortran >= 4.9.2 will correctly support !  UCS4 which is stored in 4 bytes. !  (and perhaps others). integer , parameter , public :: CK = selected_char_kind ( json_fortran_string_kind ) !********************************************************* end module json_kinds !*****************************************************************************************","tags":"","loc":"sourcefile/json_kinds.f90.html","title":"json_kinds.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  A Fortran 2008 JSON (JavaScript Object Notation) API. ! !  This module provides access to [[json_value_module]] and !  [[json_file_module]]. For normal JSON-Fortran use, using this module !  is all that is necessary. ! !  Note that this module renames the kind definition variables from [[json_kinds]] !  from [`RK`, `IK`, `LK`, `CK`, and `CDK`] to [`json_RK`, `json_IK`, `json_LK`, !  `json_CK`, and `json_CDK`] so as to avoid namespace pollution with short !  variable names. ! #ifdef USE_UCS4 #pragma push_macro(\"USE_UCS4\") #undef USE_UCS4 !  Since ```USE_UCS4``` **is** defined, this module also exports the !  operators `==`, `/=`, and `//` from [[json_string_utilities]] for !  `CK` and `CDK` operations. #pragma pop_macro(\"USE_UCS4\") #endif ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. ! !## History !  * Joseph A. Levin : March 2012 : Original [FSON](https://github.com/josephalevin/fson) !    code [retrieved on 12/2/2013]. !  * Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code. !    The original F95 code was split into four files: !    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95. !    The new code has been extensively updated, refactored and combined into this !    one module (json_module.f90). !    Various Fortran 2003/2008 features are now used !    (e.g., allocatable strings, newunit, generic, class, and abstract interface). !  * Development continues at: [Github](http://github.com/jacobwilliams/json-fortran) ! !## See also !  * [json-fortran development site](http://github.com/jacobwilliams/json-fortran) !  * [json-fortran online documentation](http://jacobwilliams.github.io/json-fortran) !  * [JSON website](http://www.json.org/) !  * [JSON validator](http://jsonlint.com/) ! !@note Originally JSON-Fortran was entirely contained within this module. module json_module use json_kinds , only : json_RK => RK , & json_IK => IK , & json_LK => LK , & json_CK => CK , & json_CDK => CDK #ifdef USE_UCS4 use json_string_utilities , only : operator ( == ),& operator ( // ),& operator ( /= ) #endif use json_value_module use json_file_module implicit none public end module json_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_module.f90.html","title":"json_module.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  Other parameters used by JSON-Fortran. !  This is a low-level module not meant to be used by a JSON-Fortran user. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_parameters use json_kinds implicit none public character ( kind = CDK , len =* ), parameter :: json_ext = '.json' !! JSON file extension !special JSON characters character ( kind = CK , len =* ), parameter :: space = ' ' character ( kind = CK , len =* ), parameter :: start_object = '{' character ( kind = CK , len =* ), parameter :: end_object = '}' character ( kind = CK , len =* ), parameter :: start_array = '[' character ( kind = CK , len =* ), parameter :: end_array = ']' character ( kind = CK , len =* ), parameter :: delimiter = ',' character ( kind = CK , len =* ), parameter :: colon_char = ':' character ( kind = CK , len =* ), parameter :: start_array_alt = '(' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: end_array_alt = ')' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: root = '$' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: this = '@' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: child = '.' !! for [[json_get_by_path]] character ( kind = CK , len =* ), parameter :: bspace = achar ( 8 ) character ( kind = CK , len =* ), parameter :: horizontal_tab = achar ( 9 ) character ( kind = CK , len =* ), parameter :: newline = achar ( 10 ) character ( kind = CK , len =* ), parameter :: formfeed = achar ( 12 ) character ( kind = CK , len =* ), parameter :: carriage_return = achar ( 13 ) character ( kind = CK , len =* ), parameter :: quotation_mark = achar ( 34 ) character ( kind = CK , len =* ), parameter :: slash = achar ( 47 ) character ( kind = CK , len =* ), parameter :: backslash = achar ( 92 ) character ( kind = CDK , len =* ), parameter , public :: default_real_fmt = '(ss,E26.16E4)' !! default real number format statement (for writing real values to strings and files). !! Note that this can be overridden by calling [[json_initialize]]. character ( kind = CK , len =* ), parameter , public :: star = '*' !! for invalid numbers and !! list-directed real output #if defined __GFORTRAN__ !not parameters due to gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) character ( kind = CK , len = 26 ), protected :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( kind = CK , len = 26 ), protected :: lower = 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters #else character ( kind = CK , len =* ), parameter , public :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( kind = CK , len =* ), parameter , public :: lower = 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters #endif #if defined __GFORTRAN__ !not parameters due to gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) character ( kind = CK , len = 4 ), protected :: null_str = 'null' !! JSON Null variable string character ( kind = CK , len = 4 ), protected :: true_str = 'true' !! JSON logical True string character ( kind = CK , len = 5 ), protected :: false_str = 'false' !! JSON logical False string #else character ( kind = CK , len =* ), parameter , public :: null_str = 'null' !! JSON Null variable string character ( kind = CK , len =* ), parameter , public :: true_str = 'true' !! JSON logical True string character ( kind = CK , len =* ), parameter , public :: false_str = 'false' !! JSON logical False string #endif integer , private :: i_ !! just a counter for `control_chars` array character ( kind = CK , len =* ), dimension ( 32 ), parameter :: control_chars = & [( achar ( i_ ), i_ = 1 , 31 ), achar ( 127 )] !! Control characters, possibly in unicode !find out the precision of the floating point number system !and set safety factors integer ( IK ), parameter :: rp_safety_factor = 1_IK integer ( IK ), parameter :: rp_addl_safety = 1_IK integer ( IK ), parameter :: real_precision = rp_safety_factor * precision ( 1.0_RK ) + & rp_addl_safety !Get the number of possible digits in the exponent when using decimal number system integer ( IK ), parameter :: maxexp = maxexponent ( 1.0_RK ) integer ( IK ), parameter :: minexp = minexponent ( 1.0_RK ) integer ( IK ), parameter :: real_exponent_digits = floor ( 1 + log10 ( & real ( max ( maxexp , abs ( maxexp )),& kind = RK ) ) ) integer ( IK ), parameter :: max_numeric_str_len = real_precision + real_exponent_digits + 6 !! 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character ( kind = CDK , len =* ), parameter :: int_fmt = '(ss,I0)' !! minimum width format for integers integer ( IK ), parameter :: chunk_size = 100_IK !! for allocatable strings: allocate chunks of this size integer ( IK ), parameter :: unit2str = - 1_IK !! unit number to cause stuff to be !! output to strings rather than files. !! See 9.5.6.12 in the F2003/08 standard integer ( IK ), parameter , public :: seq_chunk_size = 256_IK !! chunk size for reading sequential files integer ( IK ), parameter , public :: pushed_char_size = 10_IK !! magic number end module json_parameters !*****************************************************************************************","tags":"","loc":"sourcefile/json_parameters.f90.html","title":"json_parameters.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  JSON-Fortran support module for string manipulation. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_string_utilities use json_kinds use json_parameters implicit none private !****************************************************** !> !  Convert a 'DEFAULT' kind character input to !  'ISO_10646' kind and return it interface to_unicode module procedure to_uni , to_uni_vec end interface !****************************************************** #ifdef USE_UCS4 !****************************************************** !> ! Provide a means to convert to UCS4 while ! concatenating UCS4 and default strings interface operator ( // ) module procedure ucs4_join_default , default_join_ucs4 end interface public :: operator ( // ) !****************************************************** !****************************************************** !> ! Provide a string `==` operator that works ! with mixed kinds interface operator ( == ) module procedure ucs4_comp_default , default_comp_ucs4 end interface public :: operator ( == ) !****************************************************** !****************************************************** !> ! Provide a string `/=` operator that works ! with mixed kinds interface operator ( /= ) module procedure ucs4_neq_default , default_neq_ucs4 end interface public :: operator ( /= ) !****************************************************** #endif public :: integer_to_string public :: real_to_string public :: valid_json_hex public :: to_unicode public :: escape_string public :: unescape_string public :: lowercase_string contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert an integer to a string. pure subroutine integer_to_string ( ival , int_fmt , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CDK , len =* ), intent ( in ) :: int_fmt !! format for integers character ( kind = CK , len =* ), intent ( out ) :: str !! `ival` converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert a real value to a string. ! !# Modified !  * Izaak Beekman : 02/24/2015 : added the compact option. !  * Jacob Williams : 10/27/2015 : added the star option. subroutine real_to_string ( rval , real_fmt , compact_real , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CDK , len =* ), intent ( in ) :: real_fmt !! format for real numbers logical ( LK ), intent ( in ) :: compact_real !! compact the string so that it is !! displayed with fewer characters character ( kind = CK , len =* ), intent ( out ) :: str !! `rval` converted to a string. integer ( IK ) :: istat if ( real_fmt == star ) then write ( str , fmt =* , iostat = istat ) rval else write ( str , fmt = real_fmt , iostat = istat ) rval end if if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 02/24/2015 ! !  Compact a string representing a real number, so that !  the same value is displayed with fewer characters. ! !# See also !  * [[real_to_string]] subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand character ( kind = CK , len = len ( str )) :: expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start integer ( IK ) :: decimal_pos integer ( IK ) :: sig_trim integer ( IK ) :: exp_trim integer ( IK ) :: i !! counter str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2014 ! !  Add the escape characters to a string for adding to JSON. subroutine escape_string ( str_in , str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out integer ( IK ) :: i !! counter integer ( IK ) :: ipos !! accumulated string size !! (so we can allocate it in chunks for !! greater runtime efficiency) character ( kind = CK , len = 1 ) :: c !! for reading `str_in` one character at a time. #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! workaround for bug in gfortran 6.1 #endif character ( kind = CK , len =* ), parameter :: specials = quotation_mark // & backslash // & slash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( scan ( str_in , specials ) > 0 ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( quotation_mark , backslash , slash ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = '' else #if defined __GFORTRAN__ tmp = str_out ( 1 : ipos - 1 ) !workaround for bug in gfortran 6.1 str_out = tmp #else str_out = str_out ( 1 : ipos - 1 ) !original #endif end if end if else str_out = str_in end if end subroutine escape_string !***************************************************************************************** !***************************************************************************************** !> !  Remove the escape characters from a JSON string and return it. ! !  The escaped characters are denoted by the '\\' character: !```` !    '\\\"'        quotation mark !    '\\\\'        reverse solidus !    '\\/'        solidus !    '\\b'        backspace !    '\\f'        formfeed !    '\\n'        newline (LF) !    '\\r'        carriage return (CR) !    '\\t'        horizontal tab !    '\\uXXXX'    4 hexadecimal digits !```` subroutine unescape_string ( str_in , str_out , error_message ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in !! string as stored in a [[json_value]] character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out !! decoded string character ( kind = CK , len = :), allocatable , intent ( out ) :: error_message !! will be allocated if there was an error integer :: i !! counter integer :: n !! length of str_in integer :: m !! length of str_out character ( kind = CK , len = 1 ) :: c !! for scanning each character in string if ( scan ( str_in , backslash ) > 0 ) then !there is at least one escape character, so process this string: n = len ( str_in ) str_out = repeat ( space , n ) !size the output string (will be trimmed later) m = 0 !counter in str_out i = 0 !counter in str_in do i = i + 1 if ( i > n ) exit ! finished c = str_in ( i : i ) ! get next character in the string if ( c == backslash ) then if ( i < n ) then i = i + 1 c = str_in ( i : i ) !character after the escape if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then select case ( c ) case ( quotation_mark , backslash , slash ) !use d as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select m = m + 1 str_out ( m : m ) = c else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just returning them as is ![not checking to see if it is a valid hex value] ! ! Example: !   123456 !   \\uXXXX if ( i + 4 <= n ) then m = m + 1 str_out ( m : m + 5 ) = str_in ( i - 1 : i + 4 ) i = i + 4 m = m + 5 else error_message = 'Error in unescape_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // str_in ( i - 1 :) if ( allocated ( str_out )) deallocate ( str_out ) return end if else !unknown escape character error_message = 'Error in unescape_string:' // & ' unknown escape sequence in string \"' // & trim ( str_in ) // '\" [' // backslash // c // ']' if ( allocated ( str_out )) deallocate ( str_out ) return end if else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] m = m + 1 str_out ( m : m ) = c end if else m = m + 1 str_out ( m : m ) = c end if end do !trim trailing space: str_out = str_out ( 1 : m ) else !there are no escape characters, so return as is: str_out = str_in end if end subroutine unescape_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:6/14/2014 ! !  Returns true if the string is a valid 4-digit hex string. ! !# Examples !```fortran !    valid_json_hex('0000')  !returns true !    valid_json_hex('ABC4')  !returns true !    valid_json_hex('AB')    !returns false (< 4 characters) !    valid_json_hex('WXYZ')  !returns false (invalid characters) !``` pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n !! length of `str` integer ( IK ) :: i !! counter !> an array of the valid hex characters character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert string to unicode (CDK to CK). pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert array of strings to unicode (CDK to CK). ! !@note JW: may be able to remove this by making [[to_uni]] PURE ELEMENTAL ? pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CK`//`CDK` operator. pure function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CDK`//`CK` operator. pure function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CK`==`CDK` operator. pure elemental function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  `CDK`==`CK` operator. pure elemental function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  `CK`/=`CDK` operator. pure elemental function ucs4_neq_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str /= to_unicode ( def_str ) ) end function ucs4_neq_default !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  `CDK`/=`CK` operator. pure elemental function default_neq_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) /= ucs4_str ) end function default_neq_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Return the lowercase version of the `CK` character. pure elemental function lowercase_character ( c ) result ( c_lower ) implicit none character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = 1 ) :: c_lower integer :: i !! index in uppercase array i = index ( upper , c ) c_lower = merge ( lower ( i : i ), c , i > 0 ) end function lowercase_character !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns lowercase version of the `CK` string. pure elemental function lowercase_string ( str ) result ( s_lower ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str !! input string character ( kind = CK , len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: n !! length of input string s_lower = '' n = len_trim ( str ) if ( n > 0 ) then do concurrent ( i = 1 : n ) s_lower ( i : i ) = lowercase_character ( str ( i : i )) end do end if end function lowercase_string !***************************************************************************************** end module json_string_utilities !*****************************************************************************************","tags":"","loc":"sourcefile/json_string_utilities.f90.html","title":"json_string_utilities.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  This module provides a low-level interface for manipulation of JSON data. !  The two public entities are [[json_value]], and [[json_core]]. !  The [[json_file_module]] provides a higher-level interface to some !  of these routines. ! !## License !  * JSON-Fortran is released under a BSD-style license. !    See the [LICENSE](https://github.com/jacobwilliams/json-fortran/blob/master/LICENSE) !    file for details. module json_value_module use , intrinsic :: iso_fortran_env , only : iostat_end , error_unit , output_unit use json_kinds use json_parameters use json_string_utilities implicit none private #include \"json_macros.inc\" !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 logical , parameter :: use_unformatted_stream = . false . #else logical , parameter :: use_unformatted_stream = . true . #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: access_spec = 'SEQUENTIAL' #else character ( kind = CDK , len =* ), parameter :: access_spec = 'STREAM' #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: form_spec = 'FORMATTED' #else character ( kind = CDK , len =* ), parameter :: form_spec = 'UNFORMATTED' #endif !********************************************************* !********************************************************* ! !  The types of JSON data. ! integer ( IK ), parameter , public :: json_unknown = 0 !! Unknown JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_null = 1 !! Null JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_object = 2 !! Object JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_array = 3 !! Array JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_logical = 4 !! Logical JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_integer = 5 !! Integer JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_double = 6 !! Double JSON data type !! (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_string = 7 !! String JSON data type !********************************************************* !********************************************************* !> !  Type used to construct the linked-list JSON structure. !  Normally, this should always be a pointer variable. !  This type should only be used by an instance of [[json_core]]. ! !# Example ! !  The following test program: ! !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'')   !create the root !     call json%add(p,'year',1805)    !add some data !     call json%add(p,'value',1.0_RK) !add some data !     call json%print(p,'test.json')  !write it to a file !     call json%destroy(p)            !cleanup !    end program test !```` ! !  Produces the JSON file **test.json**: ! !````json !    { !      \"year\": 1805, !      \"value\": 0.1E+1 !    } !```` type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value !********************************************************* !********************************************************* !> !  To access the core routines for manipulation !  of [[json_value]] pointer variables. This class allows !  for thread safe use of the module. ! !### Usage !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json     !<--have to declare this !     type(json_value),pointer :: p !     call json%create_object(p,'')   !create the root !     call json%add(p,'year',1805)    !add some data !     call json%add(p,'value',1.0_RK) !add some data !     call json%print(p,'test.json')  !write it to a file !     call json%destroy(p)            !cleanup !    end program test !    type,public :: json_core !```` type , public :: json_core private integer ( IK ) :: spaces_per_tab = 2 !! number of spaces for indenting logical ( LK ) :: compact_real = . true . !! to use the \"compact\" form of real !! numbers for output character ( kind = CDK , len = :), allocatable :: real_fmt !! the format string to use !! for converting real numbers to strings. !! It can be set in [[json_initialize]], !! and used in [[json_value_print]] !! If not set, then `default_real_fmt` !! is used instead. logical ( LK ) :: is_verbose = . false . !! if true, all exceptions are !! immediately printed to console. logical ( LK ) :: exception_thrown = . false . !! The error flag. Will be set to true !! when an error is thrown in the class. !! Many of the methods will check this !! and return immediately if it is true. character ( kind = CK , len = :), allocatable :: err_message !! the error message integer ( IK ) :: char_count = 0 !! character position in the current line integer ( IK ) :: line_count = 1 !! lines read counter integer ( IK ) :: pushed_index = 0 !! used when parsing lines in file character ( kind = CK , len = pushed_char_size ) :: pushed_char = '' !! used when parsing !! lines in file integer ( IK ) :: ipos = 1 !! for allocatable strings: next character to read logical ( LK ) :: strict_type_checking = . false . !! if true, then no type conversions are done !! in the `get` routines if the actual variable !! type is different from the return type (for !! example, integer to double). logical ( LK ) :: trailing_spaces_significant = . false . !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ) :: case_sensitive_keys = . true . !! for name and path comparisons, are they !! case sensitive. contains private generic , public :: get_child => json_value_get_by_index , & json_value_get_child ,& MAYBEWRAP ( json_value_get_by_name_chars ) procedure , private :: json_value_get_by_index procedure , private :: MAYBEWRAP ( json_value_get_by_name_chars ) procedure , private :: json_value_get_child !> !  Add objects to a linked list of [[json_value]]s. generic , public :: add => json_value_add_member , & MAYBEWRAP ( json_value_add_integer ), & MAYBEWRAP ( json_value_add_integer_vec ), & MAYBEWRAP ( json_value_add_double ), & MAYBEWRAP ( json_value_add_double_vec ), & MAYBEWRAP ( json_value_add_logical ), & MAYBEWRAP ( json_value_add_logical_vec ), & MAYBEWRAP ( json_value_add_string ), & MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 generic , public :: add => json_value_add_string_name_ascii , & json_value_add_string_val_ascii , & json_value_add_string_vec_name_ascii , & json_value_add_string_vec_val_ascii #endif procedure , private :: json_value_add_member procedure , private :: MAYBEWRAP ( json_value_add_integer ) procedure , private :: MAYBEWRAP ( json_value_add_integer_vec ) procedure , private :: MAYBEWRAP ( json_value_add_double ) procedure , private :: MAYBEWRAP ( json_value_add_double_vec ) procedure , private :: MAYBEWRAP ( json_value_add_logical ) procedure , private :: MAYBEWRAP ( json_value_add_logical_vec ) procedure , private :: MAYBEWRAP ( json_value_add_string ) procedure , private :: MAYBEWRAP ( json_value_add_string_vec ) #ifdef USE_UCS4 procedure , private :: json_value_add_string_name_ascii procedure , private :: json_value_add_string_val_ascii procedure , private :: json_value_add_string_vec_name_ascii procedure , private :: json_value_add_string_vec_val_ascii #endif !> !  These are like the `add` methods, except if a child with the !  same name is already present, then its value is simply updated. !  Note that currently, these only work for scalar variables. !  These routines can also change the variable's type (but an error will be !  thrown if the existing variable is not a scalar). ! !@note It should not be used to change the type of a variable in an array, !      or it may result in an invalid JSON file. generic , public :: update => MAYBEWRAP ( json_update_logical ),& MAYBEWRAP ( json_update_double ),& MAYBEWRAP ( json_update_integer ),& MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 generic , public :: update => json_update_string_name_ascii ,& json_update_string_val_ascii #endif procedure , private :: MAYBEWRAP ( json_update_logical ) procedure , private :: MAYBEWRAP ( json_update_double ) procedure , private :: MAYBEWRAP ( json_update_integer ) procedure , private :: MAYBEWRAP ( json_update_string ) #ifdef USE_UCS4 procedure , private :: json_update_string_name_ascii procedure , private :: json_update_string_val_ascii #endif !> !  Get data from a [[json_value]] linked list. ! !@note There are two versions (e.g. [[json_get_integer]] and [[json_get_integer_with_path]]). !      The first one gets the value from the [[json_value]] passed into the routine, !      while the second one gets the value from the [[json_value]] found by parsing the !      path.  The path version is split up into unicode and non-unicode versions. generic , public :: get => & MAYBEWRAP ( json_get_by_path ), & json_get_integer , MAYBEWRAP ( json_get_integer_with_path ), & json_get_integer_vec , MAYBEWRAP ( json_get_integer_vec_with_path ), & json_get_double , MAYBEWRAP ( json_get_double_with_path ), & json_get_double_vec , MAYBEWRAP ( json_get_double_vec_with_path ), & json_get_logical , MAYBEWRAP ( json_get_logical_with_path ), & json_get_logical_vec , MAYBEWRAP ( json_get_logical_vec_with_path ), & json_get_string , MAYBEWRAP ( json_get_string_with_path ), & json_get_string_vec , MAYBEWRAP ( json_get_string_vec_with_path ), & json_get_array , MAYBEWRAP ( json_get_array_with_path ) procedure , private :: json_get_integer procedure , private :: json_get_integer_vec procedure , private :: json_get_double procedure , private :: json_get_double_vec procedure , private :: json_get_logical procedure , private :: json_get_logical_vec procedure , private :: json_get_string procedure , private :: json_get_string_vec procedure , private :: json_get_array procedure , private :: MAYBEWRAP ( json_get_by_path ) procedure , private :: MAYBEWRAP ( json_get_integer_with_path ) procedure , private :: MAYBEWRAP ( json_get_integer_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_double_with_path ) procedure , private :: MAYBEWRAP ( json_get_double_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_logical_with_path ) procedure , private :: MAYBEWRAP ( json_get_logical_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_string_with_path ) procedure , private :: MAYBEWRAP ( json_get_string_vec_with_path ) procedure , private :: MAYBEWRAP ( json_get_array_with_path ) procedure , public :: print_to_string => json_value_to_string !! Print the [[json_value]] structure to an allocatable string !> !  Print the [[json_value]] to a file. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value) :: p !    !... !    call json%print(p,'test.json')  !this is [[json_print_2]] !```` generic , public :: print => json_print_1 , json_print_2 procedure :: json_print_1 procedure :: json_print_2 !> !  Destructor routine for a [[json_value]] pointer. !  This must be called explicitly if it is no longer needed, !  before it goes out of scope.  Otherwise, a memory leak will result. ! !# Example ! !  Destroy the [[json_value]] pointer before the variable goes out of scope: !````fortran !     subroutine example1() !     type(json_core) :: json !     type(json_value),pointer :: p !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%print(p) !     call json%destroy(p) !     end subroutine example1 !```` ! !  Note: it should NOT be called for a [[json_value]] pointer than has already been !  added to another [[json_value]] structure, since doing so may render the !  other structure invalid.  Consider the following example: !````fortran !     subroutine example2(p) !     type(json_core) :: json !     type(json_value),pointer,intent(out) :: p !     type(json_value),pointer :: q !     call json%create_object(p,'') !     call json%add(p,'year',2015) !     call json%create_object(q,'q') !     call json%add(q,'val',1) !     call json%add(p, q)  !add q to p structure !     ! do NOT call json%destroy(q) here, because q is !     ! now part of the output structure p.  p should be destroyed !     ! somewhere upstream by the caller of this routine. !     nullify(q) !OK, but not strictly necessary !     end subroutine example2 !```` generic , public :: destroy => json_value_destroy , destroy_json_core procedure :: json_value_destroy procedure :: destroy_json_core !> !  If the child variable is present, then remove it. generic , public :: remove_if_present => MAYBEWRAP ( json_value_remove_if_present ) procedure :: MAYBEWRAP ( json_value_remove_if_present ) !> !  Allocate a [[json_value]] pointer and make it a double variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_double(p,'value',1.0_RK) !```` generic , public :: create_double => MAYBEWRAP ( json_value_create_double ) procedure :: MAYBEWRAP ( json_value_create_double ) !> !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_array(p,'arrayname') !```` generic , public :: create_array => MAYBEWRAP ( json_value_create_array ) procedure :: MAYBEWRAP ( json_value_create_array ) !> !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. generic , public :: create_object => MAYBEWRAP ( json_value_create_object ) procedure :: MAYBEWRAP ( json_value_create_object ) !> !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_null(p,'value') !```` generic , public :: create_null => MAYBEWRAP ( json_value_create_null ) procedure :: MAYBEWRAP ( json_value_create_null ) !> !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_string(p,'value','foobar') !```` generic , public :: create_string => MAYBEWRAP ( json_value_create_string ) procedure :: MAYBEWRAP ( json_value_create_string ) !> !  Allocate a json_value pointer and make it an integer variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_integer(p,'value',42) !```` generic , public :: create_integer => MAYBEWRAP ( json_value_create_integer ) procedure :: MAYBEWRAP ( json_value_create_integer ) !> !  Allocate a json_value pointer and make it a logical variable. !  The pointer should not already be allocated. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%create_logical(p,'value',.true.) !```` generic , public :: create_logical => MAYBEWRAP ( json_value_create_logical ) procedure :: MAYBEWRAP ( json_value_create_logical ) !> !  Parse the JSON file and populate the [[json_value]] tree. generic , public :: parse => json_parse_file , MAYBEWRAP ( json_parse_string ) procedure :: json_parse_file procedure :: MAYBEWRAP ( json_parse_string ) !> !  Throw an exception. generic , public :: throw_exception => MAYBEWRAP ( json_throw_exception ) procedure :: MAYBEWRAP ( json_throw_exception ) !> !  Rename a [[json_value]] variable. generic , public :: rename => MAYBEWRAP ( json_value_rename ) procedure :: MAYBEWRAP ( json_value_rename ) procedure , public :: remove => json_value_remove !! Remove a [[json_value]] from a linked-list structure. procedure , public :: check_for_errors => json_check_for_errors !! check for error and get error message procedure , public :: clear_exceptions => json_clear_exceptions !! clear exceptions procedure , public :: count => json_count !! count the number of children procedure , public :: clone => json_clone !! clone a JSON structure (deep copy) procedure , public :: failed => json_failed !! check for error procedure , public :: get_parent => json_get_parent !! get pointer to json_value parent procedure , public :: get_next => json_get_next !! get pointer to json_value next procedure , public :: get_previous => json_get_previous !! get pointer to json_value previous procedure , public :: get_tail => json_get_tail !! get pointer to json_value tail procedure , public :: info => json_info !! get info about a json_value procedure , public :: initialize => json_initialize !! to initialize some parsing parameters procedure , public :: traverse => json_traverse !! to traverse all elements of a JSON structure procedure , public :: print_error_message => json_print_error_message !! simply routine to print error messages procedure , public :: swap => json_value_swap !! Swap two [[json_value]] pointers !! in a structure (or two different structures). procedure , public :: is_child_of => json_value_is_child_of !! Check if a [[json_value]] is a child of another. procedure , public :: validate => json_value_validate !! Check that a [[json_value]] linked list is valid !! (i.e., is properly constructed). This may be !! useful if it has been constructed externally. !other private routines: procedure :: name_equal procedure :: json_value_print procedure :: string_to_integer procedure :: string_to_double procedure :: parse_value procedure :: parse_number procedure :: parse_string procedure :: parse_for_chars procedure :: parse_object procedure :: parse_array procedure :: annotate_invalid_json procedure :: pop_char procedure :: push_char procedure :: get_current_line_from_file_stream procedure :: get_current_line_from_file_sequential end type json_core !********************************************************* !********************************************************* !> !  Structure constructor to initialize a !  [[json_core]] object ! !# Example ! !```fortran ! type(json_file)  :: json_core ! json_core = json_core() !``` interface json_core module procedure initialize_json_core end interface !********************************************************* !************************************************************************************* abstract interface subroutine array_callback_func ( json , element , i , count ) !! Array element callback function.  Used by [[json_get_array]] import :: json_value , json_core , IK implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array end subroutine array_callback_func subroutine traverse_callback_func ( json , p , finished ) !! Callback function used by [[json_traverse]] import :: json_value , json_core , LK implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished !! set true to stop traversing end subroutine traverse_callback_func end interface !************************************************************************************* contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/17/2016 ! !  Destructor for the [[json_core]] type. subroutine destroy_json_core ( me ) implicit none class ( json_core ), intent ( out ) :: me end subroutine destroy_json_core !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Function constructor for a [[json_core]]. !  This is just a wrapper for [[json_initialize]]. ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. function initialize_json_core ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) result ( json_core_object ) implicit none type ( json_core ) :: json_core_object logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. call json_core_object % initialize ( verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) end function initialize_json_core !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Initialize the [[json_core]] instance. ! !  The routine may be called before any of the [[json_core]] methods are used in !  order to specify certain parameters. If it is not called, then the defaults !  are used. This routine is also called internally by various routines. !  It can also be called to clear exceptions, or to reset some !  of the variables (note that only the arguments present are changed). ! !# Modified !  * Izaak Beekman : 02/24/2015 ! !@note [[initialize_json_core]], [[json_initialize]], !      [[initialize_json_core_in_file]], and [[initialize_json_file]] !      all have a similar interface. subroutine json_initialize ( json , verbose , compact_reals ,& print_signs , real_format , spaces_per_tab ,& strict_type_checking ,& trailing_spaces_significant ,& case_sensitive_keys ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( kind = CDK , len =* ), intent ( in ), optional :: real_format !! Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer ( IK ), intent ( in ), optional :: spaces_per_tab !! number of spaces per tab for indenting (default is 2) logical ( LK ), intent ( in ), optional :: strict_type_checking !! if true, no integer, double, or logical type !! conversions are done for the `get` routines !! (default is false) logical ( LK ), intent ( in ), optional :: trailing_spaces_significant !! for name and path comparisons, is trailing !! space to be considered significant. logical ( LK ), intent ( in ), optional :: case_sensitive_keys !! for name and path comparisons, are they !! case sensitive. character ( kind = CDK , len = 10 ) :: w , d , e character ( kind = CDK , len = 2 ) :: sgn , rl_edit_desc integer ( IK ) :: istat logical ( LK ) :: sgn_prnt !reset exception to false: call json % clear_exceptions () !Just in case, clear these global variables also: json % pushed_index = 0 json % pushed_char = '' json % char_count = 0 json % line_count = 1 json % ipos = 1 #ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) #endif !various optional inputs: if ( present ( spaces_per_tab )) & json % spaces_per_tab = spaces_per_tab if ( present ( verbose )) & json % is_verbose = verbose if ( present ( strict_type_checking )) & json % strict_type_checking = strict_type_checking if ( present ( trailing_spaces_significant )) & json % trailing_spaces_significant = trailing_spaces_significant if ( present ( case_sensitive_keys )) & json % case_sensitive_keys = case_sensitive_keys !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( json % real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then !allow the special case where real format is '*': ! [this overrides the other options] if ( present ( real_format )) then if ( real_format == star ) then json % compact_real = . false . json % real_fmt = star return end if end if if ( present ( compact_reals )) json % compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call json % throw_exception ( 'Invalid real format, \"' // & trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then json % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else json % real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // & '30.16E3)' !just use this one (should never happen) end if end if end subroutine json_initialize !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/30/2016 ! !  Returns true if `name` is equal to `p%name`, using the specified !  settings for case sensitivity and trailing whitespace. function name_equal ( json , p , name ) result ( is_equal ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), intent ( in ) :: p !! the json object character ( kind = CK , len =* ), intent ( in ) :: name !! the name to check for logical ( LK ) :: is_equal !! true if the string are lexically equal if ( allocated ( p % name )) then !must be the same length if we are treating !trailing spaces as significant, so do a !quick test of this first: if ( json % trailing_spaces_significant ) then is_equal = len ( p % name ) == len ( name ) if (. not . is_equal ) return end if if ( json % case_sensitive_keys ) then is_equal = p % name == name else is_equal = lowercase_string ( p % name ) == lowercase_string ( name ) end if else is_equal = name == '' ! check a blank name end if end function name_equal !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Create a deep copy of a [[json_value]] linked-list structure. ! !# Example ! !````fortran !    program test !     use json_module !     implicit none !     type(json_core) :: json !     type(json_value),pointer :: j1, j2 !     call json%parse('../files/inputs/test1.json',j1) !     call json%clone(j1,j2) !now have two independent copies !     call json%destroy(j1)  !destroys j1, but j2 remains !     call json%print(j2,'j2.json') !     call json%destroy(j2) !    end program test !```` subroutine json_clone ( json , from , to ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) !call the main function: ! [note: this is not part of json_core class] call json_value_clone_func ( from , to ) end subroutine json_clone !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Recursive deep copy function called by [[json_clone]]. ! !@note If new data is added to the [[json_value]] type, !      then this would need to be updated. recursive subroutine json_value_clone_func ( from , to , parent , previous , next , children , tail ) implicit none type ( json_value ), pointer :: from !! this is the structure to clone type ( json_value ), pointer :: to !! the clone is put here !! (it must not already be associated) type ( json_value ), pointer , optional :: parent !! to%parent type ( json_value ), pointer , optional :: previous !! to%previous type ( json_value ), pointer , optional :: next !! to%next type ( json_value ), pointer , optional :: children !! to%children logical , optional :: tail !! if \"to\" is the tail of its parent's children nullify ( to ) if ( associated ( from )) then allocate ( to ) !copy over the data variables: ! [note: the allocate() statements don't work here for the !  deferred-length characters in gfortran-4.9] if ( allocated ( from % name )) to % name = from % name if ( allocated ( from % dbl_value )) allocate ( to % dbl_value , source = from % dbl_value ) if ( allocated ( from % log_value )) allocate ( to % log_value , source = from % log_value ) if ( allocated ( from % str_value )) to % str_value = from % str_value if ( allocated ( from % int_value )) allocate ( to % int_value , source = from % int_value ) to % var_type = from % var_type to % n_children = from % n_children !allocate and associate the pointers as necessary: if ( present ( parent )) to % parent => parent if ( present ( previous )) to % previous => previous if ( present ( next )) to % next => next if ( present ( children )) to % children => children if ( present ( tail )) then if ( tail ) to % parent % tail => to end if if ( associated ( from % next )) then allocate ( to % next ) call json_value_clone_func ( from % next ,& to % next ,& previous = to ,& parent = to % parent ,& tail = (. not . associated ( from % next % next ))) end if if ( associated ( from % children )) then allocate ( to % children ) call json_value_clone_func ( from % children ,& to % children ,& parent = to ,& tail = (. not . associated ( from % children % next ))) end if end if end subroutine json_value_clone_func !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the data within a [[json_value]], and reset type to `json_unknown`. subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/13/2014 ! !  Returns information about a [[json_value]]. subroutine json_info ( json , p , var_type , n_children , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json % count ( p ) if ( present ( name )) then if ( allocated ( p % name )) then name = p % name else name = '' end if end if end subroutine json_info !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! !  Rename a [[json_value]]. subroutine json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! new variable name p % name = name end subroutine json_value_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! !  Alternate version of [[json_value_rename]], where `name` is kind=CDK. subroutine wrap_json_value_rename ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! new variable name call json % rename ( p , to_unicode ( name )) end subroutine wrap_json_value_rename !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Clear exceptions in the [[json_core]]. pure subroutine json_clear_exceptions ( json ) implicit none class ( json_core ), intent ( inout ) :: json !clear the flag and message: json % exception_thrown = . false . json % err_message = '' end subroutine json_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Throw an exception in the [[json_core]]. !  This routine sets the error flag, and prevents any subsequent routine !  from doing anything, until [[json_clear_exceptions]] is called. ! !@note If `is_verbose` is true, this will also print a !      traceback if the Intel compiler is used. subroutine json_throw_exception ( json , msg ) #ifdef __INTEL_COMPILER use ifcore , only : tracebackqq #endif implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: msg !! the error message json % exception_thrown = . true . json % err_message = trim ( msg ) if ( json % is_verbose ) then write ( output_unit , '(A)' ) '***********************' write ( output_unit , '(A)' ) 'JSON-Fortran Exception: ' // trim ( msg ) !call backtrace()     ! gfortran (use -fbacktrace -fall-intrinsics flags) #ifdef __INTEL_COMPILER call tracebackqq ( user_exit_code =- 1 ) ! print a traceback and return #endif write ( output_unit , '(A)' ) '***********************' end if end subroutine json_throw_exception !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_throw_exception]], where `msg` is kind=CDK. subroutine wrap_json_throw_exception ( json , msg ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: msg !! the error message call json % throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Retrieve error code from the [[json_core]]. !  This should be called after `parse` to check for errors. !  If an error is thrown, before using the class again, [[json_initialize]] !  should be called to clean up before it is used again. ! !# Example ! !````fortran !     type(json_file) :: json !     logical :: status_ok !     character(kind=CK,len=:),allocatable :: error_msg !     call json%load_file(filename='myfile.json') !     call json%check_for_errors(status_ok, error_msg) !     if (.not. status_ok) then !         write(*,*) 'Error: '//error_msg !         call json%clear_exceptions() !         call json%destroy() !     end if !```` ! !# See also !  * [[json_failed]] subroutine json_check_for_errors ( json , status_ok , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . json % exception_thrown if (. not . status_ok ) then if ( allocated ( json % err_message )) then error_msg = json % err_message else error_msg = 'Unknown error.' end if else error_msg = '' end if end subroutine json_check_for_errors !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2013 ! !  Logical function to indicate if an exception has been thrown in a [[json_core]]. ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call json%parse(filename='myfile.json',p) !    if (json%failed()) then !        call json%check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call json%clear_exceptions() !        call json%destroy(p) !    end if !```` ! !  Note that [[json_file]] contains a wrapper for this routine, which is used like: !````fortran !    type(json_file) :: f !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call f%load_file(filename='myfile.json') !    if (f%failed()) then !        call f%check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call f%clear_exceptions() !        call f%destroy() !    end if !```` ! !# See also !  * [[json_check_for_errors]] pure function json_failed ( json ) result ( failed ) implicit none class ( json_core ), intent ( in ) :: json logical ( LK ) :: failed !! will be true if an exception !! has been thrown. failed = json % exception_thrown end function json_failed !***************************************************************************************** !***************************************************************************************** !> !  Allocate a [[json_value]] pointer variable. !  This should be called before adding data to it. ! !# Example ! !````fortran !    type(json_value),pointer :: var !    call json_value_create(var) !    call to_double(var,1.0_RK) !```` ! !# Notes !  1. This routine does not check for exceptions. !  2. The pointer should not already be allocated, or a memory leak will occur. subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/22/2014 ! !  Destroy a [[json_value]] linked-list structure. ! !@note The original FSON version of this !      routine was not properly freeing the memory. !      It was rewritten. recursive subroutine json_value_destroy ( json , p , destroy_next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! variable to destroy logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then `p%next` !! is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: child if ( associated ( p )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( p % name )) deallocate ( p % name ) call destroy_json_data ( p ) if ( associated ( p % children )) then do while ( p % n_children > 0 ) child => p % children if ( associated ( child )) then p % children => p % children % next p % n_children = p % n_children - 1 call json_value_destroy ( json , child ,. false .) else call json % throw_exception ( 'Error in json_value_destroy: ' // & 'Malformed JSON linked list' ) exit end if end do nullify ( p % children ) nullify ( child ) end if if ( associated ( p % next ) . and . des_next ) call json_value_destroy ( json , p % next ) if ( associated ( p % previous )) nullify ( p % previous ) if ( associated ( p % parent )) nullify ( p % parent ) if ( associated ( p % tail )) nullify ( p % tail ) deallocate ( p ) nullify ( p ) end if end subroutine json_value_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/9/2014 ! !  Remove a [[json_value]] (and all its children) !  from a linked-list structure, preserving the rest of the structure. ! !# Examples ! !  To extract an object from one JSON structure, and add it to another: !````fortran !     type(json_core) :: json !     type(json_value),pointer :: json1,json2,p !     logical :: found !     !create and populate json1 and json2 !     call json%get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json%remove(p,destroy=.false.)  ! remove it from json1 (don't destroy) !     call json%add(json2,p)               ! add it to json2 !```` ! !  To remove an object from a JSON structure (and destroy it): !````fortran !     type(json_core) :: json !     type(json_value),pointer :: json1,p !     logical :: found !     !create and populate json1 !     call json%get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json%remove(p)                  ! remove and destroy it !```` ! !# History !  * Jacob Williams : 12/28/2014 : added destroy optional argument. subroutine json_value_remove ( json , p , destroy ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( p )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( p % parent )) then parent => p % parent if ( associated ( p % next )) then !there are later items in the list: next => p % next nullify ( p % next ) if ( associated ( p % previous )) then !there are earlier items in the list previous => p % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( p % previous )) then !there are earlier items in the list: previous => p % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json % destroy ( p ) end if end subroutine json_value_remove !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! !  Swap two elements in a JSON structure. !  All of the children are carried along as well. ! !@note If both are not associated, then an error is thrown. ! !@note The assumption here is that both variables are part of a valid !      [[json_value]] linked list (so the normal `parent`, `previous`, !      `next`, etc. pointers are properly associated if necessary). ! !@warning This cannot be used to swap a parent/child pair, since that !         could lead to a circular linkage. An exception is thrown if !         this is tried. ! !@warning There are also other situations where using this routine may !         produce a malformed JSON structure, such as moving an array !         element outside of an array. This is not checked for. ! !@note If `p1` and `p2` have a common parent, it is always safe to swap them. subroutine json_value_swap ( json , p1 , p2 ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical :: same_parent , first_last , adjacent type ( json_value ), pointer :: a , b if ( json % exception_thrown ) return !both have to be associated: if ( associated ( p1 ) . and . associated ( p2 )) then !simple check to make sure that they both !aren't pointing to the same thing: if (. not . associated ( p1 , p2 )) then !we will not allow swapping an item with one of its descendants: if ( json % is_child_of ( p1 , p2 ) . or . json % is_child_of ( p2 , p1 )) then call json % throw_exception ( 'Error in json_value_swap: ' // & 'cannot swap an item with one of its descendants' ) else same_parent = ( associated ( p1 % parent ) . and . & associated ( p2 % parent ) . and . & associated ( p1 % parent , p2 % parent ) ) if ( same_parent ) then !if p1,p2 are the first,last or last,first !children of a common parent first_last = ( associated ( p1 % parent % children , p1 ) . and . & associated ( p2 % parent % tail , p2 )) . or . & ( associated ( p1 % parent % tail , p1 ) . and . & associated ( p2 % parent % children , p2 )) else first_last = . false . end if !first, we fix children,tail pointers: if ( same_parent . and . first_last ) then !this is all we have to do for the parent in this case: call swap_pointers ( p1 % parent % children , p2 % parent % tail ) else if ( same_parent . and . . not . first_last ) then if ( associated ( p1 % parent % children , p1 )) then p1 % parent % children => p2 ! p1 is the first child of the parent else if ( associated ( p1 % parent % children , p2 )) then p1 % parent % children => p1 ! p2 is the first child of the parent end if if ( associated ( p1 % parent % tail , p1 )) then p1 % parent % tail => p2 ! p1 is the last child of the parent else if ( associated ( p1 % parent % tail , p2 )) then p1 % parent % tail => p1 ! p2 is the last child of the parent end if else ! general case: different parents if ( associated ( p1 % parent )) then if ( associated ( p1 % parent % children , p1 )) p1 % parent % children => p2 if ( associated ( p1 % parent % tail , p1 )) p1 % parent % tail => p2 end if if ( associated ( p2 % parent )) then if ( associated ( p2 % parent % children , p2 )) p2 % parent % children => p1 if ( associated ( p2 % parent % tail , p2 )) p2 % parent % tail => p1 end if call swap_pointers ( p1 % parent , p2 % parent ) end if !now, have to fix previous,next pointers: !first, see if they are adjacent: adjacent = associated ( p1 % next , p2 ) . or . & associated ( p2 % next , p1 ) if ( associated ( p2 % next , p1 )) then !p2,p1 a => p2 b => p1 else !p1,p2 (or not adjacent) a => p1 b => p2 end if if ( associated ( a % previous )) a % previous % next => b if ( associated ( b % next )) b % next % previous => a if ( adjacent ) then !a comes before b in the original list b % previous => a % previous a % next => b % next a % previous => b b % next => a else if ( associated ( a % next )) a % next % previous => b if ( associated ( b % previous )) b % previous % next => a call swap_pointers ( a % previous , b % previous ) call swap_pointers ( a % next , b % next ) end if end if else call json % throw_exception ( 'Error in json_value_swap: ' // & 'both pointers must be associated' ) end if end if contains pure subroutine swap_pointers ( s1 , s2 ) implicit none type ( json_value ), pointer , intent ( inout ) :: s1 type ( json_value ), pointer , intent ( inout ) :: s2 type ( json_value ), pointer :: tmp !! temporary pointer if (. not . associated ( s1 , s2 )) then tmp => s1 s1 => s2 s2 => tmp end if end subroutine swap_pointers end subroutine json_value_swap !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/28/2016 ! !  Returns True if `p2` is a descendant of `p1` !  (i.e, a child, or a child of child, etc.) function json_value_is_child_of ( json , p1 , p2 ) result ( is_child_of ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p1 type ( json_value ), pointer :: p2 logical ( LK ) :: is_child_of is_child_of = . false . if ( json % exception_thrown ) return if ( associated ( p1 ) . and . associated ( p2 )) then if ( associated ( p1 % children )) then call json % traverse ( p1 % children , is_child_of_callback ) end if end if contains subroutine is_child_of_callback ( json , p , finished ) !! Traverse until `p` is `p2`. implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished is_child_of = associated ( p , p2 ) finished = is_child_of ! stop searching if found end subroutine is_child_of_callback end function json_value_is_child_of !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/2/2016 ! !  Validate a [[json_value]] linked list by checking to make sure !  all the pointers are properly associated, arrays and objects !  have the correct number of children, and the correct data is !  allocated for the variable types. ! !  It recursively traverses the entire structure and checks every element. ! !@note This routine does not check or throw any exceptions. subroutine json_value_validate ( json , p , is_valid , error_msg ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: is_valid !! True if the structure is valid. character ( kind = CK , len = :), allocatable :: error_msg !! if not valid, this will contain !! a description of the problem if ( associated ( p )) then is_valid = . true . call check_if_valid ( p , require_parent = associated ( p % parent )) else error_msg = 'The pointer is not associated' is_valid = . false . end if contains recursive subroutine check_if_valid ( p , require_parent ) implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( in ) :: require_parent !! the first one may be a root (so no parent), !! but all descendants must have a parent. integer :: i !! counter type ( json_value ), pointer :: element type ( json_value ), pointer :: previous if ( is_valid . and . associated ( p )) then ! data type: select case ( p % var_type ) case ( json_null , json_object , json_array ) if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for ' // & 'json_null, json_object, or json_array variable type' is_valid = . false . return end if case ( json_logical ) if (. not . allocated ( p % log_value )) then error_msg = 'log_value should be allocated for json_logical variable type' is_valid = . false . return else if ( allocated ( p % int_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_logical variable type' is_valid = . false . return end if case ( json_integer ) if (. not . allocated ( p % int_value )) then error_msg = 'int_value should be allocated for json_integer variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . & allocated ( p % dbl_value ) . or . allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_integer variable type' is_valid = . false . return end if case ( json_double ) if (. not . allocated ( p % dbl_value )) then error_msg = 'dbl_value should be allocated for json_double variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % str_value )) then error_msg = 'incorrect data allocated for json_double variable type' is_valid = . false . return end if case ( json_string ) if (. not . allocated ( p % str_value )) then error_msg = 'str_value should be allocated for json_string variable type' is_valid = . false . return else if ( allocated ( p % log_value ) . or . allocated ( p % int_value ) . or . & allocated ( p % dbl_value )) then error_msg = 'incorrect data allocated for json_string variable type' is_valid = . false . return end if case default error_msg = 'invalid JSON variable type' is_valid = . false . return end select if ( require_parent . and . . not . associated ( p % parent )) then error_msg = 'parent pointer is not associated' is_valid = . false . return end if if (. not . allocated ( p % name )) then if ( associated ( p % parent )) then if ( p % parent % var_type /= json_array ) then error_msg = 'JSON variable must have a name if not an ' // & 'array element or the root' is_valid = . false . return end if end if end if if ( associated ( p % children ) . neqv . associated ( p % tail )) then error_msg = 'both children and tail pointers must be associated' is_valid = . false . return end if ! now, check next one: if ( associated ( p % next )) then call check_if_valid ( p % next , require_parent = require_parent ) end if if ( associated ( p % children )) then if ( p % var_type /= json_array . and . p % var_type /= json_object ) then error_msg = 'only arrays and objects can have children' is_valid = . false . return end if ! first validate children pointers: previous => null () element => p % children do i = 1 , p % n_children if (. not . associated ( element % parent , p )) then error_msg = 'child''s parent pointer not properly associated' is_valid = . false . return end if if ( i == 1 . and . associated ( element % previous )) then error_msg = 'first child shouldn''t have a previous' is_valid = . false . return end if if ( i < p % n_children . and . . not . associated ( element % next )) then error_msg = 'not enough children' is_valid = . false . return end if if ( i == p % n_children . and . associated ( element % next )) then error_msg = 'too many children' is_valid = . false . return end if if ( i > 1 ) then if (. not . associated ( previous , element % previous )) then error_msg = 'previous pointer not properly associated' is_valid = . false . return end if end if if ( i == p % n_children . and . & . not . associated ( element % parent % tail , element )) then error_msg = 'parent''s tail pointer not properly associated' is_valid = . false . return end if if ( i < p % n_children ) then !setup next case: previous => element element => element % next end if end do !now check all the children: call check_if_valid ( p % children , require_parent = . true .) end if end if end subroutine check_if_valid end subroutine json_value_validate !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, remove the variable from !  the [[json_value]] structure, if it exists. subroutine json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json % get ( p , name , p_var , found ) if ( found ) call json % remove ( p_var ) end subroutine json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_remove_if_present]], where `name` is kind=CDK. subroutine wrap_json_value_remove_if_present ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_logical ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_logical ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_logical]], where `name` is kind=CDK. subroutine wrap_json_update_logical ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_double ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_double ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_double]], where `name` is kind=CDK. subroutine wrap_json_update_double ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_integer ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_integer ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_integer]], where `name` is kind=CDK. subroutine wrap_json_update_integer ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_string ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json % get ( p , name , p_var , found ) if ( found ) then call json % info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_string ( p_var , val ) !update the value case default found = . false . call json % throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json % add ( p , name , val ) !add the new element end if end subroutine json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `name` and `value` are kind=CDK. subroutine wrap_json_update_string ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `name` is kind=CDK. subroutine json_update_string_name_ascii ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , to_unicode ( name ), val , found ) end subroutine json_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where `val` is kind=CDK. subroutine json_update_string_val_ascii ( json , p , name , val , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json % update ( p , name , to_unicode ( val ), found ) end subroutine json_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Adds `member` as a child of `p`. subroutine json_value_add_member ( json , p , member ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p type ( json_value ), pointer :: member !! the child member to add if (. not . json % exception_thrown ) then ! associate the parent member % parent => p ! add to linked list if ( associated ( p % children )) then p % tail % next => member member % previous => p % tail else p % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list p % tail => member p % n_children = p % n_children + 1 end if end subroutine json_value_add_member !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a real value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json % create_double ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double]] where `name` is kind=CDK. subroutine wrap_json_value_add_double ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a real vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_double_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json % create_integer ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer]] where `name` is kind=CDK. subroutine wrap_json_value_add_integer ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create a variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_integer_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json % create_logical ( var , val , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical]] where `name` is kind=CDK. subroutine wrap_json_value_add_logical ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !! counter !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json % add ( var , '' , val ( i )) end do !add it: call json % add ( p , var ) end subroutine json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical_vec]] where `name` is kind=CDK. subroutine wrap_json_value_add_logical_vec ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a character string child to the [[json_value]] variable. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value type ( json_value ), pointer :: var character ( kind = CK , len = :), allocatable :: str !add escape characters if necessary: call escape_string ( val , str ) !create the variable: call json % create_string ( var , str , name ) !add it: call json % add ( p , var ) end subroutine json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `name` and `val` are kind=CDK. subroutine wrap_json_value_add_string ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), to_unicode ( val )) end subroutine wrap_json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `name` is kind=CDK. subroutine json_value_add_string_name_ascii ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value call json % add ( p , to_unicode ( name ), val ) end subroutine json_value_add_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where `val` is kind=CDK. subroutine json_value_add_string_val_ascii ( json , p , name , val ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json % add ( p , name , to_unicode ( val )) end subroutine json_value_add_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add an array of character strings to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i logical ( LK ) :: trim_string , adjustl_string character ( kind = CK , len = :), allocatable :: str !if the string is to be trimmed or not: if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if !create the variable as an array: call json % create_array ( var , name ) !populate the array: do i = 1 , size ( val ) !the string to write: str = val ( i ) if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) !write it: call json % add ( var , '' , str ) !cleanup deallocate ( str ) end do !add it: call json % add ( p , var ) end subroutine json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `name` and `val` are kind=CDK. subroutine wrap_json_value_add_string_vec ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `name` is kind=CDK. subroutine json_value_add_string_vec_name_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where `val` is kind=CDK. subroutine json_value_add_string_vec_val_ascii ( json , p , name , val , trim_str , adjustl_str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json % add ( p , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Count the number of children. ! !# History !  * JW : 1/4/2014 : Original routine removed. !    Now using n_children variable. !    Renamed from json_value_count. function json_count ( json , p ) result ( count ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ) :: count !! number of children if ( associated ( p )) then count = p % n_children else call json % throw_exception ( 'Error in json_count: ' // & 'pointer is not associated.' ) end if end function json_count !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/16/2015 ! !  Returns a pointer to the parent of a [[json_value]]. !  If there is no parent, then a null() pointer is returned. subroutine json_get_parent ( json , p , parent ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: parent !! pointer to parent if ( associated ( p )) then parent => p % parent else nullify ( parent ) call json % throw_exception ( 'Error in json_get_parent: ' // & 'pointer is not associated.' ) end if end subroutine json_get_parent !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the next of a [[json_value]]. !  If there is no next, then a null() pointer is returned. subroutine json_get_next ( json , p , next ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: next !! pointer to next if ( associated ( p )) then next => p % next else nullify ( next ) call json % throw_exception ( 'Error in json_get_next: ' // & 'pointer is not associated.' ) end if end subroutine json_get_next !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the previous of a [[json_value]]. !  If there is no previous, then a null() pointer is returned. subroutine json_get_previous ( json , p , previous ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: previous !! pointer to previous if ( associated ( p )) then previous => p % previous else nullify ( previous ) call json % throw_exception ( 'Error in json_get_previous: ' // & 'pointer is not associated.' ) end if end subroutine json_get_previous !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 10/31/2015 ! !  Returns a pointer to the tail of a [[json_value]] !  (the last child of an array of object). !  If there is no tail, then a null() pointer is returned. subroutine json_get_tail ( json , p , tail ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! JSON object type ( json_value ), pointer , intent ( out ) :: tail !! pointer to tail if ( associated ( p )) then tail => p % tail else nullify ( tail ) call json % throw_exception ( 'Error in json_get_tail: ' // & 'pointer is not associated.' ) end if end subroutine json_get_tail !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the index. subroutine json_value_get_by_index ( json , p , idx , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child type ( json_value ), pointer :: child !! pointer to the child integer ( IK ) :: i nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p % children )) then child => p % children do i = 1 , idx - 1 if ( associated ( child % next )) then child => child % next else call json % throw_exception ( 'Error in json_value_get_by_index:' // & ' child%next is not associated.' ) nullify ( child ) return end if end do else call json % throw_exception ( 'Error in json_value_get_by_index:' // & ' p%children is not associated.' ) end if end if end subroutine json_value_get_by_index !***************************************************************************************** !***************************************************************************************** !> !  Returns pointer to the first child of the object !  (or null() if it is not associated). subroutine json_value_get_child ( json , p , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p !! object or array JSON data type ( json_value ), pointer :: child !! pointer to the child if ( associated ( p )) then child => p % children else nullify ( child ) call json % throw_exception ( 'Error in json_value_get_child: ' // & 'pointer is not associated.' ) end if end subroutine json_value_get_child !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the name string. ! !  The name search can be case-sensitive or not, and can have significant trailing !  whitespace or not, depending on the settings in the [[json_core]] class. ! !@note The `name` input is not a path, and is not parsed like it is in [[json_get_by_path]]. subroutine json_value_get_by_name_chars ( json , p , name , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of `p` type ( json_value ), pointer :: child !! pointer to the child integer ( IK ) :: i , n_children nullify ( child ) if (. not . json % exception_thrown ) then if ( associated ( p )) then if ( p % var_type == json_object ) then n_children = json % count ( p ) child => p % children !start with first one do i = 1 , n_children if (. not . associated ( child )) then call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'Malformed JSON linked list' ) return end if if ( allocated ( child % name )) then !name string matching routine: if ( json % name_equal ( child , name )) return end if child => child % next end do end if !did not find anything: call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( child ) else call json % throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'pointer is not associated.' ) end if end if end subroutine json_value_get_by_name_chars !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_get_by_name_chars]] where `name` is kind=CDK. subroutine wrap_json_value_get_by_name_chars ( json , p , name , child ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: child call json % get ( p , to_unicode ( name ), child ) end subroutine wrap_json_value_get_by_name_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/12/2014 ! !  Print the [[json_value]] structure to an allocatable string. subroutine json_value_to_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = '' call json % json_value_print ( p , iunit = unit2str , str = str , indent = 1 , colon = . true .) end subroutine json_value_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/20/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_1 ( json , p , iunit ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json % json_value_print ( p , iunit , str = dummy , indent = 1 , colon = . true .) else call json % throw_exception ( 'Error in json_print_1: iunit must not be -1.' ) end if end subroutine json_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/23/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_2 ( json , p , filename ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json % print ( p , iunit ) close ( iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2 !***************************************************************************************** !***************************************************************************************** !> !  Print the JSON structure to a string or a file. ! !# Notes !  * This is an internal routine called by the various wrapper routines. !  * The reason the str argument is non-optional is because of a !    bug in v4.9 of the gfortran compiler. recursive subroutine json_value_print ( json , p , iunit , str , indent ,& need_comma , colon , is_array_element ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. character ( kind = CK , len = max_numeric_str_len ) :: tmp !for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array if (. not . json % exception_thrown ) then !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent )) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * json % spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = '' else s = repeat ( space , spaces ) end if select case ( p % var_type ) case ( json_object ) count = json % count ( p ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then tab = tab + 1 spaces = tab * json % spaces_per_tab end if nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! print the name if ( allocated ( element % name )) then call write_it ( repeat ( space , spaces ) // quotation_mark // & element % name // quotation_mark // colon_char // space ,& advance = . false .) else call json % throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json % count ( p ) if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( start_array ) nullify ( element ) element => p % children do i = 1 , count if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_value_print: ' // & 'Malformed JSON linked list' ) return end if ! recursive print of the element call json % json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) ! get the next child the list: element => element % next end do !indent the closing array character: call write_it ( repeat ( space , max ( 0 , spaces - json % spaces_per_tab )) // end_array ,& comma = print_comma ) nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma ) case ( json_string ) if ( allocated ( p % str_value )) then call write_it ( s // quotation_mark // & trim ( p % str_value ) // quotation_mark , comma = print_comma ) else call json % throw_exception ( 'Error in json_value_print:' // & ' p%value_string not allocated' ) return end if case ( json_logical ) if ( p % log_value ) then call write_it ( s // true_str , comma = print_comma ) else call write_it ( s // false_str , comma = print_comma ) end if case ( json_integer ) call integer_to_string ( p % int_value , int_fmt , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case ( json_double ) if ( allocated ( json % real_fmt )) then call real_to_string ( p % dbl_value , json % real_fmt , json % compact_real , tmp ) else !use the default format (user has not called initialize() or specified one): call real_to_string ( p % dbl_value , default_real_fmt , json % compact_real , tmp ) end if call write_it ( s // trim ( tmp ), comma = print_comma ) case default call json % throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains subroutine write_it ( s , advance , comma ) !! write the string to the file (or the output string) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !! string to print logical ( LK ), intent ( in ), optional :: advance !! to add line break or not logical ( LK ), intent ( in ), optional :: comma !! print comma after the string logical ( LK ) :: add_line_break , add_comma character ( kind = CK , len = :), allocatable :: s2 if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( present ( advance )) then add_line_break = advance else add_line_break = . true . !default is to advance end if !string to print: s2 = s if ( add_comma ) s2 = s2 // delimiter if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print !***************************************************************************************** !***************************************************************************************** !> !  Returns the [[json_value]] pointer given the path string. ! !# Example ! !````fortran !    type(json_value),pointer :: dat,p !    logical :: found !    !... !    call json%get(dat,'data(2).version',p,found) !```` ! !# Notes !  The following special characters are used to denote paths: ! !```` !  $         - root !  @         - this !  .         - child object member !  [] or ()  - child array element !```` ! !  Thus, if any of these characters are present in the name key, !  this routine cannot be used to get the value. !  In that case, the `get_child` methods would need to be used. subroutine json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me !! a JSON linked list character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable specify by `path` logical ( LK ), intent ( out ), optional :: found !! true if it was found integer ( IK ) :: i integer ( IK ) :: length integer ( IK ) :: child_i character ( kind = CK , len = 1 ) :: c logical ( LK ) :: array type ( json_value ), pointer :: tmp nullify ( p ) if (. not . json % exception_thrown ) then ! default to assuming relative to this p => me child_i = 1 array = . false . !keep trailing space or not: if ( json % trailing_spaces_significant ) then length = len ( path ) else length = len_trim ( path ) end if do i = 1 , length c = path ( i : i ) select case ( c ) case ( root ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 case ( this ) ! this p => me child_i = i + 1 case ( child ) ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path:' // & ' Error getting child member.' ) exit end if child_i = i + 1 case ( start_array , start_array_alt ) !....Modified to allow for 'var[3]' style syntax !Note: jmozmoz/fson has a slightly different version of this... ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_by_path:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call json % throw_exception ( 'Error in json_get_by_path: Unexpected ]' ) exit end if array = . false . child_i = json % string_to_integer ( path ( child_i : i - 1 )) nullify ( tmp ) call json % get_child ( p , child_i , tmp ) p => tmp nullify ( tmp ) child_i = i + 1 end select end do if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) call json % get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) end if if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call json % throw_exception ( 'Error in json_get_by_path:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_get_by_path ( json , me , path , p , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Convert a string into an integer. ! !# History !  * Jacob Williams : 12/10/2013 : Rewrote routine.  Added error checking. !  * Modified by Izaak Beekman ! !@note Replacement for the parse_integer function in the original code. function string_to_integer ( json , str ) result ( ival ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr if (. not . json % exception_thrown ) then ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer if ( ierr /= 0 ) then !if there was an error ival = 0 call json % throw_exception ( 'Error in string_to_integer: ' // & 'string cannot be converted to an integer: ' // & trim ( str )) end if else ival = 0 end if end function string_to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Convert a string into a double. ! !# History !  * Jacob Williams, 10/27/2015 : Now using fmt=*, rather than !    fmt=real_fmt, since it doesn't work for some unusual cases !    (e.g., when str='1E-5'). function string_to_double ( json , str ) result ( rval ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len =* ), intent ( in ) :: str real ( RK ) :: rval integer ( IK ) :: ierr !! read iostat error code if (. not . json % exception_thrown ) then !string to double read ( str , fmt =* , iostat = ierr ) rval if ( ierr /= 0 ) then !if there was an error rval = 0.0_RK call json % throw_exception ( 'Error in string_to_double: ' // & 'string cannot be converted to a double: ' // & trim ( str )) end if else rval = 0.0_RK end if end function string_to_double !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]]. subroutine json_get_integer ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( json % exception_thrown ) return if ( me % var_type == json_integer ) then value = me % int_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call json % throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end if end if end subroutine json_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]], given the path string. subroutine json_get_integer_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_with_path]], where \"path\" is kind=CDK. subroutine wrap_json_get_integer_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get an integer vector from a [[json_value]]. subroutine json_get_integer_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_int_from_array ) contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Get an integer vector from a [[json_value]], given the path string. subroutine json_get_integer_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . call json % get ( me , path = path , array_callback = get_int_from_array , found = found ) ! need to duplicate callback function, no other way contains subroutine get_int_from_array ( json , element , i , count ) !! callback function for integer implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_integer_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]]. subroutine json_get_double ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( json % exception_thrown ) return if ( me % var_type == json_double ) then value = me % dbl_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end if end if end subroutine json_get_double !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]], given the path. subroutine json_get_double_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a double vector from a [[json_value]]. subroutine json_get_double_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_double_from_array ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a double vector from a [[json_value]], given the path. subroutine json_get_double_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_double_from_array , found = found ) contains subroutine get_double_from_array ( json , element , i , count ) !! callback function for double implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]]. subroutine json_get_logical ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ) :: value value = . false . if ( json % exception_thrown ) return if ( me % var_type == json_logical ) then value = me % log_value else if ( json % strict_type_checking ) then call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) else !type conversions select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case default call json % throw_exception ( 'Error in json_get_logical: ' // & 'Unable to resolve value to logical: ' // & me % name ) end select end if end if end subroutine json_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]], given the path. subroutine json_get_logical_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found )) then found = . false . call json % clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a logical vector from [[json_value]]. subroutine json_get_logical_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_logical_from_array ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a logical vector from a [[json_value]], given the path. subroutine json_get_logical_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_logical_from_array , found = found ) contains subroutine get_logical_from_array ( json , element , i , count ) !! callback function for logical implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]]. subroutine json_get_string ( json , me , value ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value character ( kind = CK , len = :), allocatable :: error_message !! for [[unescape_string]] value = '' if (. not . json % exception_thrown ) then select case ( me % var_type ) case ( json_string ) if ( allocated ( me % str_value )) then call unescape_string ( me % str_value , value , error_message ) if ( allocated ( error_message )) then call json % throw_exception ( error_message ) deallocate ( error_message ) value = '' end if else call json % throw_exception ( 'Error in json_get_string: ' // & 'me%str_value not allocated' ) end if case default call json % throw_exception ( 'Error in json_get_string: ' // & 'Unable to resolve value to characters: ' // & me % name ) ! Note: for the other cases, we could do val to string conversions. end select end if end subroutine json_get_string !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]], given the path. subroutine json_get_string_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = '' if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_string_with_path:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . json % exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json % clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_with_path ( json , me , path , value , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a string vector from a [[json_value(type)]]. subroutine json_get_string_vec ( json , me , vec ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , array_callback = get_chars_from_array ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a string vector from a [[json_value(type)]], given the path. subroutine json_get_string_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . !the callback function is called for each element of the array: call json % get ( me , path = path , array_callback = get_chars_from_array , found = found ) contains subroutine get_chars_from_array ( json , element , i , count ) !! callback function for chars implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !! index integer ( IK ), intent ( in ) :: count !! size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json % get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_vec_with_path ( json , me , path , vec , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied [[array_callback_func]] subroutine !      for each element in the array. ! !@note For integer, double, logical, and character arrays, !      higher-level routines are provided (see `get` methods), so !      this routine does not have to be used for those cases. subroutine json_get_array ( json , me , array_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me procedure ( array_callback_func ) :: array_callback type ( json_value ), pointer :: element !! temp variable for getting elements integer ( IK ) :: i !! counter integer ( IK ) :: count !! number of elements in the array if ( json % exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json % count ( me ) element => me % children do i = 1 , count ! callback for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_get_array: ' // & 'Malformed JSON linked list' ) return end if call array_callback ( json , element , i , count ) if ( json % exception_thrown ) exit element => element % next end do case default call json % throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/28/2016 ! !  Traverse a JSON structure. !  This routine calls the user-specified [[traverse_callback_func]] !  for each element of the structure. subroutine json_traverse ( json , p , traverse_callback ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p procedure ( traverse_callback_func ) :: traverse_callback logical ( LK ) :: finished !! can be used to stop the process if (. not . json % exception_thrown ) call traverse ( p ) contains recursive subroutine traverse ( p ) !! recursive [[json_value]] traversal. implicit none type ( json_value ), pointer , intent ( in ) :: p type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children if ( json % exception_thrown ) return call traverse_callback ( json , p , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( p % var_type == json_array . or . p % var_type == json_object ) then icount = json % count ( p ) ! number of children if ( icount > 0 ) then element => p % children ! first one do i = 1 , icount ! call for each child if (. not . associated ( element )) then call json % throw_exception ( 'Error in json_traverse: ' // & 'Malformed JSON linked list' ) return end if call traverse ( element ) if ( finished . or . json % exception_thrown ) exit element => element % next end do end if nullify ( element ) end if end subroutine traverse end subroutine json_traverse !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied array_callback subroutine !  for each element in the array (specified by the path). subroutine json_get_array_with_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( json % exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json % get ( me = me , path = path , p = p ) if (. not . associated ( p )) then call json % throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json % get ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( json % exception_thrown ) then if ( present ( found ) ) then found = . false . call json % clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_array_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_array_with_path ( json , me , path , array_callback , found ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json % get ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_with_path !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON file and populate the [[json_value]] tree. ! !# Inputs ! !  The inputs can be: ! !  * `file` & `unit` : the specified unit is used to read JSON from file. !                      [note if unit is already open, then the filename is ignored] !  * `file`          : JSON is read from file using internal unit number ! !# Example ! !````fortran !    type(json_core) :: json !    type(json_value),pointer :: p !    call json%parse(file='myfile.json', p=p) !```` ! !# History !  * Jacob Williams : 01/13/2015 : added read from string option. !  * Izaak Beekman  : 03/08/2015 : moved read from string to separate !    subroutine, and error annotation to separate subroutine. ! !@note When calling this routine, any exceptions thrown from previous !      calls will automatically be cleared. subroutine json_parse_file ( json , file , p , unit ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit !! file unit actually used integer ( IK ) :: istat !! iostat flag logical ( LK ) :: is_open !! if the file is already open !clear any exceptions and initialize: call json % initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call json % throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call json % parse_value ( unit = iunit , str = CK_ '' , value = p ) if ( json % exception_thrown ) call json % annotate_invalid_json ( iunit , CK_ '' ) ! close the file if necessary close ( unit = iunit , iostat = istat ) else call json % throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON string and populate the [[json_value]] tree. ! !# See also !  * [[json_parse_file]] subroutine json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !! indicates that json data will be read from buffer !clear any exceptions and initialize: call json % initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = '' ! parse as a value call json % parse_value ( unit = iunit , str = str , value = p ) if ( json % exception_thrown ) call json % annotate_invalid_json ( iunit , str ) end subroutine json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_parse_string]], where `str` is kind=CDK. subroutine wrap_json_parse_string ( json , p , str ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json % parse ( p , to_unicode ( str )) end subroutine wrap_json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Generate a warning message if there was an error parsing a JSON !  file or string. subroutine annotate_invalid_json ( json , iunit , str ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl !  If there was an error reading the file, then !   print the line where the error occurred: if ( json % exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( json % line_count , int_fmt , line_str ) call integer_to_string ( json % char_count , int_fmt , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , json % char_count - 1 ) ) // '&#94;' if ( json % line_count > 0 . and . json % char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call json % get_current_line_from_file_stream ( iunit , line ) else call json % get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , json % line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = '' end if !create the error message: json % err_message = json % err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the SEQUENTIAL version (see also [[get_current_line_from_file_stream]]). subroutine get_current_line_from_file_sequential ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line character ( kind = CK , len = seq_chunk_size ) :: chunk !! for reading line in chunks integer ( IK ) :: istat !! iostat flag integer ( IK ) :: isize !! number of characters read in read statement !initialize: line = '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = '(A)' , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= seq_chunk_size ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the STREAM version (see also [[get_current_line_from_file_sequential]]). subroutine get_current_line_from_file_stream ( json , iunit , line ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c istart = json % ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = json % ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_value ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof !! end-of-file flag character ( kind = CK , len = 1 ) :: c !! character read from file (or string) #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call json % throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call to_object ( value ) !allocate class call json % parse_object ( unit , str , value ) case ( start_array ) ! start array call to_array ( value ) !allocate class call json % parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call json % push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of value % str_value = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) ! #else call json % parse_string ( unit , str , value % str_value ) #endif end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call json % parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call json % parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . json % exception_thrown ) call to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call json % parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . json % exception_thrown ) call to_null ( value ) !allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call json % push_char ( c ) call json % parse_number ( unit , str , value ) case default call json % throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a logical(LK) variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_logical(p,'value',.true.) !```` subroutine json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name !! variable name logical ( LK ), intent ( in ) :: val !! variable value call json_value_create ( p ) call to_logical ( p , val , name ) end subroutine json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrapper for [[json_value_create_logical]] so `create_logical` method can !  be called with name of character kind 'DEFAULT' or 'ISO_10646' subroutine wrap_json_value_create_logical ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val call json % create_logical ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an integer(IK) variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_integer(p,'value',1) !```` subroutine json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create ( p ) call to_integer ( p , val , name ) end subroutine json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper procedure for [[json_value_create_integer]] so that `create_integer` !  method may be called with either a 'DEFAULT' or 'ISO_10646' character kind !  `name` actual argument. subroutine wrap_json_value_create_integer ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json % create_integer ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a real(RK) variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_double(p,'value',1.0_RK) !```` subroutine json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create ( p ) call to_double ( p , val , name ) end subroutine json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_double]] so that `create_double` method !  may be called with an actual argument corresponding to the dummy argument, !  `name` that may be of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_double ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json % create_double ( p , val , to_unicode ( name )) end subroutine wrap_json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_string(p,'value','hello') !```` subroutine json_value_create_string ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val call json_value_create ( p ) call to_string ( p , val , name ) end subroutine json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_string]] so that `create_string` method may be called !  with actual character string arguments for `name` and `val` that are BOTH of !  'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_string ( json , p , val , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val call json % create_string ( p , to_unicode ( val ), to_unicode ( name )) end subroutine wrap_json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_null(p,'value') !```` subroutine json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_null ( p , name ) end subroutine json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_null]] so that `create_null` method may be called with !  an actual argument corresponding to the dummy argument `name` that is either !  of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_null ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_null ( p , to_unicode ( name )) end subroutine wrap_json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_object(p,'objectname') !```` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. subroutine json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_object ( p , name ) end subroutine json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_object]] so that `create_object` method may be called !  with an actual argument corresponding to the dummy argument `name` that is of !  either 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_object ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_object ( p , to_unicode ( name )) end subroutine wrap_json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example !````fortran !     type(json_value),pointer :: p !     type(json_core) :: json !     call json%create_array(p,'arrayname') !```` subroutine json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( p ) call to_array ( p , name ) end subroutine json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_array]] so that `create_array` method may be !  called with an actual argument, corresponding to the dummy argument `name`, !  that is either of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_array ( json , p , name ) implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json % create_array ( p , to_unicode ( name )) end subroutine wrap_json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a logical. subroutine to_logical ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_logical allocate ( p % log_value ) if ( present ( val )) then p % log_value = val else p % log_value = . false . !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an integer. subroutine to_integer ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_integer allocate ( p % int_value ) if ( present ( val )) then p % int_value = val else p % int_value = 0 !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a double. subroutine to_double ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p real ( RK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_double allocate ( p % dbl_value ) if ( present ( val )) then p % dbl_value = val else p % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a string. ! !# Modified !  * Izaak Beekman : 02/24/2015 ! subroutine to_string ( p , val , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_string if ( present ( val )) then p % str_value = val else p % str_value = '' !default value end if !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a null. subroutine to_null ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_null !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an object. subroutine to_object ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_object !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an array. subroutine to_array ( p , name ) implicit none type ( json_value ), intent ( inout ) :: p character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( p ) p % var_type = json_array !name: if ( present ( name )) p % name = trim ( name ) end subroutine to_array !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_object ( json , unit , str , parent ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c #if defined __GFORTRAN__ character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. #endif if (. not . json % exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call json % throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) #if defined __GFORTRAN__ call json % parse_string ( unit , str , tmp ) ! write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) #else call json % parse_string ( unit , str , pair % name ) #endif if ( json % exception_thrown ) then call json % destroy ( pair ) return end if else call json % throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call json % parse_value ( unit , str , pair ) if ( json % exception_thrown ) then call json % destroy ( pair ) return else call json % add ( parent , pair ) end if else call json % throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call json % parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call json % throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_array ( json , unit , str , array ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( json % exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call json % parse_value ( unit , str , element ) if ( json % exception_thrown ) then if ( associated ( element )) call json % destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json % add ( array , element ) ! popped the next character c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then ! The file ended before array was finished: call json % throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call json % throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array !***************************************************************************************** !***************************************************************************************** !> !  Parses a string while reading a JSON file. ! !# History !  * Jacob Williams : 6/16/2014 : Added hex validation. !  * Jacob Williams : 12/3/2015 : Fixed some bugs. subroutine parse_string ( json , unit , str , string ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . json % exception_thrown ) then !initialize: ip = 1 is_hex = . false . escape = . false . i = 0 do !get the next character from the file: c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . false .) if ( eof ) then call json % throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . . not . escape ) then !end of string if ( is_hex ) call json % throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = '' is_hex = . false . else call json % throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = '' else string = string ( 1 : ip - 1 ) end if end if end if end subroutine parse_string !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. subroutine parse_for_chars ( json , unit , str , chars ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . json % exception_thrown ) then length = len_trim ( chars ) do i = 1 , length c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing array.' ) return else if ( c /= chars ( i : i )) then call json % throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character.: \"' // c // '\" ' // chars ( i : i )) return end if end do end if end subroutine parse_for_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Read a numerical value from the file (or string). !  The routine will determine if it is an integer or a double, and !  allocate the type accordingly. ! !@note Complete rewrite of the original FSON routine, which had some problems. subroutine parse_number ( json , unit , str , value ) implicit none class ( json_core ), intent ( inout ) :: json integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer integer ( IK ) :: ip !! index to put next character !! [to speed up by reducing the number !! of character string reallocations] if (. not . json % exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: c = json % pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call json % throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call json % push_char ( c ) !string to value: if ( is_integer ) then ival = json % string_to_integer ( tmp ) call to_integer ( value , ival ) else rval = json % string_to_double ( tmp ) call to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number !***************************************************************************************** !***************************************************************************************** !> !  Get the next character from the file (or string). ! !# See also !  * [[push_char]] ! !@note This routine ignores non-printing ASCII characters (iachar<=31) that are in strings. recursive function pop_char ( json , unit , str , eof , skip_ws ) result ( popped ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ) :: popped !! the popped character. integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) -- only used if unit=0 logical ( LK ), intent ( out ) :: eof !! true if the end of the file has been reached. logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace. integer ( IK ) :: ios , str_len character ( kind = CK , len = 1 ) :: c logical ( LK ) :: ignore if (. not . json % exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if do if ( json % pushed_index > 0 ) then ! there is a character pushed back on, most likely ! from the number parsing. Note: this can only occur if ! reading from a file when use_unformatted_stream=.false. c = json % pushed_char ( json % pushed_index : json % pushed_index ) json % pushed_index = json % pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = json % ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if json % ipos = json % ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( json % ipos <= str_len ) then c = str ( json % ipos : json % ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if json % ipos = json % ipos + 1 end if json % char_count = json % char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file json % char_count = 0 eof = . true . exit else if ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record json % char_count = 0 json % line_count = json % line_count + 1 cycle end if end if if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then cycle else popped = c exit end if end do end if end function pop_char !***************************************************************************************** !***************************************************************************************** !> !  Core routine. ! !# See also !  * [[pop_char]] ! !# History !  * Jacob Williams : 5/3/2015 : replaced original version of this routine. subroutine push_char ( json , c ) implicit none class ( json_core ), intent ( inout ) :: json character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = max_numeric_str_len ) :: istr if (. not . json % exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: json % ipos = json % ipos - 1 else json % pushed_index = json % pushed_index + 1 if ( json % pushed_index > 0 . and . json % pushed_index <= len ( json % pushed_char )) then json % pushed_char ( json % pushed_index : json % pushed_index ) = c else call integer_to_string ( json % pushed_index , int_fmt , istr ) call json % throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if end if end subroutine push_char !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Print any error message, and then clear the exceptions. ! !@note This routine is used by the unit tests. !      It was originally in json_example.f90, and was !      moved here 2/26/2015 by Izaak Beekman. subroutine json_print_error_message ( json , io_unit ) implicit none class ( json_core ), intent ( inout ) :: json integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg !! error message logical :: status_ok !! false if there were any errors thrown !get error message: call json % check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( output_unit , '(A)' ) error_msg end if deallocate ( error_msg ) call json % clear_exceptions () end if end subroutine json_print_error_message !***************************************************************************************** !***************************************************************************************** end module json_value_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_value_module.f90.html","title":"json_value_module.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> ! Module for the first unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_1_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename1 = 'test1.json' contains subroutine test_1 ( error_cnt ) !! Read a sample JSON file and retrieve some data from it implicit none type ( json_file ) :: json !! the JSON structure read from the file type ( json_value ), pointer :: p !! a pointer for low-level manipulations type ( json_core ) :: core !! factory for manipulating `json_value` pointers integer , intent ( out ) :: error_cnt integer :: ival character ( kind = json_CK , len = :), allocatable :: cval real ( wp ) :: rval logical :: found error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 1' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file ' // dir // filename1 call json % load_file ( filename = dir // filename1 ) if ( json % failed ()) then !if there was an error reading the file call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the file...' write ( output_unit , '(A)' ) '{ \"part a\" :' !Wrap 3 outputs to make stdout valid json call json % print_file () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'get some data from the file...' write ( error_unit , '(A)' ) '' call json % get ( 'version.svn' , ival ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,I5)' ) 'version.svn = ' , ival end if write ( error_unit , '(A)' ) '' call json % get ( 'data(1).array(2)' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'data(1).array(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(1)' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(1) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(2)' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(3)' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(3) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'data(2).real' , rval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,E30.16)' ) 'data(2).real = ' , rval end if write ( error_unit , '(A)' ) '' call json % get ( 'files[4]' , cval ) !has hex characters if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[4] = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files[5]' , cval ) !string with spaces and no escape characters if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[5] = ' // trim ( cval ) end if ! ! Test of values that aren't there: ! Note: when using the \"found\" output, the exceptions are cleared automatically. ! write ( error_unit , '(A)' ) '' call json % get ( 'files[10]' , cval , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'files[10] not in file.' else write ( error_unit , '(1x,A)' ) 'files[10] = ' // trim ( cval ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' call json % get ( 'version.blah' , ival , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'version.blah not in file.' else write ( error_unit , '(A)' ) 'version.blah = ' , ival error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test removing data from the json structure:' call json % get ( 'files' , p ) !in the middle of a list if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else call core % initialize () call core % remove ( p ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if call json % get ( 'data(1).array' , p ) !at the end of a list if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else call core % initialize () call core % remove ( p ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if call json % get ( 'data(2).number' , p ) !at the beginning of a list if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else call core % initialize () call core % remove ( p ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part b\" : ' call json % print_file () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test replacing data from the json structure:' call json % get ( 'data(1)' , p ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else call core % initialize () call core % update ( p , 'name' , 'Cuthbert' , found ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if !call json%get('data(2)', p) !call json%update(p,'real',[1.0_wp, 2.0_wp, 3.0_wp],found)   !don't have one like this yet... !use the json_file procedure to update a variable: call json % update ( 'version.svn' , 999 , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part c\" : ' call json % print_file () write ( output_unit , '(A)' ) '}' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_1 end module jf_test_1_mod !***************************************************************************************** !***************************************************************************************** program jf_test_1 !! First unit test. use jf_test_1_mod , only : test_1 implicit none integer :: n_errors n_errors = 0 call test_1 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_1 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_1.f90.html","title":"jf_test_1.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 3/10/2015 ! ! Module for the tenth unit test. module jf_test_10_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: filename = 'test1.json' character ( len =* ), parameter :: dir = '../files/inputs/' !working directory contains subroutine test_10 ( error_cnt ) !! Test some of the lesser-used features of the library implicit none integer , intent ( out ) :: error_cnt character ( kind = json_CK , len = 256 ), dimension (:), allocatable :: str_vec type ( json_file ) :: f , f2 type ( json_value ), pointer :: p type ( json_core ) :: json !! factory for manipulating `json_value` pointers character ( kind = json_CK , len = :), allocatable :: str , name logical :: found , lval integer :: var_type , n_children character ( kind = json_CDK , len =* ), parameter :: json_str = '{ \"blah\": 123 }' error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 10 ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) // '...' call f % load_file ( dir // filename ) ! will call initialize() if ( f % failed ()) then call f % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_move_pointer...' call f2 % initialize () call f2 % move ( f ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_load_from_string...' call f % load_from_string ( json_str ) if ( f % failed ()) then call f % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_print_to_string...' call f % print_to_string ( str ) if ( f % failed ()) then call f % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_variable_info...' call f % info ( 'blah' , found , var_type , n_children ) if ( f % failed ()) then call f % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( var_type == json_integer . and . n_children == 0 ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error invalid values:' , var_type , n_children error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_get_logical...' call f2 % get ( 'data(1).tf1' , lval , found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . lval ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result.' error_cnt = error_cnt + 1 end if end if ! json_file_get_logical_vec .... [add this] write ( error_unit , '(A)' ) 'json_file_get_string_vec...' call f2 % get ( 'files' , str_vec , found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 6 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable present]...' call f2 % update ( 'data(1).tf1' ,. false ., found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable not present]...' call f2 % update ( 'new_logical' ,. true ., found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_real [variable present]...' call f2 % update ( 'data[2].real' , 10 0.0 d0 , found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_real [variable not present]...' call f2 % update ( 'new_real' , 177 6.0 d0 , found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_string [variable present]...' call f2 % update ( 'version.string' , '10.0.0' , found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_string [variable not present]...' call f2 % update ( 'new_string' , 'foo' , found ) if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_get_integer...' call f2 % get ( '$' , p , found ) !get root if ( f2 % failed ()) then call f2 % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' write ( error_unit , '(A)' ) 'json_info...' call json % info ( p , var_type , n_children , name ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_remove_if_present...' call json % remove_if_present ( p , 'version.patch' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_logical...' call json % update ( p , 'data(1).tf1' ,. true ., found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_double...' call json % update ( p , 'data(2).real' , - 1.0 d0 , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_logical...' call json % get ( p , 'data(1).tf1' , lval , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_string_vec...' call json % get ( p , 'files' , str_vec , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 6 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_create...' write ( error_unit , '(A)' ) 'json_create_logical...' ; call json % destroy ( p ); call json % create_logical ( p ,. true ., 'foo' ) write ( error_unit , '(A)' ) 'json_create_integer...' ; call json % destroy ( p ); call json % create_integer ( p , 1000 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_double ...' ; call json % destroy ( p ); call json % create_double ( p , 9.0 d0 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_string ...' ; call json % destroy ( p ); call json % create_string ( p , 'foo' , 'bar' ) write ( error_unit , '(A)' ) 'json_create_null   ...' ; call json % destroy ( p ); call json % create_null ( p , 'foo' ) write ( error_unit , '(A)' ) 'json_create_object ...' ; call json % destroy ( p ); call json % create_object ( p , 'foo' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- !cleanup: !call f%destroy()   !WARNING: causing \"pointer being freed was not allocated\" errors.... need to investigate !call f2%destroy() end subroutine test_10 end module jf_test_10_mod !***************************************************************************************** !***************************************************************************************** program jf_test_10 !! Tenth unit test. use jf_test_10_mod , only : test_10 implicit none integer :: n_errors n_errors = 0 call test_10 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_10 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_10.f90.html","title":"jf_test_10.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Izaak Beekman !  date: 3/13/2015 ! ! Module for the 11th unit test to test unicode support if enabled. module jf_test_11_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory #ifdef USE_UCS4 character ( len =* ), parameter :: unicode_file = 'hello-world-ucs4.json' #endif character ( len =* ), parameter :: ascii_equivalent = 'hello-world-ascii.json' contains subroutine test_11 ( error_cnt ) !! Read the file and extract some data from it. implicit none integer , intent ( out ) :: error_cnt character ( kind = json_CK , len = :), allocatable :: cval type ( json_file ) :: json !the JSON structure read from the file: # ifdef USE_UCS4 type ( json_file ) :: clone # endif error_cnt = 0 write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 11' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' # ifdef USE_UCS4 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // unicode_file call json % load_file ( filename = dir // unicode_file ) if ( json % failed ()) then !if there was an error reading the file call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' call clone % load_from_string ( cval ) if ( clone % failed ()) then call clone % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call clone % print_file ( output_unit ) if ( clone % failed ()) then call clone % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // unicode_file // '\"' call clone % print_file ( '../files/' // unicode_file ) if ( clone % failed () ) then call clone % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call clone % destroy () if ( clone % failed ()) then call clone % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if # endif ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // ascii_equivalent write ( error_unit , '(A)' ) 'This is the ascii equivalent of \"../files/inputs/hello-world-ucs4.json\"' call json % load_file ( filename = dir // ascii_equivalent ) if ( json % failed ()) then !if there was an error reading the file call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call json % print_file ( output_unit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // ascii_equivalent // '\"' call json % print_file ( '../files/' // ascii_equivalent ) if ( json % failed () ) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_11 end module jf_test_11_mod !***************************************************************************************** !***************************************************************************************** program jf_test_11 !! 11th unit test. use jf_test_11_mod , only : test_11 implicit none integer :: n_errors n_errors = 0 call test_11 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_11 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_11.f90.html","title":"jf_test_11.F90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Izaak Beekman !  date: 07/27/2015 ! ! Module for the 12th unit test. module jf_test_12_mod use json_module , CK => json_CK use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! Path to write JSON file to character ( len =* ), parameter :: file = 'test12.json' !! Filename to write real ( wp ), parameter :: TOL = 100 * epsilon ( 1.0_wp ) !! Tolerance for real comparisons contains subroutine test_12 ( error_cnt ) implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller integer , parameter :: imx = 5 , jmx = 3 , kmx = 4 !! dimensions for raw work array of primitive type type ( json_core ) :: json !! factory for manipulating `json_value` pointers integer , dimension ( 3 ) :: shape !! shape of work array integer , dimension (:), allocatable :: fetched_shape !! retrieved shape type ( json_value ), pointer :: root , meta_array !! json nodes to work with type ( json_value ), pointer :: tmp_json_ptr type ( json_file ) :: my_file real ( wp ), dimension ( imx , jmx , kmx ) :: raw_array !! raw work array real ( wp ) :: array_element real ( wp ), dimension (:), allocatable :: fetched_array character ( kind = CK , len = :), allocatable :: description integer :: i , j , k !! loop indices integer :: array_length , lun logical :: existed logical , dimension (:), allocatable :: SOS error_cnt = 0 call json % initialize ( verbose = . true ., real_format = 'G' ) call check_errors () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 12' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! populate the raw array forall ( i = 1 : imx , j = 1 : jmx , k = 1 : kmx ) ! could use size(... , dim=...) instead of constants raw_array ( i , j , k ) = i + ( j - 1 ) * imx + ( k - 1 ) * imx * jmx end forall call json % create_object ( root , dir // file ) call check_errors () call json % create_object ( meta_array , 'array data' ) call check_errors () shape = [ size ( raw_array , dim = 1 ), size ( raw_array , dim = 2 ), size ( raw_array , dim = 3 )] call json % add ( meta_array , 'shape' , shape ) call check_errors () call json % add ( meta_array , 'total size' , size ( raw_array )) call check_errors () call json % update ( meta_array , 'total size' , size ( raw_array ), found = existed ) call check_errors ( existed ) call json % add ( meta_array , CK_ 'description' , 'test data' ) call check_errors () ! now add the array ! N.B. `json_add()` only accepts 1-D arrays and scalars, so transform with `reshape` ! N.B. reshape populates new array in \"array element order\". ! C.F. \"Modern Fortran Explained\", by Metcalf, Cohen and Reid, p. 24. ! N.B. Fortran is a column major language call json % add ( meta_array , 'data' , reshape ( raw_array , [ size ( raw_array ) ] ) ) call check_errors () ! now put it all together call json % add ( root , meta_array ) call check_errors () write ( error_unit , '(A)' ) \"Print the JSON object to stderr:\" call json % print ( root , error_unit ) call check_errors () call json % get ( root , '$.array data.data(1)' , array_element ) call check_errors ( abs ( array_element - 1.0_wp ) <= TOL ) call json % get ( root , '@.array data.shape' , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json % update ( meta_array , 'description' , CK_ 'Test Data' , found = existed ) call check_errors ( existed ) call json % update ( meta_array , CK_ 'description' , 'Test data' , found = existed ) call check_errors ( existed ) call json % get ( meta_array , 'description' , description ) call check_errors ( 'Test data' == description ) call json % get ( root , 'array data.total size' , array_length ) call check_errors ( array_length == imx * jmx * kmx ) sos = [. true ., . true ., . true ., & . false ., . false ., . false ., & . true ., . true ., . true .] call json % add ( root , 'SOS' , sos ) call check_errors () call json % get ( root , 'SOS' , sos ) call check_errors () call json % add ( root , 'vector string' , [ CK_ 'only one value' ]) call check_errors () call json % add ( root , CK_ 'page' , [ 'The quick brown fox     ' , 'jumps over the lazy dog.' ]) call check_errors () call json % get ( root , 'SOS' , tmp_json_ptr ) call check_errors () call json % get ( tmp_json_ptr , sos ) call check_errors () call json % get ( meta_array , 'shape' , tmp_json_ptr ) call check_errors () call json % get ( tmp_json_ptr , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json % get ( meta_array , 'data' , tmp_json_ptr ) call check_errors () call json % get ( tmp_json_ptr , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call json % get ( root , 'array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) raw_array = 0 call json % get ( me = root , path = 'array data.data' , array_callback = get_3D_from_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) my_file = json_file ( root , verbose = . true ., real_format = 'G' ) call my_file % update ( 'array data.description' , CK_ 'vector data' , found = existed ) call check_file_errors ( existed ) call my_file % update ( CK_ 'array data.description' , 'Vector data' , found = existed ) call check_file_errors ( existed ) call my_file % get ( 'SOS' , sos ) call check_file_errors () call my_file % get ( '$array data.data' , fetched_array ) call check_file_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call my_file % get ( tmp_json_ptr ) call check_file_errors ( associated ( tmp_json_ptr , root )) open ( file = dir // file , newunit = lun , form = 'formatted' , action = 'write' ) call my_file % print_file ( lun ) call check_file_errors () close ( lun ) contains subroutine check_errors ( assertion ) !! check for errors in `json` implicit none logical , optional , intent ( in ) :: assertion if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( present ( assertion )) then if (. not . assertion ) error_cnt = error_cnt + 1 end if end subroutine check_errors subroutine check_file_errors ( assertion ) !! check for errors in `my_file` implicit none logical , optional , intent ( in ) :: assertion if ( my_file % failed ()) then call my_file % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( present ( assertion )) then if (. not . assertion ) error_cnt = error_cnt + 1 end if end subroutine check_file_errors subroutine get_3D_from_array ( json , element , i , count ) !! array callback function implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: element integer , intent ( in ) :: i !! index integer , intent ( in ) :: count !! size of array integer :: useless !! assign count to this to silence warnings ! let's pretend we're c programmers! call json % get ( element , raw_array ( & mod ( i - 1 , imx ) + 1 , & ! i index mod (( i - 1 ) / imx , jmx ) + 1 , & ! j index mod (( i - 1 ) / imx / jmx , kmx ) + 1 ) ) ! k inded useless = count end subroutine get_3D_from_array end subroutine test_12 end module jf_test_12_mod !***************************************************************************************** !***************************************************************************************** program jf_test_12 !! 12th unit test. use jf_test_12_mod , only : test_12 implicit none integer :: n_errors n_errors = 0 call test_12 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_12 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_12.f90.html","title":"jf_test_12.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 09/01/2015 ! ! Module for the 13th unit test. module jf_test_13_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none contains subroutine test_13 ( error_cnt ) !! Tests different real format strings using repeated calls to [[json_initialize]]. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_file ) :: my_file character ( kind = json_CK , len = :), allocatable :: str integer :: i character ( len = 2 ), dimension ( 5 ), parameter :: fmts = [ 'g ' , 'e ' , 'en' , 'es' , '* ' ] !! format statements to test write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 13' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 do i = 1 , size ( fmts ) call my_file % initialize ( real_format = trim ( fmts ( i ))) call my_file % load_from_string ( '{ \"value\": 1234.56789 }' ) if ( my_file % failed ()) then call my_file % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call my_file % print_to_string ( str ) if ( my_file % failed ()) then call my_file % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( output_unit , '(A)' ) str end if call my_file % destroy () end do end subroutine test_13 end module jf_test_13_mod !***************************************************************************************** !***************************************************************************************** program jf_test_13 !! 13th unit test. use jf_test_13_mod , only : test_13 implicit none integer :: n_errors call test_13 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_13 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_13.f90.html","title":"jf_test_13.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 09/02/2015 ! ! Module for the 14th unit test. module jf_test_14_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename1 = 'test1.json' !! the file to read integer :: icount = 0 !! a count of the number of \"name\" variables found contains subroutine test_14 ( error_cnt ) !! Tests the traversal of a JSON structure !! !! It traverses the structure, looks for all \"name\" variables, and changes the name. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_core ) :: json type ( json_value ), pointer :: p write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 14' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 icount = 0 !number of name changes (should be 2) call json % initialize () !initialize the module call json % parse ( dir // filename1 , p ) !read the file if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % traverse ( p , rename ) !traverse all nodes in the structure if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( icount /= 2 ) then write ( error_unit , '(A)' ) 'Error: should be 2 \"name\" variables in this file: ' // filename1 error_cnt = error_cnt + 1 end if if ( error_cnt == 0 ) then write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' All names changed to Fred:' write ( error_unit , '(A)' ) '' call json % print ( p , output_unit ) write ( error_unit , '(A)' ) '' end if call json % destroy ( p ) !clean up if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_14 subroutine rename ( json , p , finished ) !! change all \"name\" variable values to \"Fred\" implicit none class ( json_core ), intent ( inout ) :: json type ( json_value ), pointer , intent ( in ) :: p logical , intent ( out ) :: finished integer :: var_type character ( kind = json_CK , len = :), allocatable :: str logical :: found !get info about this variable: call json % info ( p , var_type = var_type , name = str ) !it must be a string named \"name\": if ( var_type == json_string . and . str == 'name' ) then call json % get ( p , '@' , str ) ! get original name call json % update ( p , '@' , 'Fred' , found ) ! change it write ( error_unit , '(A)' ) str // ' name changed' icount = icount + 1 end if !cleanup: if ( allocated ( str )) deallocate ( str ) !always false, since we want to traverse all nodes: finished = . false . end subroutine rename end module jf_test_14_mod !***************************************************************************************** !***************************************************************************************** program jf_test_14 !! 14th unit test. use jf_test_14_mod , only : test_14 implicit none integer :: n_errors call test_14 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_14 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_14.f90.html","title":"jf_test_14.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 10/28/2015 ! ! Module for the 15th unit test. ! This one is testing a lot of the error conditions. module jf_test_15_mod use json_module , CK => json_CK use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_15 ( error_cnt ) !! Test some of the edge cases, and incorrect usages. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_core ) :: json type ( json_value ), pointer :: p , p2 type ( json_file ) :: file1 , file2 logical :: found , status_ok integer :: var_type , i , n_children real ( wp ) :: d logical :: tf character ( kind = CK , len = :), allocatable :: error_msg write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 15' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 nullify ( p2 ) nullify ( p ) call json % parse ( p2 , '{\"int\": 1, \"real\": 2.0, \"logical\": true}' ) call json % get ( p2 , 'real' , i ) call json % get ( p2 , 'logical' , i ) call json % get ( p2 , 'integer' , d ) call json % get ( p2 , 'logical' , d ) call json % get ( p2 , 'integer' , tf ) call json % get ( p2 , 'real' , tf ) call json % check_for_errors ( status_ok , error_msg ) !error condition true call json % initialize ( print_signs = . true .) !print signs flag call json % check_for_errors ( status_ok , error_msg ) !error condition false call file1 % move ( file2 ) !should throw an exception since points are not associated call file1 % initialize () call file1 % print_file ( - 1 ) !invalid input call file1 % initialize () call file1 % print_file ( filename = '' ) !invalid filename call file1 % initialize () call file1 % info ( 'this path does not exist' , found , var_type , n_children ) call file1 % initialize () call file1 % check_for_errors ( status_ok , error_msg ) call file1 % clear_exceptions () call file1 % destroy () file1 = json_file ( p2 , json ) !constructor call file1 % destroy ( destroy_core = . true .) call json % initialize ( verbose = . false .,& compact_reals = . true .,& print_signs = . false .,& real_format = 'E' ,& spaces_per_tab = 4 ,& strict_type_checking = . true .,& trailing_spaces_significant = . false .,& case_sensitive_keys = . true .) call json % get_child ( p2 , - 99 , p ) !invalid index call json % initialize () !clear exceptions call json % get_child ( p2 , 'this child does not exist' , p ) !invalid index call json % initialize () !clear exceptions call json % print ( p2 , - 1 ) !invalid input call json % initialize () !clear exceptions call json % print ( p2 , filename = '' ) !invalid input call json % initialize () !clear exceptions end subroutine test_15 end module jf_test_15_mod !***************************************************************************************** !***************************************************************************************** program jf_test_15 !! 15th unit test. use jf_test_15_mod , only : test_15 implicit none integer :: n_errors call test_15 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_15 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_15.f90.html","title":"jf_test_15.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 4/26/2016 ! ! Module for the 16th unit test. ! Test the `swap` function. module jf_test_16_mod use json_module , CK => json_CK use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none contains subroutine test_16 ( error_cnt ) !! Test the `swap` function. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_core ) :: json type ( json_value ), pointer :: p , p1 , p2 write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 16' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Original:' call json % parse ( p , '{\"cities\": [\"New York\",\"Los Angeles\",\"Chicago\"], ' // & '\"value\": 1, \"iflag\": true, \"struct\":{\"vec\":[1,2,3]}}' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , error_unit ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: cities <-> iflag' call json % get ( p , 'cities' , p1 ) call json % get ( p , 'iflag' , p2 ) call json % swap ( p1 , p2 ) call json % print ( p , output_unit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( p1 ) nullify ( p2 ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: iflag <-> value' call json % get ( p , 'iflag' , p1 ) call json % get ( p , 'value' , p2 ) call json % swap ( p1 , p2 ) call json % print ( p , output_unit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( p1 ) nullify ( p2 ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: iflag <-> struct.vec' call json % get ( p , 'iflag' , p1 ) call json % get ( p , 'struct.vec' , p2 ) call json % swap ( p1 , p2 ) call json % print ( p , output_unit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( p1 ) nullify ( p2 ) call json % destroy ( p ) !........................................................................... ! another case write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '.....................................' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Original:' call json % parse ( p , '{ \"stats\": { \"iflag\": 0, \"str\": \"ok\" },' // & '\"vars\": [{ \"label\": \"r\", \"value\": 0.0 }, ' // & '{ \"label\": \"v\", \"value\": 0.0 }],' // & '\"empty\": { } }' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , error_unit ) !this one is not allowed, and should fail: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: vars(1).label <-> vars' call json % get ( p , 'vars(1).label' , p1 ) call json % get ( p , 'vars' , p2 ) call json % swap ( p1 , p2 ) call json % print ( p , output_unit ) if (. not . json % failed ()) then write ( error_unit , '(A)' ) 'Error: this should have failed.' error_cnt = error_cnt + 1 else call json % clear_exceptions () end if nullify ( p1 ) nullify ( p2 ) !this one should work: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: empty <-> stats.str' call json % get ( p , 'empty' , p1 ) call json % get ( p , 'stats.str' , p2 ) call json % swap ( p1 , p2 ) call json % print ( p , output_unit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( p1 ) nullify ( p2 ) call json % destroy ( p ) !........................................................................... ! other special cases: !swap first and last items in a list write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '.....................................' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Original:' call json % parse ( p , '{ \"color\": \"red\", \"width\": 10, \"height\": 2 }' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , error_unit ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: color <-> height' call json % get ( p , 'color' , p1 ) call json % get ( p , 'height' , p2 ) call json % swap ( p1 , p2 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , output_unit ) nullify ( p1 ) nullify ( p2 ) call json % destroy ( p ) !p2 is first child: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '.....................................' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Original:' call json % parse ( p , '{ \"color\": \"red\", \"width\": 10, \"height\": 2 }' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , error_unit ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: width <-> color' call json % get ( p , 'width' , p1 ) call json % get ( p , 'color' , p2 ) call json % swap ( p1 , p2 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , output_unit ) nullify ( p1 ) nullify ( p2 ) call json % destroy ( p ) !p2 is last child: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '.....................................' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Original:' call json % parse ( p , '{ \"color\": \"red\", \"width\": 10, \"height\": 2 }' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , error_unit ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Swap: width <-> height' call json % get ( p , 'width' , p1 ) call json % get ( p , 'height' , p2 ) call json % swap ( p1 , p2 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , output_unit ) nullify ( p1 ) nullify ( p2 ) call json % destroy ( p ) end subroutine test_16 end module jf_test_16_mod !***************************************************************************************** !***************************************************************************************** program jf_test_16 !! 16th unit test. use jf_test_16_mod , only : test_16 implicit none integer :: n_errors call test_16 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_16 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_16.f90.html","title":"jf_test_16.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 4/29/2016 ! ! Module for the 17th unit test. ! Test the `rename` function. module jf_test_17_mod use json_module , CK => json_CK use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none contains subroutine test_17 ( error_cnt ) !! Test the `rename` function. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_core ) :: json type ( json_value ), pointer :: p , q write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 17' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Original:' call json % parse ( p , '{\"city\": [\"New York\",\"Los Angeles\",\"Chicago\"], ' // & '\"value\": 1, \"iflag\": true, \"struct\":{\"vec\":[1,2,3]}}' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % print ( p , error_unit ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Rename: \"city\" to \"cities\"' call json % get ( p , 'city' , q ) call json % rename ( q , 'cities' ) call json % print ( p , output_unit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( q ) !verify that it was renamed: call json % get ( p , 'cities' , q ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'Success!' end if nullify ( q ) !cleanup: call json % destroy ( p ) end subroutine test_17 end module jf_test_17_mod !***************************************************************************************** !***************************************************************************************** program jf_test_17 !! 17th unit test. use jf_test_17_mod , only : test_17 implicit none integer :: n_errors call test_17 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_17 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_17.f90.html","title":"jf_test_17.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 4/30/2016 ! ! Module for the 18th unit test. ! Test the name matching options. module jf_test_18_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none contains subroutine test_18 ( error_cnt ) !! Test the name matching options. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_core ) :: json type ( json_value ), pointer :: p integer :: ival logical :: found logical , dimension ( 4 ) :: ok write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 18' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 call json % parse ( p , '{ \"a\" :{\"val\"  : 1},' // & ' \"A\" :{\"Val\"  : 2},' // & ' \"a \":{\"val  \": 3},' // & ' \"A \":{\"Val  \": 4} }' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' call json % print ( p , error_unit ) write ( error_unit , '(A)' ) '' call json % initialize ( trailing_spaces_significant = . true .,& case_sensitive_keys = . true .) call go ([ 1 , 2 , 3 , 4 ]) call json % initialize ( trailing_spaces_significant = . false .,& case_sensitive_keys = . true .) call go ([ 1 , 2 , 1 , 2 ]) call json % initialize ( trailing_spaces_significant = . true .,& case_sensitive_keys = . false .) call go ([ 1 , 1 , 3 , 3 ]) call json % initialize ( trailing_spaces_significant = . false .,& case_sensitive_keys = . false .) call go ([ 1 , 1 , 1 , 1 ]) !cleanup: call json % destroy ( p ) contains subroutine go ( iresult ) !! run test and get results implicit none integer , dimension ( 4 ), intent ( in ) :: iresult !! correct answers call json % get ( p , 'a.val' , ival , found ); ok ( 1 ) = ival == iresult ( 1 ) call json % get ( p , 'A.Val' , ival , found ); ok ( 2 ) = ival == iresult ( 2 ) call json % get ( p , 'a .val  ' , ival , found ); ok ( 3 ) = ival == iresult ( 3 ) call json % get ( p , 'A .Val  ' , ival , found ); ok ( 4 ) = ival == iresult ( 4 ) write ( error_unit , '(A)' ) '' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( all ( ok )) then write ( error_unit , '(A)' ) 'Test passed!' else write ( error_unit , * ) ok error_cnt = error_cnt + 1 write ( error_unit , '(A)' ) 'Test failed!' end if end subroutine go end subroutine test_18 end module jf_test_18_mod !***************************************************************************************** !***************************************************************************************** program jf_test_18 !! 18th unit test. use jf_test_18_mod , only : test_18 implicit none integer :: n_errors call test_18 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_18 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_18.f90.html","title":"jf_test_18.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> !  Module for the second unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_2_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! working directory character ( len =* ), parameter :: filename2 = 'test2.json' contains subroutine test_2 ( error_cnt ) !! Populate a JSON structure and write it to a file. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp , traj , tmp1 , tmp2 , p_tmp , p_integer_array , p_clone type ( json_core ) :: json !! factory for manipulating `json_value` pointers integer :: iunit character ( kind = json_CK , len = :), allocatable :: name integer :: ival , ival_clone logical :: found logical :: is_valid character ( kind = json_CK , len = :), allocatable :: error_msg write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 2' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !root: call json % create_object ( p , dir // filename2 ) ! create the value and associate the pointer ! add the file name as the name of the overall structure if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'initialize the structure...' !config structure: call json % create_object ( inp , 'inputs' ) !an object if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( p , inp ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !test get_parent: call json % get_parent ( inp , tmp1 ) !will be root call json % get_parent ( tmp1 , tmp2 ) !has no parent -> null() !trajectory structure: call json % create_array ( traj , 'trajectory' ) !an array if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( p , traj ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'adding some data to structure...' !add some variables: !input variables: call json % add ( inp , 't0' , 0.1_wp ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'tf' , 1.1_wp ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'x0' , 999 9.000_wp ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'integer_scalar' , 1 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'logical_scalar' , . true .) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( inp , 'logical_vector' , [. true ., . false ., . true .]) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) !trajectory variables: call add_variables_to_input ( json , traj , 'Rx' , 'km' , 'J2000' , 'EARTH' , [ 1.0_wp , 2.0_wp , 3.0_wp ], error_cnt ) call add_variables_to_input ( json , traj , 'Ry' , 'km' , 'J2000' , 'EARTH' , [ 1 0.0_wp , 2 0.0_wp , 3 0.0_wp ], error_cnt ) call add_variables_to_input ( json , traj , 'Rz' , 'km' , 'J2000' , 'EARTH' , [ 10 0.0_wp , 20 0.0 d0 , 30 0.0_wp ], error_cnt ) call add_variables_to_input ( json , traj , 'Vx' , 'km/s' , 'J2000' , 'EARTH' , [ 1.0e-3_wp , 2.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( json , traj , 'Vy' , 'km/s' , 'J2000' , 'EARTH' , [ 2.0e-3_wp , 2 0.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( json , traj , 'Vz' , 'km/s' , 'J2000' , 'EARTH' , [ 3.0e-3_wp , 3 0.0e-3_wp , 4 0.0e-3_wp ], error_cnt ) nullify ( traj ) !validate it: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'validating...' call json % validate ( p , is_valid , error_msg ) if (. not . is_valid ) then write ( error_unit , '(A)' ) 'Error: p is not a valid JSON linked list: ' // error_msg error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'writing file ' // trim ( dir // filename2 ) // '...' open ( newunit = iunit , file = dir // filename2 , status = 'REPLACE' ) call json % print ( p , iunit ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if close ( iunit ) !test the deep copy routine: write ( error_unit , '(A)' ) 'json_clone test' call json % clone ( p , p_clone ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=============' write ( error_unit , '(A)' ) ' p_clone' write ( error_unit , '(A)' ) '=============' call json % print ( p_clone , error_unit ) write ( error_unit , '(A)' ) '=============' write ( error_unit , '(A)' ) '' if (. not . associated ( p )) write ( error_unit , '(A)' ) 'ERROR: p has become unassociated' if (. not . associated ( p_clone )) write ( error_unit , '(A)' ) 'ERROR: p_clone is not associated' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !now, change one and verify that they are independent: call json % update ( p_clone , 'inputs.integer_scalar' , 100 , found ) if ( json % failed ()) write ( error_unit , '(A)' ) 'json%update Error for p_clone' call json % get ( p , 'inputs.integer_scalar' , ival ) if ( json % failed ()) write ( error_unit , '(A)' ) 'json%get Error for p' call json % get ( p_clone , 'inputs.integer_scalar' , ival_clone ) if ( json % failed ()) write ( error_unit , '(A)' ) 'json%get Error for p_clone' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( ival == 1 . and . ival_clone == 100 ) then write ( error_unit , '(A)' ) 'json%clone ... passed' else write ( error_unit , '(A)' ) 'Error: ival /= ival_clone' error_cnt = error_cnt + 1 end if end if end if !test some of the pointer routines: write ( error_unit , '(A)' ) 'Pointer routine tests' call json % get ( p , 'inputs.integer_array' , p_integer_array ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !get parent test: call json % get_parent ( p_integer_array , p_tmp ) !should be \"inputs\" call json % info ( p_tmp , name = name ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( name == 'inputs' ) then write ( error_unit , '(A)' ) 'json%get_parent ... passed' else write ( error_unit , '(A)' ) 'Error: parent should be \"inputs\", is actually: ' // trim ( name ) error_cnt = error_cnt + 1 end if end if !get next test: call json % get_next ( p_integer_array , p_tmp ) !should be \"names\" call json % info ( p_tmp , name = name ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( name == 'names' ) then write ( error_unit , '(A)' ) 'json%get_next ... passed' else write ( error_unit , '(A)' ) 'Error: next should be \"names\", is actually: ' // trim ( name ) error_cnt = error_cnt + 1 end if end if !get previous test: call json % get_previous ( p_integer_array , p_tmp ) !should be \"integer_scalar\" call json % info ( p_tmp , name = name ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( name == 'integer_scalar' ) then write ( error_unit , '(A)' ) 'json%get_previous ... passed' else write ( error_unit , '(A)' ) 'Error: next should be \"integer_scalar\", is actually: ' // trim ( name ) error_cnt = error_cnt + 1 end if end if !get tail test: call json % get_tail ( p_integer_array , p_tmp ) !should be 99, the last element in the array call json % get ( p_tmp , ival ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( ival == 99 ) then write ( error_unit , '(A)' ) 'json%get_tail ... passed' else write ( error_unit , '(A,1X,I5)' ) 'Error: tail value should be 99, is actually: ' , ival error_cnt = error_cnt + 1 end if end if end if !cleanup: call json % destroy ( p ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_2 subroutine add_variables_to_input ( json , me , variable , units , frame , center , rdata , error_cnt ) !Used by test_2. implicit none type ( json_core ), intent ( inout ) :: json type ( json_value ), pointer :: me character ( len =* ), intent ( in ) :: variable , units , frame , center real ( wp ), dimension (:), intent ( in ) :: rdata integer , intent ( inout ) :: error_cnt type ( json_value ), pointer :: var !a variable in the trajectory: !initialize: nullify ( var ) !create the object before data can be added: call json % create_object ( var , '' ) !name does not matter if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !variable info: call json % add ( var , 'VARIABLE' , trim ( variable )) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( var , 'UNITS' , trim ( units )) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( var , 'FRAME' , trim ( frame )) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( var , 'CENTER' , trim ( center )) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory [vector of reals]: call json % add ( var , 'DATA' , rdata ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add this variable to trajectory structure: call json % add ( me , var ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !cleanup: nullify ( var ) end subroutine add_variables_to_input end module jf_test_2_mod !***************************************************************************************** !***************************************************************************************** program jf_test_2 !! Second unit test. use jf_test_2_mod , only : test_2 implicit none integer :: n_errors n_errors = 0 call test_2 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_2 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_2.f90.html","title":"jf_test_2.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> ! Module for the third unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_3_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !working directory character ( len =* ), parameter :: filename2 = 'test2.json' contains subroutine test_3 ( error_cnt ) !! Read the file generated in [[test_2]], and extract some data from it. implicit none integer , intent ( out ) :: error_cnt integer :: ival character ( kind = json_CK , len = :), allocatable :: cval real ( wp ) :: rval type ( json_file ) :: json !the JSON structure read from the file: integer :: i character ( kind = json_CK , len = 10 ) :: str real ( wp ), dimension (:), allocatable :: rvec write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 3' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // filename2 call json % load_file ( filename = dir // filename2 ) if ( json % failed ()) then !if there was an error reading the file call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' !get scalars: write ( error_unit , '(A)' ) '' call json % get ( 'inputs.integer_scalar' , ival ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,I5)' ) 'inputs.integer_scalar = ' , ival end if !get one element from a vector: write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(1).DATA(2)' , rval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,F30.16)' ) 'trajectory(1).DATA(2) = ' , rval end if !get vectors: do i = 1 , 4 write ( str , fmt = '(I10)' ) i str = adjustl ( str ) write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(' // trim ( str ) // ').VARIABLE' , cval ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'trajectory(' // trim ( str ) // ').VARIABLE = ' // trim ( cval ) !...get the vector using the callback method: call json % get ( 'trajectory(' // trim ( str ) // ').DATA' , rvec ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,*(F30.16,1X))' ) 'trajectory(' // trim ( str ) // ').DATA = ' , rvec end if end if end do end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_3 end module jf_test_3_mod !***************************************************************************************** !***************************************************************************************** program jf_test_3 !! Third unit test. use jf_test_3_mod , only : test_3 implicit none integer :: n_errors n_errors = 0 call test_3 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_3 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_3.f90.html","title":"jf_test_3.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> ! Module for the forth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_4_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! working directory character ( len =* ), parameter :: filename4 = 'test4.json' contains subroutine test_4 ( error_cnt ) !! Populate a JSON structure, write it to a file, !! then read it. !! !! Also tests the json_value_to_string routine to write !! the file to a character string. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp type ( json_file ) :: json type ( json_core ) :: core !! factory for manipulating `json_value` pointers integer :: i character ( kind = json_CK , len = 10 ) :: istr character ( kind = json_CK , len = :), allocatable :: string error_cnt = 0 call core % initialize () if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 4' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'creating structure' call core % create_object ( p , dir // filename4 ) !create the value and associate the pointer !add the file name as the name of the overall structure if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !config structure: call core % create_object ( inp , 'INPUTS' ) !an object if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add just integers: do i = 1 , 100 write ( istr , fmt = '(I10)' ) i istr = adjustl ( istr ) call core % add ( inp , 'x' // trim ( istr ), i ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do call core % add ( p , inp ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to file' !write the file: call core % print ( p , trim ( dir // filename4 )) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to string' write ( error_unit , '(A)' ) '' !write it to a string, and print to console: call core % print_to_string ( p , string ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) string deallocate ( string ) !cleanup !cleanup: call core % destroy ( p ) if ( core % failed ()) then call core % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'read file' call json % load_file ( filename = dir // filename4 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'cleanup' call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_4 end module jf_test_4_mod !***************************************************************************************** !***************************************************************************************** program jf_test_4 !! Fourth unit test. use jf_test_4_mod , only : test_4 implicit none integer :: n_errors n_errors = 0 call test_4 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_4 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_4.f90.html","title":"jf_test_4.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> ! Module for the fifth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_5_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename5 = 'test5.json' contains subroutine test_5 ( error_cnt ) !! Github issue example: https://github.com/josephalevin/fson/issues/12 !! !! Read an existing file and extract some variables. implicit none integer , intent ( out ) :: error_cnt integer :: vv integer , dimension (:), allocatable :: vvv real ( wp ) :: d type ( json_file ) :: json logical :: found error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 5' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) 'load file...' call json % load_file ( filename = dir // filename5 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console: write ( error_unit , '(A)' ) 'print file...' call json % print_file () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'extract data...' write ( error_unit , '(A)' ) '--------------------------' call json % get ( 'Correl.ID2' , vv , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,I5)' ) 'vv = ' , vv call json % get ( 'Correl.ID1' , vvv , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,*(I5,1X))' ) 'vvv= ' , vvv call json % get ( 'Prior[3].mode' , d , found ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,E30.16)' ) 'd  = ' , d write ( error_unit , '(A)' ) '' end if ! clean up call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_5 end module jf_test_5_mod !***************************************************************************************** !***************************************************************************************** program jf_test_5 !! Fifth unit test. use jf_test_5_mod , only : test_5 implicit none integer :: n_errors n_errors = 0 call test_5 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_5 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_5.f90.html","title":"jf_test_5.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> !  Module for the sixth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_6_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory contains subroutine test_6 ( error_cnt ) !! This example tries to read an invalid JSON file. implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json integer :: i character ( len =* ), dimension ( 2 ), parameter :: files = [ 'invalid.json ' ,& 'invalid2.json' ] error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 6 : invalid JSON files' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' do i = 1 , 2 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'load file: ' // trim ( files ( i )) write ( error_unit , '(A)' ) '' call json % load_file ( filename = dir // trim ( files ( i ))) if ( json % failed ()) then call json % print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'An error should have been raised!' error_cnt = error_cnt + 1 end if ! clean up call json % destroy () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do end subroutine test_6 end module jf_test_6_mod !***************************************************************************************** !***************************************************************************************** program jf_test_6 !! Sixth unit test. use jf_test_6_mod , only : test_6 implicit none integer :: n_errors n_errors = 0 call test_6 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_6 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_6.f90.html","title":"jf_test_6.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> !  Module for the seventh unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_7_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_7 ( error_cnt ) !! Indent test implicit none integer , intent ( out ) :: error_cnt type ( json_core ) :: json !! factory for manipulating `json_value` pointers type ( json_value ), pointer :: root , a , b , c , d , e , e1 , e2 , escaped_string , p logical :: found character ( kind = json_CK , len = 1 ), dimension (:), allocatable :: strvec character ( kind = json_CK , len = :), allocatable :: string found = . false . error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 7 : indent test' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !----------------------- ! jsonlint indention is !----------------------- !{ !    \"a\": { !        \"ints\": [ !            1, !            2, !            3 !        ], !        \"chars\": [ !            \"a\", !            \"b\", !            \"c\" !        ] !    }, !    \"b\": { !        \"c\": { !            \"val1\": 1066 !        } !    }, !    \"d\": { !        \"val2\": 1815 !    }, !    \"array\": [ !        { !            \"int1\": 1 !        }, !        { !            \"int1\": 1, !            \"int2\": 2 !        } !    ] !    \"escaped string\": \"\\\\\\/\\b\\f\\n\\r\\t\" !} !create a json structure: call json % create_object ( root , 'root' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_object ( a , 'a' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( a , 'ints' , [ 1 , 2 , 3 ]) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_object ( b , 'b' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( a , 'chars' , [ 'a' , 'b' , 'c' ]) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get_child ( a , 'chars' , p ) call json % get ( p , strvec ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_object ( c , 'c' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( c , 'val1' , 1066 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_object ( d , 'd' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( d , 'val2' , 1815 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_array ( e , 'array' ) !objects in an array if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_object ( e1 , '' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( e1 , 'int1' , 1 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % create_object ( e2 , '' ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( e2 , 'int1' , 1 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( e2 , 'int2' , 2 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( e , e1 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( e , e2 ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( root , a ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( root , b ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( b , c ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( root , d ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( root , e ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( root , 'escaped string' ,& '\\/' // & achar ( 8 ) // & achar ( 12 ) // & achar ( 10 ) // & achar ( 13 ) // & achar ( 9 )) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % add ( root , 'wacky string' ,[ 'trim   ' , '  and  ' , ' adjust' , '   left' ],& trim_str = . true ., adjustl_str = . true .) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( a ) !don't need these anymore nullify ( b ) nullify ( c ) nullify ( d ) nullify ( e ) nullify ( e1 ) nullify ( e2 ) nullify ( escaped_string ) call json % print ( root , output_unit ) !print to the console if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! look for the 'escaped string' entry call json % get ( root , 'escaped string' , escaped_string , found ) if ( json % failed () . or . . not . found ) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( escaped_string , string ) if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) \"Fetched unescaped 'escaped string': \" // string ! remove the escaped string entry if ( found ) call json % remove ( escaped_string , destroy = . true .) call json % print ( root , error_unit ) !print to stderr if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % destroy ( root ) !cleanup if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_7 end module jf_test_7_mod !***************************************************************************************** !***************************************************************************************** program jf_test_7 !! Seventh unit test. use jf_test_7_mod , only : test_7 implicit none integer :: n_errors n_errors = 0 call test_7 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_7 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_7.f90.html","title":"jf_test_7.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> !  Module for the eighth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_8_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_8 ( error_cnt ) !! read a JSON structure from a string implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p type ( json_core ) :: json !! factory for manipulating `json_value` pointers character ( len =* ), parameter :: newline = achar ( 10 ) character ( len =* ), parameter :: str = '{ \"label\": \"foo\",' // newline // ' \"value\": \"bar\" }' character ( len =* ), parameter :: str2 = '{ \"label\": \"foo\",' // newline // & '  \"value\": \"bar\",' // newline // & '  \"empty_array\": [],' // newline // & '  \"empty_object\": {}' // newline // & '}' character ( len =* ), parameter :: str_invalid = '{ \"label\": \"foo\",' // newline // ' \"value : \"bar\" }' error_cnt = 0 call json % initialize () if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 8 : read JSON from string' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 1:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json % parse ( str = str , p = p ) ! read it from str if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '{ \"part a\" : ' call json % print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % destroy ( p ) ! cleanup if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 2:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json % parse ( str = str2 , p = p ) ! read it from str if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part b\" : ' call json % print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % destroy ( p ) ! cleanup if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Invalid test:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json % parse ( str = str_invalid , p = p ) ! read it from str if ( json % failed ()) then call json % print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'This should have failed!' error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part c\" : ' call json % print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) '}' if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % destroy ( p ) ! cleanup if ( json % failed ()) then call json % print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_8 end module jf_test_8_mod !***************************************************************************************** !***************************************************************************************** program jf_test_8 !! Eighth unit test. use jf_test_8_mod , only : test_8 implicit none integer :: n_errors n_errors = 0 call test_8 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_8 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_8.f90.html","title":"jf_test_8.f90 – Fortran Program"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 3/2/2015 ! ! Module for the ninth unit test. module jf_test_9_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none !small file - 0.0 sec : http://www.json-generator.com !character(len=*),parameter :: filename = 'random1.json' !7 MB - 5.4 sec : http://www.json-generator.com character ( len =* ), parameter :: filename = 'big.json' !13 MB - 7.6 sec : http://mtgjson.com !character(len=*),parameter :: filename = 'AllSets.json' !....WARNING: this file is causing some error.... (bug in code?) !100 MB - takes forever... : https://github.com/seductiveapps/largeJSON !character(len=*),parameter :: filename = '100mb.json' !small file that contains unicode characters: !character(len=*),parameter :: filename = 'hello-world-ucs4.json'  !!!! test !!!! character ( len =* ), parameter :: dir = '../files/inputs/' !working directory contains subroutine test_9 ( error_cnt ) !! Open a random JSON file generated by http://www.json-generator.com implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: f real :: tstart , tend character ( len = :), allocatable :: str error_cnt = 0 write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9a ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_file' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call f % load_file ( dir // filename ) ! will automatically call initialize() with defaults call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time: ' , tend - tstart , ' sec' if ( f % failed ()) then call f % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !cleanup: call f % destroy () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9b ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_from_string' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call read_file ( dir // filename , str ) if ( allocated ( str )) then call f % load_from_string ( str ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time to parse: ' , tend - tstart , ' sec' if ( f % failed ()) then call f % print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !write(error_unit,'(A)') str   !!!! test !!!! !write(error_unit,'(A)') ''    !!!! test !!!! else write ( error_unit , '(A)' ) 'Error loading file' end if !cleanup: call f % destroy () end subroutine test_9 subroutine read_file ( filename , str ) !! Reads the contents of the file into the allocatable string str. !! If there are any problems, str will be returned unallocated. !! !!@warning Will this routine work if the file contains unicode characters?? implicit none character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable , intent ( out ) :: str integer :: iunit , istat , filesize open ( newunit = iunit ,& file = filename ,& status = 'OLD' ,& form = 'UNFORMATTED' ,& access = 'STREAM' ,& iostat = istat ) if ( istat == 0 ) then inquire ( file = filename , size = filesize ) if ( filesize > 0 ) then allocate ( character ( len = filesize ) :: str ) read ( iunit , pos = 1 , iostat = istat ) str if ( istat /= 0 ) deallocate ( str ) close ( iunit , iostat = istat ) end if end if end subroutine read_file end module jf_test_9_mod !***************************************************************************************** !***************************************************************************************** program jf_test_9 !! Ninth unit test. use jf_test_9_mod , only : test_9 implicit none integer :: n_errors n_errors = 0 call test_9 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_9 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_9.f90.html","title":"jf_test_9.f90 – Fortran Program"},{"text":"Source Code !******************************************************************************************************* !> author: Izaak Beekman ! ! This program is run when configuring the json-fortran build, ! to determine whether or not ISO 10646/UCS4 characters are ! supported by the compiler. program test_iso_10646_support use iso_fortran_env , only : output_unit , error_unit implicit none integer , parameter :: UCS4_K = selected_char_kind ( 'ISO_10646' ) if ( UCS4_K == - 1 ) then !Not supported! write ( error_unit , '(A)' ) 'Your compiler does not support ISO 10646/UCS4 characters!' write ( error_unit , '(A)' ) 'JSON-Fortran must/will be configured to use the \"DEFAULT\"' write ( error_unit , '(A)' ) 'character set. (Should be \"ASCII\" on a reasonable system.)' stop 2 else write ( error_unit , '(A)' ) 'Congratulations! Your compiler supports ISO 10646/UCS4!' write ( error_unit , '(A)' ) 'JSON-Fortran may be configured to enable UCS4 support.' write ( output_unit , '(A)' ) 'UCS4_SUPPORTED' end if end program test_iso_10646_support !*******************************************************************************************************","tags":"","loc":"sourcefile/test_iso_10646_support.f90.html","title":"test_iso_10646_support.f90 – Fortran Program"},{"text":"type, public :: json_file Constructor public interface json_file private function initialize_json_file(p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) private function initialize_json_file_v2(json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Type-Bound Procedures procedure, public :: initialize => initialize_json_core_in_file private subroutine initialize_json_core_in_file(me, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. procedure, public :: load_file => json_file_load private subroutine json_file_load(me, filename, unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use (if not present, a newunit is used) generic, public :: load_from_string => json_file_load_from_string private subroutine json_file_load_from_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from procedure, public :: destroy => json_file_destroy private subroutine json_file_destroy(me, destroy_core) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical, intent(in), optional :: destroy_core to also destroy the json_core .\n default is to leave it as is. procedure, public :: move => json_file_move_pointer private subroutine json_file_move_pointer(to, from) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from generic, public :: info => json_file_variable_info private subroutine json_file_variable_info(me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children procedure, public :: failed => json_file_failed private pure function json_file_failed(me) result(failed) Arguments Type Intent Optional Attributes Name class( json_file ), intent(in) :: me Return Value logical(kind=LK) will be true if there has been an error. procedure, public :: print_error_message => json_file_print_error_message private subroutine json_file_print_error_message(me, io_unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer, intent(in), optional :: io_unit procedure, public :: check_for_errors => json_file_check_for_errors private subroutine json_file_check_for_errors(me, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) procedure, public :: clear_exceptions => json_file_clear_exceptions private pure subroutine json_file_clear_exceptions(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure, public :: print_to_string => json_file_print_to_string private subroutine json_file_print_to_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to generic, public :: print_file => json_file_print_to_console , json_file_print_1 , json_file_print_2 private subroutine json_file_print_to_console(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me private subroutine json_file_print_1(me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) private subroutine json_file_print_2(me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to generic, public :: get => json_file_get_object , json_file_get_integer , json_file_get_double , json_file_get_logical , json_file_get_string , json_file_get_integer_vec , json_file_get_double_vec , json_file_get_logical_vec , json_file_get_string_vec , json_file_get_root private subroutine json_file_get_object(me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_integer(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_double(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_logical(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_string(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_integer_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found private subroutine json_file_get_double_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_logical_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_string_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_file_get_root(me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable generic, public :: update => json_file_update_integer , json_file_update_logical , json_file_update_real , json_file_update_string private subroutine json_file_update_integer(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_logical(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_real(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_file_update_string(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_load_from_string private subroutine json_file_load_from_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from procedure, public :: json_file_variable_info private subroutine json_file_variable_info(me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children procedure, public :: json_file_get_object private subroutine json_file_get_object(me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_integer private subroutine json_file_get_integer(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_double private subroutine json_file_get_double(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_logical private subroutine json_file_get_logical(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_string private subroutine json_file_get_string(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_integer_vec private subroutine json_file_get_integer_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found procedure, public :: json_file_get_double_vec private subroutine json_file_get_double_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_logical_vec private subroutine json_file_get_logical_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_string_vec private subroutine json_file_get_string_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found procedure, public :: json_file_get_root private subroutine json_file_get_root(me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable procedure, public :: json_file_update_integer private subroutine json_file_update_integer(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_update_logical private subroutine json_file_update_logical(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_update_real private subroutine json_file_update_real(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_update_string private subroutine json_file_update_string(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found procedure, public :: json_file_print_to_console private subroutine json_file_print_to_console(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me procedure, public :: json_file_print_1 private subroutine json_file_print_1(me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) procedure, public :: json_file_print_2 private subroutine json_file_print_2(me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to","tags":"","loc":"type/json_file.html","title":"json_file – Fortran Program "},{"text":"type, public :: json_value sequence","tags":"","loc":"type/json_value.html","title":"json_value – Fortran Program "},{"text":"type, public :: json_core Constructor public interface json_core private function initialize_json_core(verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Type-Bound Procedures generic, public :: get_child => json_value_get_by_index, json_value_get_child, json_value_get_by_name_chars private subroutine json_value_get_by_index(json, p, idx, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), , pointer :: child pointer to the child private subroutine json_value_get_child(json, p, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p object or array JSON data type( json_value ), , pointer :: child pointer to the child private subroutine json_value_get_by_name_chars(json, p, name, child) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name the name of a child of p type( json_value ), , pointer :: child pointer to the child generic, public :: add => json_value_add_member, json_value_add_integer, json_value_add_integer_vec, json_value_add_double, json_value_add_double_vec, json_value_add_logical, json_value_add_logical_vec, json_value_add_string, json_value_add_string_vec private subroutine json_value_add_member(json, p, member) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p type( json_value ), , pointer :: member the child member to add private subroutine json_value_add_integer(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val private subroutine json_value_add_integer_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value private subroutine json_value_add_double(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value private subroutine json_value_add_double_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val private subroutine json_value_add_logical(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value private subroutine json_value_add_logical_vec(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value private subroutine json_value_add_string(json, p, name, val) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value private subroutine json_value_add_string_vec(json, p, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element generic, public :: update => json_update_logical, json_update_double, json_update_integer, json_update_string private subroutine json_update_logical(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_double(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_integer(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found private subroutine json_update_string(json, p, name, val, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found generic, public :: get => json_get_by_path, json_get_integer, json_get_integer_with_path, json_get_integer_vec, json_get_integer_vec_with_path, json_get_double, json_get_double_with_path, json_get_double_vec, json_get_double_vec_with_path, json_get_logical, json_get_logical_with_path, json_get_logical_vec, json_get_logical_vec_with_path, json_get_string, json_get_string_with_path, json_get_string_vec, json_get_string_vec_with_path, json_get_array, json_get_array_with_path private subroutine json_get_by_path(json, me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me a JSON linked list character(kind=CK,len=*), intent(in) :: path path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable specify by path logical(kind=LK), intent(out), optional :: found true if it was found private subroutine json_get_integer(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value private subroutine json_get_integer_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_integer_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_integer_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_double(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out) :: value private subroutine json_get_double_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_double_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_double_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_logical(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK) :: value private subroutine json_get_logical_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK) :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_logical_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec private subroutine json_get_logical_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_string(json, me, value) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value private subroutine json_get_string_with_path(json, me, path, value, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found private subroutine json_get_string_vec(json, me, vec) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec private subroutine json_get_string_vec_with_path(json, me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found private subroutine json_get_array(json, me, array_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me procedure(array_callback_func) :: array_callback private subroutine json_get_array_with_path(json, me, path, array_callback, found) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure(array_callback_func) :: array_callback logical(kind=LK), intent(out), optional :: found procedure, public :: print_to_string => json_value_to_string Print the json_value structure to an allocatable string private subroutine json_value_to_string(json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string generic, public :: print => json_print_1, json_print_2 private subroutine json_print_1(json, p, iunit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). private subroutine json_print_2(json, p, filename) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) generic, public :: destroy => json_value_destroy, destroy_json_core private recursive subroutine json_value_destroy(json, p, destroy_next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p variable to destroy logical(kind=LK), intent(in), optional :: destroy_next if true, then p%next is also destroyed (default is true) private subroutine destroy_json_core(me) Arguments Type Intent Optional Attributes Name class( json_core ), intent(out) :: me generic, public :: remove_if_present => json_value_remove_if_present private subroutine json_value_remove_if_present(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_double => json_value_create_double private subroutine json_value_create_double(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name generic, public :: create_array => json_value_create_array private subroutine json_value_create_array(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_object => json_value_create_object private subroutine json_value_create_object(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_null => json_value_create_null private subroutine json_value_create_null(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: name generic, public :: create_string => json_value_create_string private subroutine json_value_create_string(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name generic, public :: create_integer => json_value_create_integer private subroutine json_value_create_integer(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name generic, public :: create_logical => json_value_create_logical private subroutine json_value_create_logical(json, p, val, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name generic, public :: parse => json_parse_file, json_parse_string private subroutine json_parse_file(json, file, p, unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), , pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) private subroutine json_parse_string(json, p, str) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data generic, public :: throw_exception => json_throw_exception private subroutine json_throw_exception(json, msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json character(kind=CK,len=*), intent(in) :: msg the error message generic, public :: rename => json_value_rename private subroutine json_value_rename(json, p, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p character(kind=CK,len=*), intent(in) :: name new variable name procedure, public :: remove => json_value_remove Remove a json_value from a linked-list structure. private subroutine json_value_remove(json, p, destroy) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. procedure, public :: check_for_errors => json_check_for_errors check for error and get error message private subroutine json_check_for_errors(json, status_ok, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) procedure, public :: clear_exceptions => json_clear_exceptions clear exceptions private pure subroutine json_clear_exceptions(json) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json procedure, public :: count => json_count count the number of children private function json_count(json, p) result(count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p Return Value integer(kind=IK) <\np n\nu\nm\nb\ne\nr o\nf c\nh\ni\nl\nd\nr\ne\nn\n<\n/\np procedure, public :: clone => json_clone clone a JSON structure (deep copy) private subroutine json_clone(json, from, to) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: from this is the structure to clone type( json_value ), , pointer :: to the clone is put here\n (it must not already be associated) procedure, public :: failed => json_failed check for error private pure function json_failed(json) result(failed) Arguments Type Intent Optional Attributes Name class( json_core ), intent(in) :: json Return Value logical(kind=LK) will be true if an exception\n has been thrown. procedure, public :: get_parent => json_get_parent get pointer to json_value parent private subroutine json_get_parent(json, p, parent) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: parent pointer to parent procedure, public :: get_next => json_get_next get pointer to json_value next private subroutine json_get_next(json, p, next) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: next pointer to next procedure, public :: get_previous => json_get_previous get pointer to json_value previous private subroutine json_get_previous(json, p, previous) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: previous pointer to previous procedure, public :: get_tail => json_get_tail get pointer to json_value tail private subroutine json_get_tail(json, p, tail) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p JSON object type( json_value ), intent(out), pointer :: tail pointer to tail procedure, public :: info => json_info get info about a json_value private subroutine json_info(json, p, var_type, n_children, name) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name procedure, public :: initialize => json_initialize to initialize some parsing parameters private subroutine json_initialize(json, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. procedure, public :: traverse => json_traverse to traverse all elements of a JSON structure private subroutine json_traverse(json, p, traverse_callback) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p procedure(traverse_callback_func) :: traverse_callback procedure, public :: print_error_message => json_print_error_message simply routine to print error messages private subroutine json_print_error_message(json, io_unit) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json integer, intent(in), optional :: io_unit procedure, public :: swap => json_value_swap Swap two json_value pointers\n in a structure (or two different structures). private subroutine json_value_swap(json, p1, p2) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 procedure, public :: is_child_of => json_value_is_child_of Check if a json_value is a child of another. private function json_value_is_child_of(json, p1, p2) result(is_child_of) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), , pointer :: p1 type( json_value ), , pointer :: p2 Return Value logical(kind=LK) procedure, public :: validate => json_value_validate Check that a json_value linked list is valid\n (i.e., is properly constructed). This may be\n useful if it has been constructed externally. private subroutine json_value_validate(json, p, is_valid, error_msg) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: is_valid True if the structure is valid. character(kind=CK,len=:), , allocatable :: error_msg if not valid, this will contain\n a description of the problem","tags":"","loc":"type/json_core.html","title":"json_core – Fortran Program "},{"text":"public interface json_file Module Procedures private function initialize_json_file(p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) private function initialize_json_file_v2(json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file )","tags":"","loc":"interface/json_file.html","title":"json_file – Fortran Program"},{"text":"public pure function valid_json_hex(str) result(valid) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: n length of str integer(kind=IK), public :: i counter character(kind=CK,len=1), public, parameter, dimension(22) :: valid_chars = [(achar(i), i=48, 57), (achar(i), i=65, 70), (achar(i), i=97, 102)] an array of the valid hex characters","tags":"","loc":"proc/valid_json_hex.html","title":"valid_json_hex – Fortran Program"},{"text":"public pure elemental function lowercase_string(str) result(s_lower) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str input string Return Value character(kind=CK,len=(len(str))) lowercase version of the string Variables Type Visibility Attributes Name Initial integer, public :: i counter integer, public :: n length of input string","tags":"","loc":"proc/lowercase_string.html","title":"lowercase_string – Fortran Program"},{"text":"public pure subroutine integer_to_string(ival, int_fmt, str) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CDK,len=*), intent(in) :: int_fmt format for integers character(kind=CK,len=*), intent(out) :: str ival converted to a string. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istat","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string – Fortran Program"},{"text":"public subroutine real_to_string(rval, real_fmt, compact_real, str) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CDK,len=*), intent(in) :: real_fmt format for real numbers logical(kind=LK), intent(in) :: compact_real compact the string so that it is\n displayed with fewer characters character(kind=CK,len=*), intent(out) :: str rval converted to a string. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istat","tags":"","loc":"proc/real_to_string.html","title":"real_to_string – Fortran Program"},{"text":"public subroutine escape_string(str_in, str_out) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i counter integer(kind=IK), public :: ipos accumulated string size\n (so we can allocate it in chunks for\n greater runtime efficiency) character(kind=CK,len=1), public :: c for reading str_in one character at a time. character(kind=CK,len=:), public, allocatable :: tmp workaround for bug in gfortran 6.1 character(kind=CK,len=*), public, parameter :: specials = quotation_mark//backslash//slash//bspace//formfeed//newline//carriage_return//horizontal_tab","tags":"","loc":"proc/escape_string.html","title":"escape_string – Fortran Program"},{"text":"public subroutine unescape_string(str_in, str_out, error_message) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in string as stored in a json_value character(kind=CK,len=:), intent(out), allocatable :: str_out decoded string character(kind=CK,len=:), intent(out), allocatable :: error_message will be allocated if there was an error Variables Type Visibility Attributes Name Initial integer, public :: i counter integer, public :: n length of str_in integer, public :: m length of str_out character(kind=CK,len=1), public :: c for scanning each character in string","tags":"","loc":"proc/unescape_string.html","title":"unescape_string – Fortran Program"},{"text":"public interface to_unicode Module Procedures private pure function to_uni(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) private pure function to_uni_vec(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str))","tags":"","loc":"interface/to_unicode.html","title":"to_unicode – Fortran Program"},{"text":"public interface json_core Module Procedures private function initialize_json_core(verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core )","tags":"","loc":"interface/json_core.html","title":"json_core – Fortran Program"},{"text":"public subroutine test_1(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read a sample JSON file and retrieve some data from it Variables Type Visibility Attributes Name Initial type( json_file ), public :: json the JSON structure read from the file type( json_value ), public, pointer :: p a pointer for low-level manipulations type( json_core ), public :: core factory for manipulating json_value pointers integer, public :: ival character(kind=json_CK,len=:), public, allocatable :: cval real(kind=wp), public :: rval logical, public :: found","tags":"","loc":"proc/test_1.html","title":"test_1 – Fortran Program"},{"text":"public subroutine test_10(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Test some of the lesser-used features of the library Variables Type Visibility Attributes Name Initial character(kind=json_CK,len=256), public, dimension(:), allocatable :: str_vec type( json_file ), public :: f type( json_file ), public :: f2 type( json_value ), public, pointer :: p type( json_core ), public :: json factory for manipulating json_value pointers character(kind=json_CK,len=:), public, allocatable :: str character(kind=json_CK,len=:), public, allocatable :: name logical, public :: found logical, public :: lval integer, public :: var_type integer, public :: n_children character(kind=json_CDK,len=*), public, parameter :: json_str = '{ \"blah\": 123 }'","tags":"","loc":"proc/test_10.html","title":"test_10 – Fortran Program"},{"text":"public subroutine test_11(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file and extract some data from it. Variables Type Visibility Attributes Name Initial character(kind=json_CK,len=:), public, allocatable :: cval type( json_file ), public :: json","tags":"","loc":"proc/test_11.html","title":"test_11 – Fortran Program"},{"text":"public subroutine test_12(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Variables Type Visibility Attributes Name Initial integer, public, parameter :: imx = 5 integer, public, parameter :: jmx = 3 integer, public, parameter :: kmx = 4 dimensions for raw work array of primitive type type( json_core ), public :: json factory for manipulating json_value pointers integer, public, dimension(3) :: shape shape of work array integer, public, dimension(:), allocatable :: fetched_shape retrieved shape type( json_value ), public, pointer :: root type( json_value ), public, pointer :: meta_array json nodes to work with type( json_value ), public, pointer :: tmp_json_ptr type( json_file ), public :: my_file real(kind=wp), public, dimension(imx,jmx,kmx) :: raw_array raw work array real(kind=wp), public :: array_element real(kind=wp), public, dimension(:), allocatable :: fetched_array character(kind=CK,len=:), public, allocatable :: description integer, public :: i integer, public :: j integer, public :: k loop indices integer, public :: array_length integer, public :: lun logical, public :: existed logical, public, dimension(:), allocatable :: SOS Subroutines subroutine check_errors(assertion) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: assertion Description check for errors in json subroutine check_file_errors(assertion) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: assertion Description check for errors in my_file subroutine get_3D_from_array(json, element, i, count) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: element integer, intent(in) :: i index integer, intent(in) :: count size of array Description array callback function","tags":"","loc":"proc/test_12.html","title":"test_12 – Fortran Program"},{"text":"public subroutine test_13(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests different real format strings using repeated calls to [[json_initialize]]. Variables Type Visibility Attributes Name Initial type( json_file ), public :: my_file character(kind=json_CK,len=:), public, allocatable :: str integer, public :: i character(len=2), public, parameter, dimension(5) :: fmts = ['g ', 'e ', 'en', 'es', '* '] format statements to test","tags":"","loc":"proc/test_13.html","title":"test_13 – Fortran Program"},{"text":"public subroutine test_14(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests the traversal of a JSON structure It traverses the structure, looks for all \"name\" variables, and changes the name. Variables Type Visibility Attributes Name Initial type( json_core ), public :: json type( json_value ), public, pointer :: p","tags":"","loc":"proc/test_14.html","title":"test_14 – Fortran Program"},{"text":"public subroutine rename(json, p, finished) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical, intent(out) :: finished Description change all \"name\" variable values to \"Fred\" Variables Type Visibility Attributes Name Initial integer, public :: var_type character(kind=json_CK,len=:), public, allocatable :: str logical, public :: found","tags":"","loc":"proc/rename.html","title":"rename – Fortran Program"},{"text":"public subroutine test_15(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test some of the edge cases, and incorrect usages. Variables Type Visibility Attributes Name Initial type( json_core ), public :: json type( json_value ), public, pointer :: p type( json_value ), public, pointer :: p2 type( json_file ), public :: file1 type( json_file ), public :: file2 logical, public :: found logical, public :: status_ok integer, public :: var_type integer, public :: i integer, public :: n_children real(kind=wp), public :: d logical, public :: tf character(kind=CK,len=:), public, allocatable :: error_msg","tags":"","loc":"proc/test_15.html","title":"test_15 – Fortran Program"},{"text":"public subroutine test_16(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test the swap function. Variables Type Visibility Attributes Name Initial type( json_core ), public :: json type( json_value ), public, pointer :: p type( json_value ), public, pointer :: p1 type( json_value ), public, pointer :: p2","tags":"","loc":"proc/test_16.html","title":"test_16 – Fortran Program"},{"text":"public subroutine test_17(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test the rename function. Variables Type Visibility Attributes Name Initial type( json_core ), public :: json type( json_value ), public, pointer :: p type( json_value ), public, pointer :: q","tags":"","loc":"proc/test_17.html","title":"test_17 – Fortran Program"},{"text":"public subroutine test_18(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test the name matching options. Variables Type Visibility Attributes Name Initial type( json_core ), public :: json type( json_value ), public, pointer :: p integer, public :: ival logical, public :: found logical, public, dimension(4) :: ok Subroutines subroutine go(iresult) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(4) :: iresult correct answers Description run test and get results","tags":"","loc":"proc/test_18.html","title":"test_18 – Fortran Program"},{"text":"public subroutine test_2(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure and write it to a file. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p type( json_value ), public, pointer :: inp type( json_value ), public, pointer :: traj type( json_value ), public, pointer :: tmp1 type( json_value ), public, pointer :: tmp2 type( json_value ), public, pointer :: p_tmp type( json_value ), public, pointer :: p_integer_array type( json_value ), public, pointer :: p_clone type( json_core ), public :: json factory for manipulating json_value pointers integer, public :: iunit character(kind=json_CK,len=:), public, allocatable :: name integer, public :: ival integer, public :: ival_clone logical, public :: found logical, public :: is_valid character(kind=json_CK,len=:), public, allocatable :: error_msg","tags":"","loc":"proc/test_2.html","title":"test_2 – Fortran Program"},{"text":"public subroutine add_variables_to_input(json, me, variable, units, frame, center, rdata, error_cnt) Arguments Type Intent Optional Attributes Name type( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(len=*), intent(in) :: variable character(len=*), intent(in) :: units character(len=*), intent(in) :: frame character(len=*), intent(in) :: center real(kind=wp), intent(in), dimension(:) :: rdata integer, intent(inout) :: error_cnt Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var","tags":"","loc":"proc/add_variables_to_input.html","title":"add_variables_to_input – Fortran Program"},{"text":"public subroutine test_3(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file generated in test_2 , and extract some data from it. Variables Type Visibility Attributes Name Initial integer, public :: ival character(kind=json_CK,len=:), public, allocatable :: cval real(kind=wp), public :: rval type( json_file ), public :: json integer, public :: i character(kind=json_CK,len=10), public :: str real(kind=wp), public, dimension(:), allocatable :: rvec","tags":"","loc":"proc/test_3.html","title":"test_3 – Fortran Program"},{"text":"public subroutine test_4(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure, write it to a file,\n then read it. Also tests the json_value_to_string routine to write\n the file to a character string. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p type( json_value ), public, pointer :: inp type( json_file ), public :: json type( json_core ), public :: core factory for manipulating json_value pointers integer, public :: i character(kind=json_CK,len=10), public :: istr character(kind=json_CK,len=:), public, allocatable :: string","tags":"","loc":"proc/test_4.html","title":"test_4 – Fortran Program"},{"text":"public subroutine test_5(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Github issue example: https://github.com/josephalevin/fson/issues/12 Read an existing file and extract some variables. Variables Type Visibility Attributes Name Initial integer, public :: vv integer, public, dimension(:), allocatable :: vvv real(kind=wp), public :: d type( json_file ), public :: json logical, public :: found","tags":"","loc":"proc/test_5.html","title":"test_5 – Fortran Program"},{"text":"public subroutine test_6(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description This example tries to read an invalid JSON file. Variables Type Visibility Attributes Name Initial type( json_file ), public :: json integer, public :: i character(len=*), public, parameter, dimension(2) :: files = ['invalid.json ', 'invalid2.json']","tags":"","loc":"proc/test_6.html","title":"test_6 – Fortran Program"},{"text":"public subroutine test_7(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Indent test Variables Type Visibility Attributes Name Initial type( json_core ), public :: json factory for manipulating json_value pointers type( json_value ), public, pointer :: root type( json_value ), public, pointer :: a type( json_value ), public, pointer :: b type( json_value ), public, pointer :: c type( json_value ), public, pointer :: d type( json_value ), public, pointer :: e type( json_value ), public, pointer :: e1 type( json_value ), public, pointer :: e2 type( json_value ), public, pointer :: escaped_string type( json_value ), public, pointer :: p logical, public :: found character(kind=json_CK,len=1), public, dimension(:), allocatable :: strvec character(kind=json_CK,len=:), public, allocatable :: string","tags":"","loc":"proc/test_7.html","title":"test_7 – Fortran Program"},{"text":"public subroutine test_8(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description read a JSON structure from a string Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p type( json_core ), public :: json factory for manipulating json_value pointers character(len=*), public, parameter :: newline = achar(10) character(len=*), public, parameter :: str = '{ \"label\": \"foo\",'//newline//' \"value\": \"bar\" }' character(len=*), public, parameter :: str2 = '{ \"label\": \"foo\",'//newline//'  \"value\": \"bar\",'//newline//'  \"empty_array\": [],'//newline//'  \"empty_object\": {}'//newline//'}' character(len=*), public, parameter :: str_invalid = '{ \"label\": \"foo\",'//newline//' \"value : \"bar\" }'","tags":"","loc":"proc/test_8.html","title":"test_8 – Fortran Program"},{"text":"public subroutine test_9(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Open a random JSON file generated by http://www.json-generator.com Variables Type Visibility Attributes Name Initial type( json_file ), public :: f real, public :: tstart real, public :: tend character(len=:), public, allocatable :: str","tags":"","loc":"proc/test_9.html","title":"test_9 – Fortran Program"},{"text":"public subroutine read_file(filename, str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: str Description Reads the contents of the file into the allocatable string str.\n If there are any problems, str will be returned unallocated. Warning Will this routine work if the file contains unicode characters?? Variables Type Visibility Attributes Name Initial integer, public :: iunit integer, public :: istat integer, public :: filesize","tags":"","loc":"proc/read_file.html","title":"read_file – Fortran Program"},{"text":"Uses: iso_fortran_env json_kinds json_parameters json_string_utilities json_value_module File encoding preprocessor macro. This C preprocessor macro will take a procedure name as an\n input, and output either that same procedure name if the\n code is compiled without USE_UCS4 being defined or it will\n expand the procedure name to the original procedure name,\n followed by a comma and then the original procedure name\n with 'wrap_' prepended to it. This is suitable for creating\n overloaded interfaces that will accept UCS4 character actual\n arguments as well as DEFAULT/ASCII character arguments,\n based on whether or not ISO 10646 is supported and requested. Interfaces public interface json_file private function initialize_json_file(p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_file ) private function initialize_json_file_v2(json_value_object, json_core_object) result(file_object) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: json_value_object type( json_core ), intent(in) :: json_core_object Return Value type( json_file ) Derived Types type, public :: json_file Constructor private  function initialize_json_file (p, verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) private  function initialize_json_file_v2 (json_value_object, json_core_object) Type-Bound Procedures procedure, public :: initialize => initialize_json_core_in_file procedure, public :: load_file => json_file_load generic, public :: load_from_string => json_file_load_from_string procedure, public :: destroy => json_file_destroy procedure, public :: move => json_file_move_pointer generic, public :: info => json_file_variable_info procedure, public :: failed => json_file_failed procedure, public :: print_error_message => json_file_print_error_message procedure, public :: check_for_errors => json_file_check_for_errors procedure, public :: clear_exceptions => json_file_clear_exceptions procedure, public :: print_to_string => json_file_print_to_string generic, public :: print_file => json_file_print_to_console, json_file_print_1, json_file_print_2 generic, public :: get => json_file_get_object, json_file_get_integer, json_file_get_double, json_file_get_logical, json_file_get_string, json_file_get_integer_vec, json_file_get_double_vec, json_file_get_logical_vec, json_file_get_string_vec, json_file_get_root generic, public :: update => json_file_update_integer, json_file_update_logical, json_file_update_real, json_file_update_string procedure, public :: json_file_load_from_string procedure, public :: json_file_variable_info procedure, public :: json_file_get_object procedure, public :: json_file_get_integer procedure, public :: json_file_get_double procedure, public :: json_file_get_logical procedure, public :: json_file_get_string procedure, public :: json_file_get_integer_vec procedure, public :: json_file_get_double_vec procedure, public :: json_file_get_logical_vec procedure, public :: json_file_get_string_vec procedure, public :: json_file_get_root procedure, public :: json_file_update_integer procedure, public :: json_file_update_logical procedure, public :: json_file_update_real procedure, public :: json_file_update_string procedure, public :: json_file_print_to_console procedure, public :: json_file_print_1 procedure, public :: json_file_print_2","tags":"","loc":"module/json_file_module.html","title":"json_file_module – Fortran Program"},{"text":"Uses: iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: RK = real64 Default real kind [8 bytes] integer, public, parameter :: IK = int32 Default integer kind [4 bytes]. integer, public, parameter :: CDK = selected_char_kind('DEFAULT') integer, public, parameter :: LK = logical_kinds(min(3, size(logical_kinds))) integer, public, parameter :: CK = selected_char_kind(json_fortran_string_kind)","tags":"","loc":"module/json_kinds.html","title":"json_kinds – Fortran Program"},{"text":"Uses: json_kinds json_value_module json_file_module","tags":"","loc":"module/json_module.html","title":"json_module – Fortran Program"},{"text":"Uses: json_kinds Variables Type Visibility Attributes Name Initial character(kind=CDK,len=*), public, parameter :: json_ext = '.json' JSON file extension character(kind=CK,len=*), public, parameter :: space = ' ' character(kind=CK,len=*), public, parameter :: start_object = '{' character(kind=CK,len=*), public, parameter :: end_object = '}' character(kind=CK,len=*), public, parameter :: start_array = '[' character(kind=CK,len=*), public, parameter :: end_array = ']' character(kind=CK,len=*), public, parameter :: delimiter = ',' character(kind=CK,len=*), public, parameter :: colon_char = ':' character(kind=CK,len=*), public, parameter :: start_array_alt = '(' for [[json_get_by_path]] character(kind=CK,len=*), public, parameter :: end_array_alt = ')' for [[json_get_by_path]] character(kind=CK,len=*), public, parameter :: root = '$' for [[json_get_by_path]] character(kind=CK,len=*), public, parameter :: this = '@' for [[json_get_by_path]] character(kind=CK,len=*), public, parameter :: child = '.' for [[json_get_by_path]] character(kind=CK,len=*), public, parameter :: bspace = achar(8) character(kind=CK,len=*), public, parameter :: horizontal_tab = achar(9) character(kind=CK,len=*), public, parameter :: newline = achar(10) character(kind=CK,len=*), public, parameter :: formfeed = achar(12) character(kind=CK,len=*), public, parameter :: carriage_return = achar(13) character(kind=CK,len=*), public, parameter :: quotation_mark = achar(34) character(kind=CK,len=*), public, parameter :: slash = achar(47) character(kind=CK,len=*), public, parameter :: backslash = achar(92) character(kind=CDK,len=*), public, parameter :: default_real_fmt = '(ss,E26.16E4)' default real number format statement (for writing real values to strings and files).\n Note that this can be overridden by calling [[json_initialize]]. character(kind=CK,len=*), public, parameter :: star = '*' for invalid numbers and\n list-directed real output character(kind=CK,len=26), protected :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' uppercase characters character(kind=CK,len=26), protected :: lower = 'abcdefghijklmnopqrstuvwxyz' lowercase characters character(kind=CK,len=4), protected :: null_str = 'null' JSON Null variable string character(kind=CK,len=4), protected :: true_str = 'true' JSON logical True string character(kind=CK,len=5), protected :: false_str = 'false' JSON logical False string character(kind=CK,len=*), public, parameter, dimension(32) :: control_chars = [(achar(i_), i_=1, 31), achar(127)] Control characters, possibly in unicode integer(kind=IK), public, parameter :: rp_safety_factor = 1_IK integer(kind=IK), public, parameter :: rp_addl_safety = 1_IK integer(kind=IK), public, parameter :: real_precision = rp_safety_factor*precision(1.0_RK)+rp_addl_safety integer(kind=IK), public, parameter :: maxexp = maxexponent(1.0_RK) integer(kind=IK), public, parameter :: minexp = minexponent(1.0_RK) integer(kind=IK), public, parameter :: real_exponent_digits = floor(1+log10(real(max(maxexp, abs(maxexp)), kind=RK))) integer(kind=IK), public, parameter :: max_numeric_str_len = real_precision+real_exponent_digits+6 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character(kind=CDK,len=*), public, parameter :: int_fmt = '(ss,I0)' minimum width format for integers integer(kind=IK), public, parameter :: chunk_size = 100_IK for allocatable strings: allocate chunks of this size integer(kind=IK), public, parameter :: unit2str = -1_IK unit number to cause stuff to be\n output to strings rather than files.\n See 9.5.6.12 in the F2003/08 standard integer(kind=IK), public, parameter :: seq_chunk_size = 256_IK chunk size for reading sequential files integer(kind=IK), public, parameter :: pushed_char_size = 10_IK magic number","tags":"","loc":"module/json_parameters.html","title":"json_parameters – Fortran Program"},{"text":"Uses: json_kinds json_parameters Interfaces public interface to_unicode private pure function to_uni(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) private pure function to_uni_vec(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Functions public pure function valid_json_hex (str) result(valid) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Description Author Jacob Williams public pure elemental function lowercase_string (str) result(s_lower) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str input string Return Value character(kind=CK,len=(len(str))) <\np l\no\nw\ne\nr\nc\na\ns\ne v\ne\nr\ns\ni\no\nn o\nf t\nh\ne s\nt\nr\ni\nn\ng\n<\n/\np Description Author Jacob Williams Subroutines public pure subroutine integer_to_string (ival, int_fmt, str) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CDK,len=*), intent(in) :: int_fmt format for integers character(kind=CK,len=*), intent(out) :: str ival converted to a string. Description Author Jacob Williams public subroutine real_to_string (rval, real_fmt, compact_real, str) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CDK,len=*), intent(in) :: real_fmt format for real numbers logical(kind=LK), intent(in) :: compact_real compact the string so that it is\n displayed with fewer characters character(kind=CK,len=*), intent(out) :: str rval converted to a string. Description Author Jacob Williams public subroutine escape_string (str_in, str_out) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out Description Author Jacob Williams public subroutine unescape_string (str_in, str_out, error_message) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in string as stored in a json_value character(kind=CK,len=:), intent(out), allocatable :: str_out decoded string character(kind=CK,len=:), intent(out), allocatable :: error_message will be allocated if there was an error","tags":"","loc":"module/json_string_utilities.html","title":"json_string_utilities – Fortran Program"},{"text":"Uses: iso_fortran_env json_kinds json_parameters json_string_utilities File encoding preprocessor macro. This C preprocessor macro will take a procedure name as an\n input, and output either that same procedure name if the\n code is compiled without USE_UCS4 being defined or it will\n expand the procedure name to the original procedure name,\n followed by a comma and then the original procedure name\n with 'wrap_' prepended to it. This is suitable for creating\n overloaded interfaces that will accept UCS4 character actual\n arguments as well as DEFAULT/ASCII character arguments,\n based on whether or not ISO 10646 is supported and requested. Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: json_unknown = 0 Unknown JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_null = 1 Null JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_object = 2 Object JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_array = 3 Array JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_logical = 4 Logical JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_integer = 5 Integer JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_double = 6 Double JSON data type\n (see [[json_file_variable_info]] and [[json_info]]) integer(kind=IK), public, parameter :: json_string = 7 String JSON data type Interfaces public interface json_core private function initialize_json_core(verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) result(json_core_object) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=CDK,len=*), intent(in), optional :: real_format Real number format: 'E' [default], '*', 'G', 'EN', or 'ES' integer(kind=IK), intent(in), optional :: spaces_per_tab number of spaces per tab for indenting (default is 2) logical(kind=LK), intent(in), optional :: strict_type_checking if true, no integer, double, or logical type\n conversions are done for the get routines\n (default is false) logical(kind=LK), intent(in), optional :: trailing_spaces_significant for name and path comparisons, is trailing\n space to be considered significant. logical(kind=LK), intent(in), optional :: case_sensitive_keys for name and path comparisons, are they\n case sensitive. Return Value type( json_core ) Derived Types type, public, sequence  :: json_value type, public :: json_core Constructor <\np t\nh\ne p\no\np\np\ne\nd c\nh\na\nr\na\nc\nt\ne\nr\n.\n<\n/\np private  function initialize_json_core (verbose, compact_reals, print_signs, real_format, spaces_per_tab, strict_type_checking, trailing_spaces_significant, case_sensitive_keys) Type-Bound Procedures generic, public :: get_child => json_value_get_by_index, json_value_get_child, json_value_get_by_name_chars generic, public :: add => json_value_add_member, json_value_add_integer, json_value_add_integer_vec, json_value_add_double, json_value_add_double_vec, json_value_add_logical, json_value_add_logical_vec, json_value_add_string, json_value_add_string_vec <\np f\no\nr n\na\nm\ne a\nn\nd p\na\nt\nh c\no\nm\np\na\nr\ni\ns\no\nn\ns\n, a\nr\ne t\nh\ne\ny c\na\ns\ne s\ne\nn\ns\ni\nt\ni\nv\ne\n.\n<\n/\np generic, public :: update => json_update_logical, json_update_double, json_update_integer, json_update_string generic, public :: get => json_get_by_path, json_get_integer, json_get_integer_with_path, json_get_integer_vec, json_get_integer_vec_with_path, json_get_double, json_get_double_with_path, json_get_double_vec, json_get_double_vec_with_path, json_get_logical, json_get_logical_with_path, json_get_logical_vec, json_get_logical_vec_with_path, json_get_string, json_get_string_with_path, json_get_string_vec, json_get_string_vec_with_path, json_get_array, json_get_array_with_path procedure, public :: print_to_string => json_value_to_string <\np P\nr\ni\nn\nt t\nh\ne [\n[\nj\ns\no\nn\n_\nv\na\nl\nu\ne\n]\n] s\nt\nr\nu\nc\nt\nu\nr\ne t\no a\nn a\nl\nl\no\nc\na\nt\na\nb\nl\ne s\nt\nr\ni\nn\ng\n<\n/\np generic, public :: print => json_print_1, json_print_2 <\np P\nr\ni\nn\nt t\nh\ne [\n[\nj\ns\no\nn\n_\nv\na\nl\nu\ne\n]\n] s\nt\nr\nu\nc\nt\nu\nr\ne t\no a\nn a\nl\nl\no\nc\na\nt\na\nb\nl\ne s\nt\nr\ni\nn\ng\n<\n/\np generic, public :: destroy => json_value_destroy, destroy_json_core generic, public :: remove_if_present => json_value_remove_if_present generic, public :: create_double => json_value_create_double generic, public :: create_array => json_value_create_array generic, public :: create_object => json_value_create_object generic, public :: create_null => json_value_create_null generic, public :: create_string => json_value_create_string generic, public :: create_integer => json_value_create_integer generic, public :: create_logical => json_value_create_logical generic, public :: parse => json_parse_file, json_parse_string generic, public :: throw_exception => json_throw_exception generic, public :: rename => json_value_rename procedure, public :: remove => json_value_remove Remove a json_value from a linked-list structure. procedure, public :: check_for_errors => json_check_for_errors check for error and get error message procedure, public :: clear_exceptions => json_clear_exceptions clear exceptions procedure, public :: count => json_count count the number of children procedure, public :: clone => json_clone clone a JSON structure (deep copy) procedure, public :: failed => json_failed check for error procedure, public :: get_parent => json_get_parent get pointer to json_value parent procedure, public :: get_next => json_get_next get pointer to json_value next procedure, public :: get_previous => json_get_previous get pointer to json_value previous procedure, public :: get_tail => json_get_tail get pointer to json_value tail procedure, public :: info => json_info get info about a json_value procedure, public :: initialize => json_initialize to initialize some parsing parameters procedure, public :: traverse => json_traverse to traverse all elements of a JSON structure procedure, public :: print_error_message => json_print_error_message simply routine to print error messages procedure, public :: swap => json_value_swap Swap two json_value pointers\n in a structure (or two different structures). procedure, public :: is_child_of => json_value_is_child_of Check if a json_value is a child of another. procedure, public :: validate => json_value_validate Check that a json_value linked list is valid\n (i.e., is properly constructed). This may be\n useful if it has been constructed externally.","tags":"","loc":"module/json_value_module.html","title":"json_value_module – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename1 = 'test1.json' Subroutines public subroutine test_1 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read a sample JSON file and retrieve some data from it","tags":"","loc":"module/jf_test_1_mod.html","title":"jf_test_1_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: filename = 'test1.json' character(len=*), public, parameter :: dir = '../files/inputs/' Subroutines public subroutine test_10 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Test some of the lesser-used features of the library","tags":"","loc":"module/jf_test_10_mod.html","title":"jf_test_10_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: ascii_equivalent = 'hello-world-ascii.json' Subroutines public subroutine test_11 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file and extract some data from it.","tags":"","loc":"module/jf_test_11_mod.html","title":"jf_test_11_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' Path to write JSON file to character(len=*), public, parameter :: file = 'test12.json' Filename to write real(kind=wp), public, parameter :: TOL = 100*epsilon(1.0_wp) Tolerance for real comparisons Subroutines public subroutine test_12 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller","tags":"","loc":"module/jf_test_12_mod.html","title":"jf_test_12_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_13 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests different real format strings using repeated calls to [[json_initialize]].","tags":"","loc":"module/jf_test_13_mod.html","title":"jf_test_13_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename1 = 'test1.json' the file to read integer, public :: icount = 0 a count of the number of \"name\" variables found Subroutines public subroutine test_14 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests the traversal of a JSON structure public subroutine rename (json, p, finished) Arguments Type Intent Optional Attributes Name class( json_core ), intent(inout) :: json type( json_value ), intent(in), pointer :: p logical, intent(out) :: finished Description change all \"name\" variable values to \"Fred\"","tags":"","loc":"module/jf_test_14_mod.html","title":"jf_test_14_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_15 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test some of the edge cases, and incorrect usages.","tags":"","loc":"module/jf_test_15_mod.html","title":"jf_test_15_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_16 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test the swap function.","tags":"","loc":"module/jf_test_16_mod.html","title":"jf_test_16_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_17 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test the rename function.","tags":"","loc":"module/jf_test_17_mod.html","title":"jf_test_17_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_18 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Test the name matching options.","tags":"","loc":"module/jf_test_18_mod.html","title":"jf_test_18_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' working directory character(len=*), public, parameter :: filename2 = 'test2.json' Subroutines public subroutine test_2 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure and write it to a file. public subroutine add_variables_to_input (json, me, variable, units, frame, center, rdata, error_cnt) Arguments Type Intent Optional Attributes Name type( json_core ), intent(inout) :: json type( json_value ), , pointer :: me character(len=*), intent(in) :: variable character(len=*), intent(in) :: units character(len=*), intent(in) :: frame character(len=*), intent(in) :: center real(kind=wp), intent(in), dimension(:) :: rdata integer, intent(inout) :: error_cnt","tags":"","loc":"module/jf_test_2_mod.html","title":"jf_test_2_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' character(len=*), public, parameter :: filename2 = 'test2.json' Subroutines public subroutine test_3 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file generated in test_2 , and extract some data from it.","tags":"","loc":"module/jf_test_3_mod.html","title":"jf_test_3_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' working directory character(len=*), public, parameter :: filename4 = 'test4.json' Subroutines public subroutine test_4 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure, write it to a file,\n then read it.","tags":"","loc":"module/jf_test_4_mod.html","title":"jf_test_4_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename5 = 'test5.json' Subroutines public subroutine test_5 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Github issue example: https://github.com/josephalevin/fson/issues/12","tags":"","loc":"module/jf_test_5_mod.html","title":"jf_test_5_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory Subroutines public subroutine test_6 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description This example tries to read an invalid JSON file.","tags":"","loc":"module/jf_test_6_mod.html","title":"jf_test_6_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_7 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Indent test","tags":"","loc":"module/jf_test_7_mod.html","title":"jf_test_7_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Subroutines public subroutine test_8 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description read a JSON structure from a string","tags":"","loc":"module/jf_test_8_mod.html","title":"jf_test_8_mod – Fortran Program"},{"text":"Uses: json_module iso_fortran_env Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: filename = 'big.json' character(len=*), public, parameter :: dir = '../files/inputs/' Subroutines public subroutine test_9 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Open a random JSON file generated by http://www.json-generator.com public subroutine read_file (filename, str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: str Description Reads the contents of the file into the allocatable string str.\n If there are any problems, str will be returned unallocated.","tags":"","loc":"module/jf_test_9_mod.html","title":"jf_test_9_mod – Fortran Program"},{"text":"Uses: jf_test_1_mod First unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_1.html","title":"jf_test_1 – Fortran Program"},{"text":"Uses: jf_test_10_mod Tenth unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_10.html","title":"jf_test_10 – Fortran Program"},{"text":"Uses: jf_test_11_mod 11th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_11.html","title":"jf_test_11 – Fortran Program"},{"text":"Uses: jf_test_12_mod 12th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_12.html","title":"jf_test_12 – Fortran Program"},{"text":"Uses: jf_test_13_mod 13th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_13.html","title":"jf_test_13 – Fortran Program"},{"text":"Uses: jf_test_14_mod 14th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_14.html","title":"jf_test_14 – Fortran Program"},{"text":"Uses: jf_test_15_mod 15th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_15.html","title":"jf_test_15 – Fortran Program"},{"text":"Uses: jf_test_16_mod 16th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_16.html","title":"jf_test_16 – Fortran Program"},{"text":"Uses: jf_test_17_mod 17th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_17.html","title":"jf_test_17 – Fortran Program"},{"text":"Uses: jf_test_18_mod 18th unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_18.html","title":"jf_test_18 – Fortran Program"},{"text":"Uses: jf_test_2_mod Second unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_2.html","title":"jf_test_2 – Fortran Program"},{"text":"Uses: jf_test_3_mod Third unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_3.html","title":"jf_test_3 – Fortran Program"},{"text":"Uses: jf_test_4_mod Fourth unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_4.html","title":"jf_test_4 – Fortran Program"},{"text":"Uses: jf_test_5_mod Fifth unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_5.html","title":"jf_test_5 – Fortran Program"},{"text":"Uses: jf_test_6_mod Sixth unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_6.html","title":"jf_test_6 – Fortran Program"},{"text":"Uses: jf_test_7_mod Seventh unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_7.html","title":"jf_test_7 – Fortran Program"},{"text":"Uses: jf_test_8_mod Eighth unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_8.html","title":"jf_test_8 – Fortran Program"},{"text":"Uses: jf_test_9_mod Ninth unit test. Variables Type Attributes Name Initial integer :: n_errors","tags":"","loc":"program/jf_test_9.html","title":"jf_test_9 – Fortran Program"},{"text":"Uses: iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: UCS4_K = selected_char_kind('ISO_10646')","tags":"","loc":"program/test_iso_10646_support.html","title":"test_iso_10646_support – Fortran Program"}]}