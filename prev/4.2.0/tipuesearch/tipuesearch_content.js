var tipuesearch = {"pages":[{"text":"JSON-Fortran Brief description License Official Releases Miscellaneous Brief description A user-friendly and object-oriented API for reading and writing JSON files, written in\nmodern Fortran (Fortran 2003+).  The source code is a single Fortran module file\n( json_module.F90 ). License The JSON -Fortran source code and related files and documentation are\ndistributed under a permissive free software license (BSD-style).  See\nthe LICENSE file for more details. Official Releases The current stable release is 4.2.0 and can be downloaded\non GitHub or installed with Homebrew on Mac OSX. The\ndocumentation for the current version, 4.2.0 , can be\nfound here 1 , and a\nlist of changes from the previous version are here . A list of all past releases, links to their documentation, and the\nchage log can be found on the releases page . Miscellaneous For more information about JSON , see: http://www.json.org/ Documentation for a particular release does not contain links\nback to general documentation; use the browser's back button to\nnavigate back to http://jacobwilliams.github.io/json-fortran/ â†© Developer Info Jacob Williams","tags":"home","loc":"index.html","title":" JSON-Fortran "},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !# JSON-Fortran: !  A Fortran 2008 JSON (JavaScript Object Notation) API. ! !  [TOC] ! !  This module provides an interface for reading and writing JSON files. ! !@note ```-DUSE_UCS4``` is an optional preprocessor flag. !      When present, Unicode support is enabled. Note that this !      is currently only supported with the gfortran compiler. !      Example: ```gfortran -DUSE_UCS4 ... ``` #ifdef USE_UCS4 #  pragma push_macro(\"USE_UCS4\") #  undef USE_UCS4 !      The documentation given here assumes ```USE_UCS4``` **is** defined. #  pragma pop_macro(\"USE_UCS4\") #else !      The documentation given here assumes ```USE_UCS4``` **is not** defined. #endif ! !@warning ```CK``` and ```CDK``` are the JSON-Fortran character kind and JSON-Fortran default !         character kind respectively. Client code **MUST** ensure characters of ```kind=CK``` !         are used for all character variables and strings passed to the JSON-Fortran !         library *EXCEPT* for file names which must be of ```'DEFAULT'``` character kind, !         provided here as ```CDK```. In particular, any variable that is a: json path, string !         value or object name passed to the JSON-Fortran library **MUST** be of type ```CK```. ! !@note Most string literal constants of default kind are fine to pass as arguments to !      JSON-Fortran procedures since they have been overloaded to accept ```intent(in)``` !      character arguments of the default (```CDK```) kind. If you find a procedure which does !      not accept an ```intent(in)``` literal string argument of default kind, please !      [file an issue](https://github.com/jacobwilliams/json-fortran/issues/new) on github. ! !## License ! !  **JSON-Fortran License:** ! !    JSON-Fortran: A Fortran 2008 JSON API ! !    http://github.com/jacobwilliams/json-fortran ! !    Copyright (c) 2014-2015, Jacob Williams ! !    All rights reserved. ! !    Redistribution and use in source and binary forms, with or without modification, !    are permitted provided that the following conditions are met: !    * Redistributions of source code must retain the above copyright notice, this !      list of conditions and the following disclaimer. !    * Redistributions in binary form must reproduce the above copyright notice, this !      list of conditions and the following disclaimer in the documentation and/or !      other materials provided with the distribution. !    * The names of its contributors may not be used to endorse or promote products !      derived from this software without specific prior written permission. !    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND !    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED !    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR !    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES !    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; !    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON !    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT !    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !  **Original FSON License:** ! !    Copyright (c) 2012 Joseph A. Levin ! !    Permission is hereby granted, free of charge, to any person obtaining a copy of this !    software and associated documentation files (the \"Software\"), to deal in the Software !    without restriction, including without limitation the rights to use, copy, modify, merge, !    publish, distribute, sublicense, and/or sell copies of the Software, and to permit !    persons to whom the Software is furnished to do so, subject to the following conditions: ! !    The above copyright notice and this permission notice shall be included in all copies or !    substantial portions of the Software. ! !    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, !    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR !    PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE !    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT !    OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER !    DEALINGS IN THE SOFTWARE. ! !## History !  * Joseph A. Levin : March 2012 : Original FSON code [retrieved on 12/2/2013]. !  * Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code. !    The original F95 code was split into four files: !    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95. !    The new code has been extensively updated, refactored and combined into this !    one module (json_module.f90). !    Various Fortran 2003/2008 features are now used !    (e.g., allocatable strings, newunit, generic, class, and abstract interface). !  * Development continues at: [Github](http://github.com/jacobwilliams/json-fortran) ! !## See also !  * [json-fortran development site](http://github.com/jacobwilliams/json-fortran) !  * [json-fortran online documentation](http://jacobwilliams.github.io/json-fortran) !  * [JSON website](http://www.json.org/) !  * [JSON validator](http://jsonlint.com/) module json_module use , intrinsic :: iso_fortran_env implicit none private integer , parameter :: RK = real64 !! Default real kind [8 bytes] integer , parameter :: IK = int32 !! Default integer kind [4 bytes]. !********************************************************* !> !  Processor dependendant 'DEFAULT' character kind. !  This is 1 byte for the Intel and Gfortran compilers. integer , parameter , public :: CDK = selected_char_kind ( 'DEFAULT' ) !********************************************************* !********************************************************* !> !  Default logical kind. !  This is 4 bytes for the Intel and Gfortran compilers !  (and perhaps others). !  The declaration ensures a valid kind !  if the compiler doesn't have a logical_kinds(3). ! integer , parameter :: LK = logical_kinds ( min ( 3 , size ( logical_kinds ))) !********************************************************* !********************************************************* !> !  String kind preprocessor macro. ! #if defined __GFORTRAN__ && defined USE_UCS4 ! gfortran compiler AND UCS4 support requested: character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'ISO_10646' #else ! this is the string kind to use unless compiling with GFortran AND ! UCS4/ISO 10646 support is requested character ( kind = CDK , len =* ), parameter :: json_fortran_string_kind = 'DEFAULT' #endif !********************************************************* !********************************************************* !> !  Default character kind used by JSON-Fortran. !  If ISO 10646 (UCS4) support is available, use that, !  otherwise, gracefully fall back on 'DEFAULT' characters. !  Currently only gfortran >= 4.9.2 will correctly support !  UCS4 which is stored in 4 bytes. !  (and perhaps others). integer , parameter , public :: CK = selected_char_kind ( json_fortran_string_kind ) !********************************************************* !********************************************************* ! File encoding preprocessor macro. ! #if defined __GFORTRAN__ && defined USE_UCS4 ! gfortran compiler AND UCS4 support requested, & silence redefine warning: ! Make sure we output files with utf-8 encoding too #define FILE_ENCODING ,encoding='UTF-8' #else ! don't ask for utf-8 file encoding unless using UCS4 ! this may let us use unformatted stream io to read in files more quickly ! even with unicode support turned on `inquire( ... encoding=FL_ENCODING)` ! may be able to detect json files in which each character is exactly one ! byte #define FILE_ENCODING #endif !********************************************************* !********************************************************* ! This C preprocessor macro will take a procedure name as an ! input, and output either that same procedure name if the ! code is compiled without USE_UCS4 being defined or it will ! expand the procedure name to the original procedure name, ! followed by a comma and then the original procedure name ! with 'wrap_' prepended to it. This is suitable for creating ! overloaded interfaces that will accept UCS4 character actual ! arguments as well as DEFAULT/ASCII character arguments, ! based on whether or not ISO 10646 is supported and requested. ! # ifdef USE_UCS4 #   ifdef __GFORTRAN__ ! gfortran uses cpp in old-school compatibility mode so ! the # stringify and ## concatenate operators don't work ! but we can use C/C++ style comment to ensure PROCEDURE is ! correctly tokenized and prepended with 'wrap_' when the ! macro is expanded #     define MAYBEWRAP(PROCEDURE) PROCEDURE , wrap_/**/PROCEDURE #   endif !   ifdef __INTEL_COMPILER ! Intel's fpp does support the more contemporary ## concatenation ! operator, but doesn't treat the C/C++ comments the same way. ! If you use the gfortran approach and pass the -noB switch to ! fpp, the macro will expand, but with a space between wrap_ and ! whatever PROCEDURE expands to ! Intel doesn't support ISO 10646 yet, but this is here to ! ease the transition once they do. !     define MAYBEWRAP(PROCEDURE) PROCEDURE , wrap_##PROCEDURE !   endif # else #   define MAYBEWRAP(PROCEDURE) PROCEDURE # endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 logical , parameter :: use_unformatted_stream = . false . #else logical , parameter :: use_unformatted_stream = . true . #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: access_spec = 'SEQUENTIAL' #else character ( kind = CDK , len =* ), parameter :: access_spec = 'STREAM' #endif !********************************************************* !********************************************************* !> !  If Unicode is not enabled, then !  JSON files are opened using access='STREAM' and !  form='UNFORMATTED'.  This allows the file to !  be read faster. ! #ifdef USE_UCS4 character ( kind = CDK , len =* ), parameter :: form_spec = 'FORMATTED' #else character ( kind = CDK , len =* ), parameter :: form_spec = 'UNFORMATTED' #endif !********************************************************* !********************************************************* ! !  The types of JSON data. ! integer ( IK ), parameter , public :: json_unknown = 0 !! Unknown JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_null = 1 !! Null JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_object = 2 !! Object JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_array = 3 !! Array JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_logical = 4 !! Logical JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_integer = 5 !! Integer JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_double = 6 !! Double JSON data type (see [[json_file_variable_info]] and [[json_info]]) integer ( IK ), parameter , public :: json_string = 7 !! String JSON data type (see [[json_file_variable_info]] and [[json_info]]) !********************************************************* !********************************************************* !> !  Type used to construct the linked-list JSON structure. !  Normally, this should always be a pointer variable. ! !# Example ! !  The following test program: !```fortran !    program test !     use json_module !     implicit none !     type(json_value),pointer :: p !     call json_initialize()         !initialize the module !     call json_create_object(p,'')  !create the root !     call json_add(p,'year',1805)   !add some data !     call json_add(p,'value',1.0d0) !add some data !     call json_print(p,'test.json') !write it to a file !     call json_destroy(p)           !cleanup !    end program test !``` !  Produces the JSON file **test.json**: !```json !    { !      \"year\": 1805, !      \"value\": 0.1E+1 !    } !``` type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value !********************************************************* !********************************************************* !> author: Jacob Williams !  date: 12/9/2013 ! !  The json_file is the main public class that is !  used to open a file and get data from it. ! !# Example ! !```fortran !    program test !    use json_module !    implicit none !    type(json_file) :: json !    integer :: ival !    real(real64) :: rval !    character(len=:),allocatable :: cval !    logical :: found !    call json_initialize() !    call json%load_file(filename='myfile.json') !    call json%print_file() !print to the console !    call json%get('var.i',ival,found) !    call json%get('var.r(3)',rval,found) !    call json%get('var.c',cval,found) !    call json%destroy() !    end program test !``` type , public :: json_file private type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & json_file_get_root generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #     ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #     endif !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !git info: procedure :: MAYBEWRAP ( json_file_variable_info ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: json_file_get_root !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #     ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #     endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file !********************************************************* !********************************************************* !> author: Izaak Beekman !  date: 07/23/2015 ! !  Structure constructor to initialize a [[json_file(type)]] object !  with an existing [[json_value]] object ! !# Example ! !```fortran ! ... ! type(json_file)  :: my_file ! type(json_value) :: json_object ! ... ! ! Construct a json_object ! my_file = json_file(json_object) !``` interface json_file module procedure initialize_json_file end interface !************************************************************************************* !************************************************************************************* abstract interface subroutine array_callback_func ( element , i , count ) !! Array element callback function.  Used by [[json_get_array]] import :: json_value , IK implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array end subroutine array_callback_func subroutine traverse_callback_func ( p , finished ) !! Callback function used by [[json_traverse]] import :: json_value , LK implicit none type ( json_value ), pointer , intent ( in ) :: p logical ( LK ), intent ( out ) :: finished end subroutine traverse_callback_func end interface !************************************************************************************* # ifdef USE_UCS4 ! Provide a means to convert to UCS4 while concatenating UCS4 and default strings interface operator ( // ) module procedure ucs4_join_default , default_join_ucs4 end interface ! Provide a string comparison operator that works with mixed kinds interface operator ( == ) module procedure ucs4_comp_default , default_comp_ucs4 end interface # endif !************************************************************************************* !> !  Get a child, either by index or name string. !  Both of these return a [[json_value]] pointer. ! !@note Formerly, this was called json_value_get_child interface json_get_child module procedure json_value_get_by_index module procedure MAYBEWRAP ( json_value_get_by_name_chars ) end interface json_get_child !************************************************************************************* !************************************************************************************* !> !  Add objects to a linked list of [[json_value]]s. ! !@note Formerly, this was called json_value_add interface json_add module procedure json_value_add_member module procedure MAYBEWRAP ( json_value_add_integer ) module procedure MAYBEWRAP ( json_value_add_integer_vec ) module procedure MAYBEWRAP ( json_value_add_double ) module procedure MAYBEWRAP ( json_value_add_double_vec ) module procedure MAYBEWRAP ( json_value_add_logical ) module procedure MAYBEWRAP ( json_value_add_logical_vec ) module procedure MAYBEWRAP ( json_value_add_string ) module procedure MAYBEWRAP ( json_value_add_string_vec ) #     ifdef USE_UCS4 module procedure json_value_add_string_name_ascii module procedure json_value_add_string_val_ascii module procedure json_value_add_string_vec_name_ascii module procedure json_value_add_string_vec_val_ascii #     endif end interface json_add !************************************************************************************* !************************************************************************************* !> !  These are like [[json_add]], except if a child with the same name is !  already present, then its value is simply updated. !  Note that currently, these only work for scalar variables. !  These routines can also change the variable's type (but an error will be !  thrown if the existing variable is not a scalar). ! !@note It should not be used to change the type of a variable in an array, !      or it may result in an invalid JSON file. interface json_update module procedure MAYBEWRAP ( json_update_logical ),& MAYBEWRAP ( json_update_double ),& MAYBEWRAP ( json_update_integer ),& MAYBEWRAP ( json_update_string ) #     ifdef USE_UCS4 module procedure json_update_string_name_ascii module procedure json_update_string_val_ascii #     endif end interface json_update !************************************************************************************* !************************************************************************************* !> !  Get data from a [[json_value]] linked list. ! !@note There are two versions (e.g. [[json_get_integer]] and [[json_get_integer_with_path]]). !      The first one gets the value from the [[json_value]] passed into the routine, !      while the second one gets the value from the [[json_value]] found by parsing the !      path.  The path version is split up into unicode and non-unicode versions. interface json_get module procedure MAYBEWRAP ( json_get_by_path ) module procedure json_get_integer , MAYBEWRAP ( json_get_integer_with_path ) module procedure json_get_integer_vec , MAYBEWRAP ( json_get_integer_vec_with_path ) module procedure json_get_double , MAYBEWRAP ( json_get_double_with_path ) module procedure json_get_double_vec , MAYBEWRAP ( json_get_double_vec_with_path ) module procedure json_get_logical , MAYBEWRAP ( json_get_logical_with_path ) module procedure json_get_logical_vec , MAYBEWRAP ( json_get_logical_vec_with_path ) module procedure json_get_string , MAYBEWRAP ( json_get_string_with_path ) module procedure json_get_string_vec , MAYBEWRAP ( json_get_string_vec_with_path ) module procedure json_get_array , MAYBEWRAP ( json_get_array_with_path ) end interface json_get !************************************************************************************* !************************************************************************************* !> !  Print the json_value structure to an allocatable string. interface json_print_to_string module procedure json_value_to_string end interface !************************************************************************************* !************************************************************************************* !> !  Print the [[json_value]] to a file. ! !# Example ! !```fortran !    type(json_value) :: p !    !... !    call json_print(p,'test.json')  !this is [[json_print_2]] !``` interface json_print module procedure json_print_1 !input is unit number module procedure json_print_2 !input is file name end interface !************************************************************************************* !************************************************************************************* !> !  Destructor routine for a [[json_value]] pointer. !  This must be called explicitly if it is no longer needed, !  before it goes out of scope.  Otherwise, a memory leak will result. ! !# Example ! !  Destroy the [[json_value]] pointer before the variable goes out of scope: !```fortran !     subroutine example1() !     type(json_value),pointer :: p !     call json_create_object(p,'') !     call json_add(p,'year',2015) !     call json_print(p) !     call json_destroy(p) !     end subroutine example1 !``` ! !  Note: it should NOT be called for a [[json_value]] pointer than has already been !  added to another [[json_value]] structure, since doing so may render the !  other structure invalid.  Consider the following example: !```fortran !     subroutine example2(p) !     type(json_value),pointer,intent(out) :: p !     type(json_value),pointer :: q !     call json_create_object(p,'') !     call json_add(p,'year',2015) !     call json_create_object(q,'q') !     call json_add(q,'val',1) !     call json_add(p, q)  !add q to p structure !     ! do NOT call json_destroy(q) here, because q is !     ! now part of the output structure p.  p should be destroyed !     ! somewhere upstream by the caller of this routine. !     nullify(q) !OK, but not strictly necessary !     end subroutine example2 !``` interface json_destroy module procedure json_value_destroy end interface !************************************************************************************* !************************************************************************************* !> !  Remove a [[json_value]] from a linked-list structure. interface json_remove module procedure json_value_remove end interface !************************************************************************************* !************************************************************************************* !> !  If the child variable is present, then remove it. interface json_remove_if_present module procedure MAYBEWRAP ( json_value_remove_if_present ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a [[json_value]] pointer and make it a double variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !    type(json_value),pointer :: p !    call json_create_double(p,'value',1.0d0) !``` interface json_create_double module procedure MAYBEWRAP ( json_value_create_double ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !     type(json_value),pointer :: p !     call json_create(p,'arrayname') !``` interface json_create_array module procedure MAYBEWRAP ( json_value_create_array ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !     type(json_value),pointer :: p !     call json_create(p,'objectname') !``` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. interface json_create_object module procedure MAYBEWRAP ( json_value_create_object ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !     type(json_value),pointer :: p !     call json_create_null(p,'value') !``` interface json_create_null module procedure MAYBEWRAP ( json_value_create_null ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !     type(json_value),pointer :: p !     call json_create_string(p,'value','foobar') !``` interface json_create_string module procedure MAYBEWRAP ( json_value_create_string ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a json_value pointer and make it an integer variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !     type(json_value),pointer :: p !     call json_create_integer(p,'value',42) !``` interface json_create_integer module procedure MAYBEWRAP ( json_value_create_integer ) end interface !************************************************************************************* !************************************************************************************* !> !  Allocate a json_value pointer and make it a logical variable. !  The pointer should not already be allocated. ! !# Example ! !```fortran !     type(json_value),pointer :: p !     call json_create_logical(p,'value',.true.) !``` interface json_create_logical module procedure MAYBEWRAP ( json_value_create_logical ) end interface !************************************************************************************* !************************************************************************************* !> !  Parse the JSON file and populate the [[json_value]] tree. interface json_parse module procedure json_parse_file , MAYBEWRAP ( json_parse_string ) end interface !************************************************************************************* !************************************************************************************* !> !  Convert a 'DEFAULT' kind character input to 'ISO_10646' kind and return it interface to_unicode module procedure to_uni , to_uni_vec end interface !************************************************************************************* !************************************************************************************* !> !  Throw an exception. interface throw_exception module procedure MAYBEWRAP ( json_throw_exception ) end interface throw_exception !************************************************************************************* !public routines: public :: json_add ! add data to a JSON structure public :: json_check_for_errors ! check for error and get error message public :: json_clear_exceptions ! clear exceptions public :: json_count ! count the number of children public :: json_create_array ! allocate a json_value array public :: json_create_double ! allocate a json_value double public :: json_create_integer ! allocate a json_value integer public :: json_create_logical ! allocate a json_value logical public :: json_create_null ! allocate a json_value null public :: json_create_object ! allocate a json_value object public :: json_create_string ! allocate a json_value string public :: json_destroy ! clear a JSON structure (destructor) public :: json_failed ! check for error public :: json_get ! get data from the JSON structure public :: json_get_child ! get a child of a json_value public :: json_info ! get info about a json_value public :: json_initialize ! to initialize the module public :: json_parse ! read a JSON file and populate the structure public :: json_print ! print the JSON structure to a file public :: json_print_to_string ! write the JSON structure to a string public :: json_remove ! remove from a JSON structure public :: json_remove_if_present ! remove from a JSON structure (if it is present) public :: json_update ! update a value in a JSON structure public :: json_traverse ! to traverse all elements of a JSON structure public :: json_print_error_message ! public :: to_unicode ! Function to convert from 'DEFAULT' to 'ISO_10646' strings # ifdef USE_UCS4 public :: operator ( // ) public :: operator ( == ) # endif character ( kind = CDK , len =* ), parameter , public :: json_ext = '.json' !! JSON file extension !special JSON characters character ( kind = CK , len =* ), parameter :: space = ' ' character ( kind = CK , len =* ), parameter :: start_object = '{' character ( kind = CK , len =* ), parameter :: end_object = '}' character ( kind = CK , len =* ), parameter :: start_array = '[' character ( kind = CK , len =* ), parameter :: end_array = ']' character ( kind = CK , len =* ), parameter :: delimiter = ',' character ( kind = CK , len =* ), parameter :: colon_char = ':' character ( kind = CK , len =* ), parameter :: bspace = achar ( 8 ) character ( kind = CK , len =* ), parameter :: horizontal_tab = achar ( 9 ) character ( kind = CK , len =* ), parameter :: newline = achar ( 10 ) character ( kind = CK , len =* ), parameter :: formfeed = achar ( 12 ) character ( kind = CK , len =* ), parameter :: carriage_return = achar ( 13 ) character ( kind = CK , len =* ), parameter :: quotation_mark = achar ( 34 ) character ( kind = CK , len =* ), parameter :: slash = achar ( 47 ) character ( kind = CK , len =* ), parameter :: backslash = achar ( 92 ) !These were parameters, but gfortran bug (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65141) !necessitates moving them here to be variables character ( kind = CK , len = 4 ) :: null_str = 'null' character ( kind = CK , len = 4 ) :: true_str = 'true' character ( kind = CK , len = 5 ) :: false_str = 'false' ! Control characters, possibly in unicode integer , private :: i_ character ( kind = CK , len =* ), parameter :: control_chars ( 32 ) = [( achar ( i_ ), i_ = 1 , 31 ), achar ( 127 )] !for indenting (Note: jsonlint.com uses 4 spaces) integer ( IK ), parameter :: spaces_per_tab = 2 !Variables for real string printing: logical ( LK ) :: compact_real = . true . !! to use the \"compact\" form of real numbers for output !find out the precision of the floating point number system !and set safety factors integer ( IK ), parameter :: rp_safety_factor = 1 integer ( IK ), parameter :: rp_addl_safety = 1 integer ( IK ), parameter :: real_precision = rp_safety_factor * precision ( 1.0_RK ) + & rp_addl_safety !Get the number of possible digits in the exponent when using decimal number system integer ( IK ), parameter :: maxexp = maxexponent ( 1.0_RK ) integer ( IK ), parameter :: minexp = minexponent ( 1.0_RK ) integer ( IK ), parameter :: real_exponent_digits = floor ( 1 + log10 ( & real ( max ( maxexp , abs ( maxexp )),& kind = RK ) ) ) integer ( IK ), parameter :: max_numeric_str_len = real_precision + real_exponent_digits + 6 !! 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character ( kind = CDK , len =* ), parameter :: int_fmt = '(ss,I0)' !! minimum width format for integers character ( kind = CK , len =* ), parameter :: star = '*' !! for invalid numbers character ( kind = CDK , len = :), allocatable :: real_fmt !! the format string to use for real numbers !! it is set in [[json_initialize]] ! ! Note: the following global variables make this module non thread safe. ! !exception handling [private variables] logical ( LK ) :: is_verbose = . false . !! if true, all exceptions are immediately printed to console logical ( LK ) :: exception_thrown = . true . !! the error flag (by default, this is true to make sure that [[json_initialize]] is called. character ( kind = CK , len = :), allocatable :: err_message !! the error message !temp vars used when parsing lines in file [private variables] integer ( IK ) :: char_count = 0 !character position in the current line integer ( IK ) :: line_count = 1 !lines read counter integer ( IK ) :: pushed_index = 0 character ( kind = CK , len = 10 ) :: pushed_char = '' !JW : what is this magic number 10?? integer ( IK ), parameter :: chunk_size = 100 !! for allocatable strings: allocate chunks of this size integer ( IK ) :: ipos = 1 !! for allocatable strings: next character to read integer ( IK ), parameter :: unit2str = - 1 !! unit number to cause stuff to be !! output to strings rather than files. !! See 9.5.6.12 in the F2003/08 standard contains !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 07/23/2015 ! !  Cast a [[json_value]] object as a [[json_file(type)]] object function initialize_json_file ( p ) result ( file_object ) implicit none type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object type ( json_file ) :: file_object if ( present ( p )) file_object % p => p end function initialize_json_file !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Destroy the data within a [[json_value]], and rest type to `json_unknown`. subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Destroy the [[json_file(type)]]. subroutine json_file_destroy ( me ) implicit none class ( json_file ), intent ( inout ) :: me if ( associated ( me % p )) call json_value_destroy ( me % p ) end subroutine json_file_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2014 ! !  Move the [[json_value]] pointer from one [[json_file(type)]] to another. !  The \"from\" pointer is then nullified, but not destroyed. ! !@note If \"from%p\" is not associated, then an error is thrown. subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then to % p => from % p nullify ( from % p ) else call throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Load the JSON data from a file. ! !# Example ! !```fortran !     type(json_file) :: f !     call f%load_file('my_file.json') !``` subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use call json_parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/13/2015 ! !  Load the JSON data from a string. ! !# Example ! !  Load JSON from a string: !```fortran !     type(json_file) :: f !     call f%load_from_string('{ \"name\": \"Leonidas\" }') !``` subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call json_parse ( str = str , p = me % p ) end subroutine json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_load_from_string]], where \"str\" is kind=CDK. subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call json_file_load_from_string ( me , to_unicode ( str )) end subroutine wrap_json_file_load_from_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to the console. subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable :: dummy call json_value_print ( me % p , iunit = output_unit , str = dummy , indent = 1 , colon = . true .) end subroutine json_file_print_to_console !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Prints the JSON file to the specified file unit number. subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) integer ( IK ) :: i character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then i = iunit call json_value_print ( me % p , iunit = i , str = dummy , indent = 1 , colon = . true .) else call throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON structure to the specified filename. !  The file is opened, printed, and then closed. ! !# Example !  Example loading a JSON file, changing a value, and then printing !  result to a new file: !```fortran !     type(json_file) :: f !     logical :: found !     call f%load_file('my_file.json')    !open the original file !     call f%update('version',4,found)    !change the value of a variable !     call f%print_file('my_file_2.json') !save file as new name !``` subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call me % print_file ( iunit ) !call the other routine close ( iunit , iostat = istat ) else call throw_exception ( 'Error in json_file_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_file_print_2 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/11/2015 ! !  Print the JSON file to a string. ! !# Example ! !  Open a JSON file, and then print the contents to a string: !```fortran !     type(json_file) :: f !     character(kind=CK,len=:),allocatable :: str !     call f%load_file('my_file.json') !     call f%print_file(str) !``` subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call json_value_to_string ( me % p , str ) end subroutine json_file_print_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Returns information about a variable in a [[json_file(type)]]. subroutine json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: found !! the variable exists in the structure integer ( IK ), intent ( out ) :: var_type !! variable type integer ( IK ), intent ( out ) :: n_children !! number of children type ( json_value ), pointer :: p !initialize: nullify ( p ) !get a pointer to the variable (if it is there): call me % get ( path , p , found ) if ( found ) then !get info: call json_info ( p , var_type , n_children ) else !set to dummy values: var_type = json_unknown n_children = 0 end if !cleanup: nullify ( p ) end subroutine json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_variable_info]], where \"path\" is kind=CDK. subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: found integer ( IK ), intent ( out ) :: var_type integer ( IK ), intent ( out ) :: n_children call json_file_variable_info ( me , to_unicode ( path ), found , var_type , n_children ) end subroutine wrap_json_file_variable_info !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/13/2014 ! !  Returns information about a [[json_value]]. subroutine json_info ( p , var_type , n_children , name ) implicit none type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json_count ( p ) if ( present ( name )) name = p % name end subroutine json_info !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2014 ! !  Get a [[json_value]] pointer to an object from a JSON file. subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call json_get_by_path ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 7/23/2015 ! !  Get a [[json_value]] pointer to the JSON file root. ! !@note This is equivalent to calling ```[[json_file]]%get('$',p)``` subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_object]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json_file_get_object ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get an integer value from a JSON file. subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_integer ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get an integer vector from a JSON file. subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_integer_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_integer_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a real(RK) variable value from a JSON file. subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_double ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a real(RK) vector from a JSON file. subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_double_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_double_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a logical(LK) value from a JSON file. subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_logical ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Get a logical(LK) vector from a JSON file. subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_logical_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_logical_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/9/2013 ! !  Get a character string from a json file. !  The output val is an allocatable character string. subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_string ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Get a string vector from a JSON file. subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_get_string_vec]], where \"path\" is kind=CDK. subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_string_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Initialize the JSON-Fortran module. !  The routine must be called before any of the routines are used. !  It can also be called after using the module and encountering exceptions. ! !# Modified !  * Izaak Beekman : 02/24/2015 subroutine json_initialize ( verbose , compact_reals , print_signs , real_format ) implicit none logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( len =* , kind = CDK ), intent ( in ), optional :: real_format !! exponential (default), scientific, engineering or general character ( kind = CDK , len = 10 ) :: w , d , e character ( kind = CDK , len = 2 ) :: sgn , rl_edit_desc integer ( IK ) :: istat logical ( LK ) :: sgn_prnt !clear any errors from previous runs: call json_clear_exceptions () !Ensure gfortran bug work around \"parameters\" are set properly null_str = 'null' true_str = 'true' false_str = 'false' !Just in case, clear these global variables also: pushed_index = 0 pushed_char = '' char_count = 0 line_count = 1 ipos = 1 # ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) # endif !verbose error printing: if ( present ( verbose )) is_verbose = verbose !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then if ( present ( compact_reals )) compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call throw_exception ( 'Invalid real format, \"' // trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // '30.16E3)' !just use this one (should never happen) end if end if end subroutine json_initialize !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Clear exceptions in the JSON module. subroutine json_clear_exceptions () implicit none !clear the flag and message: exception_thrown = . false . err_message = '' end subroutine json_clear_exceptions !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Throw an exception in the JSON module. !  This routine sets the error flag, and prevents any subsequent routine !  from doing anything, until [[json_clear_exceptions]] is called. subroutine json_throw_exception ( msg ) implicit none character ( kind = CK , len =* ), intent ( in ) :: msg !the error message exception_thrown = . true . err_message = trim ( msg ) if ( is_verbose ) then write ( * , '(A)' ) '***********************' write ( * , '(A)' ) 'JSON-Fortran EXCEPTION: ' // trim ( msg ) !call backtrace()     ! gfortran (use -fbacktrace -fall-intrinsics flags) !call tracebackqq(-1) ! intel (requires \"use ifcore\" in this routine) write ( * , '(A)' ) '***********************' end if end subroutine json_throw_exception !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_throw_exception]], where \"msg\" is kind=CDK. subroutine wrap_json_throw_exception ( msg ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: msg !the error message call json_throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Retrieve error code from the module. !  This should be called after [[json_parse]] to check for errors. !  If an error is thrown, before using the module again, [[json_initialize]] !  should be called to clean up before it is used again. ! !# Example ! !```fortran !     type(json_file) :: json !     logical :: status_ok !     character(kind=CK,len=:),allocatable :: error_msg !     call json%load_file(filename='myfile.json') !     call json_check_for_errors(status_ok, error_msg) !     if (.not. status_ok) then !         write(*,*) 'Error: '//error_msg !         call json_clear_exceptions() !         call json%destroy() !     end if !``` ! !# See also !  * [[json_failed]] subroutine json_check_for_errors ( status_ok , error_msg ) implicit none logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . exception_thrown if (. not . status_ok ) then if ( allocated ( err_message )) then error_msg = err_message else error_msg = 'Error: json_initialize() must be called first to initialize the module.' end if else error_msg = '' end if end subroutine json_check_for_errors !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/5/2013 ! !  Logical function to indicate if an exception has been thrown. ! !# Example ! !```fortran !    type(json_file) :: json !    logical :: status_ok !    character(len=:),allocatable :: error_msg !    call json%load_file(filename='myfile.json') !    if (json_failed()) then !        call json_check_for_errors(status_ok, error_msg) !        write(*,*) 'Error: '//error_msg !        call json_clear_exceptions() !        call json%destroy() !    end if !``` ! !# See also !  * [[json_check_for_errors]] ! function json_failed () result ( failed ) implicit none logical ( LK ) :: failed failed = exception_thrown end function json_failed !***************************************************************************************** !***************************************************************************************** !> !  Allocate a [[json_value]] pointer variable. !  This should be called before adding data to it. ! !# Example ! !```fortran !    type(json_value),pointer :: var !    call json_value_create(var) !    call to_double(var,1.0d0) !``` ! !# Notes !  1. This routine does not check for exceptions. !  2. The pointer should not already be allocated. subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/22/2014 ! !  Destroy a [[json_value]] linked-list structure. ! !@note The original FSON version of this !      routine was not properly freeing the memory. !      It was rewritten. recursive subroutine json_value_destroy ( me , destroy_next ) implicit none type ( json_value ), pointer :: me logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then me%next is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: p if ( associated ( me )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( me % name )) deallocate ( me % name ) call destroy_json_data ( me ) if ( associated ( me % children )) then do while ( me % n_children > 0 ) p => me % children me % children => me % children % next me % n_children = me % n_children - 1 call json_value_destroy ( p ,. false .) end do nullify ( me % children ) nullify ( p ) end if if ( associated ( me % next ) . and . des_next ) call json_value_destroy ( me % next ) if ( associated ( me % previous )) nullify ( me % previous ) if ( associated ( me % parent )) nullify ( me % parent ) if ( associated ( me % tail )) nullify ( me % tail ) deallocate ( me ) nullify ( me ) end if end subroutine json_value_destroy !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/9/2014 ! !  Remove a [[json_value]] (and all its children) !  from a linked-list structure, preserving the rest of the structure. ! !# Examples ! !  To extract an object from one JSON structure, and add it to another: !```fortran !     type(json_value),pointer :: json1,json2,p !     logical :: found !     !create and populate json1 and json2 !     call json_get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json_remove(p,destroy=.false.)  ! remove it from json1 (don't destroy) !     call json_add(json2,p)               ! add it to json2 !``` ! !  To remove an object from a JSON structure (and destroy it): !```fortran !     type(json_value),pointer :: json1,p !     logical :: found !     !create and populate json1 !     call json_get(json1,'name',p,found)  ! get pointer to name element of json1 !     call json_remove(p)                  ! remove and destroy it !``` ! !# History !  * Jacob Williams : 12/28/2014 : added destroy optional argument. ! subroutine json_value_remove ( me , destroy ) implicit none type ( json_value ), pointer :: me logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( me )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( me % parent )) then parent => me % parent if ( associated ( me % next )) then !there are later items in the list: next => me % next nullify ( me % next ) if ( associated ( me % previous )) then !there are earlier items in the list previous => me % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( me % previous )) then !there are earlier items in the list: previous => me % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json_value_destroy ( me ) end if end subroutine json_value_remove !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, remove the variable from !  the [[json_value]] structure, if it exists. subroutine json_value_remove_if_present ( p , name ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json_get ( p , name , p_var , found ) if ( found ) call json_remove ( p_var ) end subroutine json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_remove_if_present]], where \"name\" is kind=CDK. subroutine wrap_json_value_remove_if_present ( p , name ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_integer]] subroutine json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_integer]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_integer ( me , to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_logical]] subroutine json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_logical]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_logical ( me , to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_double]] subroutine json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_real !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_real]], where \"name\" is kind=CDK. subroutine wrap_json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_real ( me , to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_real !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/10/2015 ! !  Given the path string, if the variable is present in the file, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. ! !# See also !  * [[json_update_string]] subroutine json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"name\" and \"val\" are kind=CDK. subroutine wrap_json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_string ( me , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_file_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"name\" is kind=CDK. subroutine json_file_update_string_name_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_string ( me , to_unicode ( name ), val , found ) end subroutine json_file_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_file_update_string]], where \"val\" is kind=CDK. subroutine json_file_update_string_val_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_string ( me , name , to_unicode ( val ), found ) end subroutine json_file_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_logical ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_logical ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_logical]], where \"name\" is kind=CDK. subroutine wrap_json_update_logical ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_logical ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_double ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_double ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_double]], where \"name\" is kind=CDK. subroutine wrap_json_update_double ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_double ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_integer ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_integer ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_integer]], where \"name\" is kind=CDK. subroutine wrap_json_update_integer ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_integer ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/6/2014 ! !  Given the path string, if the variable is present, !  and is a scalar, then update its value. !  If it is not present, then create it and set its value. subroutine json_update_string ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_string ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where \"name\" and \"value\" are kind=CDK. subroutine wrap_json_update_string ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_string ( p , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_update_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where \"name\" is kind=CDK. subroutine json_update_string_name_ascii ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_string ( p , to_unicode ( name ), val , found ) end subroutine json_update_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_update_string]], where \"val\" is kind=CDK. subroutine json_update_string_val_ascii ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_string ( p , name , to_unicode ( val ), found ) end subroutine json_update_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Adds \"member\" as a child of \"me\". subroutine json_value_add_member ( me , member ) implicit none type ( json_value ), pointer :: me type ( json_value ), pointer :: member !! the child member to add if (. not . exception_thrown ) then ! associate the parent member % parent => me ! add to linked list if ( associated ( me % children )) then me % tail % next => member member % previous => me % tail else me % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list me % tail => member me % n_children = me % n_children + 1 end if end subroutine json_value_add_member !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a real value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json_value_create ( var ) call to_double ( var , val , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_double !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double]] where \"name\" is kind=CDK. subroutine wrap_json_value_add_double ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json_value_add_double ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a real vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_double_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json_add ( var , '' , val ( i )) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_double_vec]] where \"name\" is kind=CDK. subroutine wrap_json_value_add_double_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json_value_add_double_vec ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json_value_create ( var ) call to_integer ( var , val , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer]] where \"name\" is kind=CDK. subroutine wrap_json_value_add_integer ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json_value_add_integer ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add an integer vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_integer_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !counter !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json_add ( var , '' , val ( i )) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_integer_vec]] where \"name\" is kind=CDK. subroutine wrap_json_value_add_integer_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json_value_add_integer_vec ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical value child to the [[json_value]] variable ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json_value_create ( var ) call to_logical ( var , val , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical]] where \"name\" is kind=CDK. subroutine wrap_json_value_add_logical ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json_value_add_logical ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Add a logical vector to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_logical_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !counter !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json_add ( var , '' , val ( i )) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_logical_vec]] where \"name\" is kind=CDK. subroutine wrap_json_value_add_logical_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json_value_add_logical_vec ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add a character string child to the [[json_value]] variable. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value type ( json_value ), pointer :: var character ( kind = CK , len = :), allocatable :: str !add escape characters if necessary: call escape_string ( val , str ) !create the variable: call json_value_create ( var ) call to_string ( var , str , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where \"name\" and \"val\" are kind=CDK. subroutine wrap_json_value_add_string ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json_value_add_string ( me , to_unicode ( name ), to_unicode ( val )) end subroutine wrap_json_value_add_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where \"name\" is kind=CDK. subroutine json_value_add_string_name_ascii ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value call json_value_add_string ( me , to_unicode ( name ), val ) end subroutine json_value_add_string_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string]] where \"val\" is kind=CDK. subroutine json_value_add_string_val_ascii ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json_value_add_string ( me , name , to_unicode ( val )) end subroutine json_value_add_string_val_ascii !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2014 ! !  Add the escape characters to a string for adding to JSON. subroutine escape_string ( str_in , str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out integer ( IK ) :: i , ipos character ( kind = CK , len = 1 ) :: c character ( kind = CK , len =* ), parameter :: specials = quotation_mark // & backslash // & slash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( scan ( str_in , specials ) > 0 ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( quotation_mark , backslash , slash ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = '' else str_out = str_out ( 1 : ipos - 1 ) end if end if else str_out = str_in end if end subroutine escape_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Add an array of character strings to the structure. ! !@note This routine is part of the public API that can be !      used to build a JSON structure using [[json_value]] pointers. subroutine json_value_add_string_vec ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i logical ( LK ) :: trim_string , adjustl_string character ( kind = CK , len = :), allocatable :: str !if the string is to be trimmed or not: if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) !the string to write: str = val ( i ) if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) !write it: call json_add ( var , '' , str ) !cleanup deallocate ( str ) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where \"name\" and \"val\" are kind=CDK. subroutine wrap_json_value_add_string_vec ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json_value_add_string_vec ( me , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where \"name\" is kind=CDK. subroutine json_value_add_string_vec_name_ascii ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json_value_add_string_vec ( me , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_add_string_vec]] where \"val\" is kind=CDK. subroutine json_value_add_string_vec_val_ascii ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json_value_add_string_vec ( me , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii !***************************************************************************************** !***************************************************************************************** !> !  Count the number of children. ! !# History !  * JW : 1/4/2014 : Original routine removed. !    Now using n_children variable. !    Renamed from json_value_count. pure function json_count ( me ) result ( count ) implicit none integer ( IK ) :: count !! number of children type ( json_value ), pointer , intent ( in ) :: me count = me % n_children end function json_count !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the index. subroutine json_value_get_by_index ( me , idx , p ) implicit none type ( json_value ), pointer , intent ( in ) :: me !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child type ( json_value ), pointer :: p !! pointer to the child integer ( IK ) :: i nullify ( p ) if (. not . exception_thrown ) then if ( associated ( me % children )) then p => me % children do i = 1 , idx - 1 if ( associated ( p % next )) then p => p % next else call throw_exception ( 'Error in json_value_get_by_index:' // & ' p%next is not associated.' ) nullify ( p ) return end if end do else call throw_exception ( 'Error in json_value_get_by_index:' // & ' me%children is not associated.' ) end if end if end subroutine json_value_get_by_index !***************************************************************************************** !***************************************************************************************** !> !  Returns a child in the object or array given the name string. ! !  It is a case-sensitive search, and the name string is not trimmed. !  So, for example, !```fortran !     'a ' /= 'A ' /= 'a  ' !``` ! !@note The \"name\" input is not a path, and is not parsed like it is in [[json_get_by_path]]. subroutine json_value_get_by_name_chars ( me , name , p ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of \"me\" type ( json_value ), pointer :: p !! pointer to the child integer ( IK ) :: i , n_children nullify ( p ) if (. not . exception_thrown ) then if ( associated ( me )) then if ( me % var_type == json_object ) then n_children = json_count ( me ) p => me % children !start with first one do i = 1 , n_children if ( allocated ( p % name )) then if ( p % name == name ) return end if p => p % next end do end if !did not find anything: call throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( p ) else call throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'pointer is not associated.' ) end if end if end subroutine json_value_get_by_name_chars !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_value_get_by_name_chars]] where \"name\" is kind=CDK. subroutine wrap_json_value_get_by_name_chars ( me , name , p ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p call json_value_get_by_name_chars ( me , to_unicode ( name ), p ) end subroutine wrap_json_value_get_by_name_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/12/2014 ! !  Print the [[json_value]] structure to an allocatable string. subroutine json_value_to_string ( me , str ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = '' call json_value_print ( me , iunit = unit2str , str = str , indent = 1 , colon = . true .) end subroutine json_value_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/20/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_1 ( me , iunit ) implicit none type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json_value_print ( me , iunit , str = dummy , indent = 1 , colon = . true .) else call throw_exception ( 'Error in json_print: iunit must not be -1.' ) end if end subroutine json_print_1 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/23/2014 ! !  Print the [[json_value]] structure to a file. subroutine json_print_2 ( me , filename ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json_print ( me , iunit ) close ( iunit , iostat = istat ) else call throw_exception ( 'Error in json_print: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2 !***************************************************************************************** !***************************************************************************************** !> !  Print the JSON structure to a string or a file. ! !# Notes !  * This is an internal routine called by the wrapper routines !    [[json_print]] and [[json_value_to_string]]. !  * The reason the str argument is non-optional is because of a !    bug in v4.9 of the gfortran compiler. recursive subroutine json_value_print ( me , iunit , str , indent , need_comma , colon , is_array_element ) implicit none type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. character ( kind = CK , len = max_numeric_str_len ) :: tmp !for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array if (. not . exception_thrown ) then !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent )) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = '' else s = repeat ( space , spaces ) end if select case ( me % var_type ) case ( json_object ) count = json_count ( me ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then tab = tab + 1 spaces = tab * spaces_per_tab end if nullify ( element ) element => me % children do i = 1 , count ! print the name if ( allocated ( element % name )) then call write_it ( repeat ( space , spaces ) // quotation_mark // & element % name // quotation_mark // colon_char // space ,& advance = . false .) else call throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json_count ( me ) if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( start_array ) nullify ( element ) element => me % children do i = 1 , count ! recursive print of the element call json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) ! get the next child the list: element => element % next end do !indent the closing array character: call write_it ( repeat ( space , max ( 0 , spaces - spaces_per_tab )) // end_array ,& comma = print_comma ) nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma ) case ( json_string ) if ( allocated ( me % str_value )) then call write_it ( s // quotation_mark // & trim ( me % str_value ) // quotation_mark , comma = print_comma ) else call throw_exception ( 'Error in json_value_print:' // & ' me%value_string not allocated' ) return end if case ( json_logical ) if ( me % log_value ) then call write_it ( s // true_str , comma = print_comma ) else call write_it ( s // false_str , comma = print_comma ) end if case ( json_integer ) call integer_to_string ( me % int_value , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case ( json_double ) call real_to_string ( me % dbl_value , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case default call throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains ! ! write the string to the file (or the output string) ! subroutine write_it ( s , advance , comma ) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !string to print logical ( LK ), intent ( in ), optional :: advance !to add line break or not logical ( LK ), intent ( in ), optional :: comma !print comma after the string logical ( LK ) :: add_line_break , add_comma character ( kind = CK , len = :), allocatable :: s2 if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( present ( advance )) then add_line_break = advance else add_line_break = . true . !default is to advance end if !string to print: s2 = s if ( add_comma ) s2 = s2 // delimiter if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print !***************************************************************************************** !***************************************************************************************** !> !  Returns the [[json_value]] pointer given the path string. ! !# Example ! !```fortran !     type(json_value),pointer :: dat,p !     logical :: found !     !... !     call json_get(dat,'data(2).version',p,found) !``` ! !# Notes !  The following special characters are used to denote paths: ! !``` !  $         - root !  @         - this !  .         - child object member !  [] or ()  - child array element !``` ! !  Thus, if any of these characters are present in the name key, !  this routine cannot be used to get the value. !  In that case, the [[json_get_child]] routines would need to be used. subroutine json_get_by_path ( me , path , p , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found !! true if it was found character ( kind = CK , len = 1 ), parameter :: start_array_alt = '(' character ( kind = CK , len = 1 ), parameter :: end_array_alt = ')' integer ( IK ) :: i , length , child_i character ( kind = CK , len = 1 ) :: c logical ( LK ) :: array type ( json_value ), pointer :: tmp if (. not . exception_thrown ) then nullify ( p ) ! default to assuming relative to this p => me child_i = 1 array = . false . length = len_trim ( path ) do i = 1 , length c = path ( i : i ) select case ( c ) case ( CK_ '$' ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 case ( CK_ '@' ) ! this p => me child_i = i + 1 case ( CK_ '.' ) ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json_get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_by_path:' // & ' Error getting child member.' ) exit end if child_i = i + 1 case ( start_array , start_array_alt ) !....Modified to allow for 'var[3]' style syntax !Note: jmozmoz/fson has a slightly different version of this... ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json_get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_by_path:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call throw_exception ( 'Error in json_get_by_path: Unexpected ]' ) exit end if array = . false . child_i = string_to_integer ( path ( child_i : i - 1 )) nullify ( tmp ) call json_get_child ( p , child_i , tmp ) p => tmp nullify ( tmp ) child_i = i + 1 end select end do if ( exception_thrown ) then if ( present ( found )) then found = . false . call json_clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) call json_get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) end if if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call throw_exception ( 'Error in json_get_by_path:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json_clear_exceptions () end if end if end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_by_path]] where \"path\" is kind=CDK. subroutine wrap_json_get_by_path ( me , path , p , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json_get_by_path ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path !***************************************************************************************** !***************************************************************************************** !> !  Convert a string into an integer. ! !# History !  * Jacob Williams : 12/10/2013 : Rewrote routine.  Added error checking. !  * Modified by Izaak Beekman ! !@note Replacement for the parse_integer function in the original code. function string_to_integer ( str ) result ( ival ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr if (. not . exception_thrown ) then ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer if ( ierr /= 0 ) then !if there was an error ival = 0 call throw_exception ( 'Error in string_to_integer:' // & ' string cannot be converted to an integer: ' // trim ( str )) end if else ival = 0 end if end function string_to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/19/2014 ! !  Convert a string into a double. function string_to_double ( str ) result ( rval ) implicit none real ( RK ) :: rval character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ierr if (. not . exception_thrown ) then read ( str , fmt = real_fmt , iostat = ierr ) rval !string to double if ( ierr /= 0 ) then !if there was an error rval = 0.0_RK call throw_exception ( 'Error in string_to_double:' // & ' string cannot be converted to a double: ' // trim ( str )) end if end if end function string_to_double !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]]. subroutine json_get_integer ( me , value ) implicit none type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( exception_thrown ) return select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end subroutine json_get_integer !***************************************************************************************** !***************************************************************************************** !> !  Get an integer value from a [[json_value]], given the path string. subroutine json_get_integer_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_integer ( p , value ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found ) ) then found = . false . call json_clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_with_path]], where \"path\" is kind=CDK. subroutine wrap_json_get_integer_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_integer_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get an integer vector from a [[json_value]]. subroutine json_get_integer_vec ( me , vec ) implicit none type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_int_from_array ) contains ! callback function for integer subroutine get_int_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec !***************************************************************************************** !***************************************************************************************** !> !  Get an integer vector from a [[json_value]], given the path string. subroutine json_get_integer_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . call json_get ( me , path = path , array_callback = get_int_from_array , found = found ) ! need to duplicate callback function, no other way contains ! callback function for integer subroutine get_int_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_integer_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_integer_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_integer_vec_with_path ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]]. subroutine json_get_double ( me , value ) implicit none type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( exception_thrown ) return select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_double ) value = me % dbl_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end subroutine json_get_double !***************************************************************************************** !***************************************************************************************** !> !  Get a double value from a [[json_value]], given the path. subroutine json_get_double_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_double ( p , value ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found )) then found = . false . call json_clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_double_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a double vector from a [[json_value]]. subroutine json_get_double_vec ( me , vec ) implicit none type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_double_from_array ) contains ! callback function for double subroutine get_double_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a double vector from a [[json_value]], given the path. subroutine json_get_double_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , path = path , array_callback = get_double_from_array , found = found ) contains ! callback function for double subroutine get_double_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_double_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_double_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_double_vec_with_path ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]]. subroutine json_get_logical ( me , value ) implicit none type ( json_value ), pointer , intent ( in ) :: me logical ( LK ) :: value value = . false . if ( exception_thrown ) return select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case ( json_logical ) value = me % log_value case default call throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve value to logical: ' // me % name ) end select end subroutine json_get_logical !***************************************************************************************** !***************************************************************************************** !> !  Get a logical value from a [[json_value]], given the path. subroutine json_get_logical_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_logical ( p , value ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found )) then found = . false . call json_clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_logical_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a logical vector from [[json_value]]. subroutine json_get_logical_vec ( me , vec ) implicit none type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_logical_from_array ) contains ! callback function for logical subroutine get_logical_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a logical vector from a [[json_value]], given the path. subroutine json_get_logical_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , path = path , array_callback = get_logical_from_array , found = found ) contains ! callback function for logical subroutine get_logical_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_logical_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_logical_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_logical_vec_with_path ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]]. subroutine json_get_string ( me , value ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value character ( kind = CK , len = :), allocatable :: s , pre , post integer ( IK ) :: j , jprev , n character ( kind = CK , len = 1 ) :: c value = '' if ( exception_thrown ) return select case ( me % var_type ) case ( json_string ) if ( allocated ( me % str_value )) then !get the value as is: s = me % str_value ! Now, have to remove the escape characters: ! ! '\\\"'        quotation mark ! '\\\\'        reverse solidus ! '\\/'        solidus ! '\\b'        backspace ! '\\f'        formfeed ! '\\n'        newline (LF) ! '\\r'        carriage return (CR) ! '\\t'        horizontal tab ! '\\uXXXX'    4 hexadecimal digits ! !initialize: n = len ( s ) j = 1 do jprev = j !initialize j = index ( s ( j : n ), backslash ) !look for an escape character if ( j > 0 ) then !an escape character was found !index in full string of the escape character: j = j + ( jprev - 1 ) if ( j < n ) then !save the bit before the escape character: if ( j > 1 ) then pre = s ( 1 : j - 1 ) else pre = '' end if !character after the escape character: c = s ( j + 1 : j + 1 ) if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then !save the bit after the escape characters: if ( j + 2 < n ) then post = s ( j + 2 : n ) else post = '' end if select case ( c ) case ( quotation_mark , backslash , slash ) !use c as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select s = pre // c // post n = n - 1 !backslash character has been ! removed from the string else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just printing them as is ![not checking to see if it is a valid hex value] if ( j + 5 <= n ) then j = j + 4 else call throw_exception ( 'Error in json_get_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // trim ( c )) exit end if else !unknown escape character call throw_exception ( 'Error in json_get_string:' // & ' unknown escape sequence in string \"' // & trim ( s ) // '\" [' // backslash // c // ']' ) exit end if j = j + 1 !go to the next character if ( j >= n ) exit !finished else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] exit end if else exit !no more escape characters in the string end if end do if ( exception_thrown ) then if ( allocated ( value )) deallocate ( value ) else value = s end if else call throw_exception ( 'Error in json_get_string:' // & ' me%value not allocated' ) end if case default call throw_exception ( 'Error in json_get_string:' // & ' Unable to resolve value to characters: ' // me % name ) ! Note: for the other cases, we could do val to string conversions. end select !cleanup: if ( allocated ( s )) deallocate ( s ) if ( allocated ( pre )) deallocate ( pre ) if ( allocated ( post )) deallocate ( post ) end subroutine json_get_string !***************************************************************************************** !***************************************************************************************** !> !  Get a character string from a [[json_value]], given the path. subroutine json_get_string_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = '' if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_string:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_string ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json_clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_string_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_with_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 5/14/2014 ! !  Get a string vector from a [[json_file(type)]]. subroutine json_get_string_vec ( me , vec ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_chars_from_array ) contains ! callback function for chars subroutine get_chars_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec !***************************************************************************************** !***************************************************************************************** !> !  Get a string vector from a [[json_file(type)]], given the path. subroutine json_get_string_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , path = path , array_callback = get_chars_from_array , found = found ) contains ! callback function for chars subroutine get_chars_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_string_vec_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_string_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_string_vec_with_path ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_with_path !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied [[array_callback_func]] subroutine !      for each element in the array. ! !@note For integer, double, logical, and character arrays, !      higher-level routines are provided (see [[json_get]]), so !      this routine does not have to be used for those cases. subroutine json_get_array ( me , array_callback ) implicit none type ( json_value ), pointer , intent ( in ) :: me procedure ( array_callback_func ) :: array_callback type ( json_value ), pointer :: element integer ( IK ) :: i , count if ( exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json_count ( me ) element => me % children do i = 1 , count ! callback for each child call array_callback ( element , i , count ) element => element % next end do case default call throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 09/02/2015 ! !  Traverse a JSON structure. !  This routine calls the user-specified [[traverse_callback_func]] !  for each element of the structure. ! recursive subroutine json_traverse ( me , traverse_callback ) implicit none type ( json_value ), pointer , intent ( in ) :: me procedure ( traverse_callback_func ) :: traverse_callback type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children logical ( LK ) :: finished !! can be used to stop the process if ( exception_thrown ) return call traverse_callback ( me , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( me % var_type == json_array . or . me % var_type == json_object ) then icount = json_count ( me ) ! number of children if ( icount > 0 ) then element => me % children ! first one do i = 1 , icount ! call for each child call json_traverse ( element , traverse_callback ) if ( finished ) exit element => element % next end do end if nullify ( element ) end if end subroutine json_traverse !***************************************************************************************** !***************************************************************************************** !> !  This routine calls the user-supplied array_callback subroutine !  for each element in the array (specified by the path). subroutine json_get_array_with_path ( me , path , array_callback , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_array ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found ) ) then found = . false . call json_clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_with_path !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_get_array_with_path]], where \"path\" is kind=CDK subroutine wrap_json_get_array_with_path ( me , path , array_callback , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json_get_array_with_path ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_with_path !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON file and populate the [[json_value]] tree. ! !# Inputs ! !  The inputs can be: ! !  * file and unit : the specified unit is used to read JSON from file. !                    [note if unit is already open, then the filename is ignored] !  * file          : JSON is read from file using internal unit number ! !# Example ! !```fortran !    type(json_value),pointer :: p !    call json_parse(file='myfile.json', p=p) !``` ! !# History !  * Jacob Williams : 01/13/2015 : added read from string option. !  * Izaak Beekman  : 03/08/2015 : moved read from string to separate !    subroutine, and error annotation !    to separate subroutine. ! !@note When calling this routine, any exceptions thrown from previous !      calls will automatically be cleared. subroutine json_parse_file ( file , p , unit ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit , istat logical ( LK ) :: is_open !clear any exceptions and initialize: call json_initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call parse_value ( unit = iunit , str = CK_ '' , value = p ) if ( exception_thrown ) call annotate_invalid_json ( iunit , CK_ '' ) ! close the file if necessary close ( unit = iunit , iostat = istat ) else call throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file !***************************************************************************************** !***************************************************************************************** !> !  Parse the JSON string and populate the [[json_value]] tree. ! !# See also !  * [[json_parse_file]] subroutine json_parse_string ( p , str ) implicit none type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !indicates that json data will be read from buffer if ( . not . exception_thrown ) then !clear any exceptions and initialize: call json_initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = '' ! parse as a value call parse_value ( unit = iunit , str = str , value = p ) if ( exception_thrown ) call annotate_invalid_json ( iunit , str ) end if end subroutine json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Alternate version of [[json_parse_string]], where \"str\" is kind=CDK. subroutine wrap_json_parse_string ( p , str ) implicit none type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json_parse_string ( p , to_unicode ( str )) end subroutine wrap_json_parse_string !***************************************************************************************** !***************************************************************************************** !> !  Generate a warning message if there was an error parsing a JSON !  file or string. subroutine annotate_invalid_json ( iunit , str ) implicit none integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl ! !  If there was an error reading the file, then !   print the line where the error occurred: ! if ( exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( line_count , line_str ) call integer_to_string ( char_count , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , char_count - 1 ) ) // '&#94;' if ( line_count > 0 . and . char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call get_current_line_from_file_stream ( iunit , line ) else call get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = '' end if !create the error message: err_message = err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the SEQUENTIAL version (see also [[get_current_line_from_file_stream]]). subroutine get_current_line_from_file_sequential ( iunit , line ) implicit none integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ), parameter :: n_chunk = 256 ! chunk size [arbitrary] character ( kind = CDK , len =* ), parameter :: nfmt = '(A256)' ! corresponding format statement character ( kind = CK , len = n_chunk ) :: chunk integer ( IK ) :: istat , isize !initialize: line = '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = nfmt , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= n_chunk ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Rewind the file to the beginning of the current line, and return this line. !  The file is assumed to be opened. !  This is the STREAM version (see also [[get_current_line_from_file_sequential]]). subroutine get_current_line_from_file_stream ( iunit , line ) implicit none integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c !updated for the new STREAM version: istart = ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_value ( unit , str , value ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = :), allocatable :: tmp !this is a work-around for a bug ! in the gfortran 4.9 compiler. if (. not . exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call to_object ( value ) !allocate class call parse_object ( unit , str , value ) case ( start_array ) ! start array call to_array ( value ) !allocate class call parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) call parse_string ( unit , str , tmp ) !write to a tmp variable because of value % str_value = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) ! end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . exception_thrown ) call to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . exception_thrown ) call to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . exception_thrown ) call to_null ( value ) !allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call push_char ( c ) call parse_number ( unit , str , value ) case default call throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a logical(LK) variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'value',.true.) !``` subroutine json_value_create_logical ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! variable name logical ( LK ), intent ( in ) :: val !! variable value call json_value_create ( me ) call to_logical ( me , val , name ) end subroutine json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrapper for [[json_value_create_logical]] so [[json_create_logical]] can !  be called with name of character kind 'DEFAULT' or 'ISO_10646' subroutine wrap_json_value_create_logical ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val call json_value_create_logical ( me , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an integer(IK) variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'value',1) !``` subroutine json_value_create_integer ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create ( me ) call to_integer ( me , val , name ) end subroutine json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper procedure for [[json_value_create_integer]] so that [[json_create_integer]] !  may be called with either a 'DEFAULT' or 'ISO_10646' character kind 'name' !  actual argument. subroutine wrap_json_value_create_integer ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create_integer ( me , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it a real(RK) variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'value',1.0d0) !``` subroutine json_value_create_double ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create ( me ) call to_double ( me , val , name ) end subroutine json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_double]] so that [[json_create_double]] may be !  called with an actual argument corresponding to the dummy argument, 'name' !  that may be of 'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_double ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create_double ( me , val , to_unicode ( name )) end subroutine wrap_json_value_create_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a string variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'value','hello') !``` subroutine json_value_create_string ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val call json_value_create ( me ) call to_string ( me , val , name ) end subroutine json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_string]] so that [[json_create_string]] may be called with actual !  character string arguments for 'name' and 'val' that are BOTH of 'DEFAULT' or !  'ISO_10646' character kind. subroutine wrap_json_value_create_string ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val call json_value_create_string ( me , to_unicode ( val ), to_unicode ( name )) end subroutine wrap_json_value_create_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a json_value pointer and make it a null variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'value') !``` subroutine json_value_create_null ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( me ) call to_null ( me , name ) end subroutine json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_null]] so that [[json_create_null]] may be called with an actual !  argument corresponding to the dummy argument 'name' that is either of 'DEFAULT' or !  'ISO_10646' character kind. subroutine wrap_json_value_create_null ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_create_null ( me , to_unicode ( name )) end subroutine wrap_json_value_create_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an object variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'objectname') !``` ! !@note The name is not significant for the root structure or an array element. !      In those cases, an empty string can be used. subroutine json_value_create_object ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( me ) call to_object ( me , name ) end subroutine json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Wrap [[json_value_create_object]] so that [[json_create_object]] may be called with an actual !  argument corresponding to the dummy argument 'name' that is of either 'DEFAULT' or !  'ISO_10646' character kind. subroutine wrap_json_value_create_object ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_create_object ( me , to_unicode ( name )) end subroutine wrap_json_value_create_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Allocate a [[json_value]] pointer and make it an array variable. !  The pointer should not already be allocated. ! !# Example !```fortran !     type(json_value),pointer :: p !     call json_create(p,'arrayname') !``` subroutine json_value_create_array ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( me ) call to_array ( me , name ) end subroutine json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  A wrapper for [[json_value_create_array]] so that [[json_create_array]] may be called with !  an actual argument, corresponding to the dummy argument 'name', that is either of !  'DEFAULT' or 'ISO_10646' character kind. subroutine wrap_json_value_create_array ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_create_array ( me , to_unicode ( name )) end subroutine wrap_json_value_create_array !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a logical. subroutine to_logical ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_logical allocate ( me % log_value ) if ( present ( val )) then me % log_value = val else me % log_value = . false . !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_logical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an integer. subroutine to_integer ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_integer allocate ( me % int_value ) if ( present ( val )) then me % int_value = val else me % int_value = 0 !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_integer !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a double. subroutine to_double ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me real ( RK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_double allocate ( me % dbl_value ) if ( present ( val )) then me % dbl_value = val else me % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_double !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a string. ! !# Modified !  * Izaak Beekman : 02/24/2015 ! subroutine to_string ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_string if ( present ( val )) then me % str_value = val else me % str_value = '' !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to a null. subroutine to_null ( me , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_null !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_null !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an object. subroutine to_object ( me , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_object !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_object !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Change the [[json_value]] variable to an array. subroutine to_array ( me , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_array !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_array !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_object ( unit , str , parent ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. if (. not . exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) call parse_string ( unit , str , tmp ) !write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) if ( exception_thrown ) then call json_destroy ( pair ) return end if else call throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call parse_value ( unit , str , pair ) if ( exception_thrown ) then call json_destroy ( pair ) return else call json_add ( parent , pair ) end if else call throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. recursive subroutine parse_array ( unit , str , array ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call parse_value ( unit , str , element ) if ( exception_thrown ) then if ( associated ( element )) call json_destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json_add ( array , element ) ! popped the next character c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then ! The file ended before array was finished: call throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array !***************************************************************************************** !***************************************************************************************** !> !  Parses a string while reading a JSON file. ! !# History !  * Jacob Williams : 6/16/2014 : Added hex validation. subroutine parse_string ( unit , str , string ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c , last character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . exception_thrown ) then !initialize: ip = 1 last = space is_hex = . false . escape = . false . i = 0 do !get the next character from the file: c = pop_char ( unit , str = str , eof = eof , skip_ws = . false .) if ( eof ) then call throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . last /= backslash ) then if ( is_hex ) call throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = '' is_hex = . false . else call throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if !update for next char: last = c end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = '' else string = string ( 1 : ip - 1 ) end if end if end if end subroutine parse_string !***************************************************************************************** !***************************************************************************************** !> !  Core parsing routine. subroutine parse_for_chars ( unit , str , chars ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . exception_thrown ) then length = len_trim ( chars ) do i = 1 , length c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing array.' ) return else if ( c /= chars ( i : i )) then call throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character.: \"' // c // '\" ' // chars ( i : i )) return end if end do end if end subroutine parse_for_chars !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/20/2014 ! !  Read a numerical value from the file (or string). !  The routine will determine if it is an integer or a double, and !  allocate the type accordingly. ! !@note Complete rewrite of the original FSON routine, which had some problems. subroutine parse_number ( unit , str , value ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer !to speed up by reducing the number of character string reallocations: integer ( IK ) :: ip !index to put next character if (. not . exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call push_char ( c ) !string to value: if ( is_integer ) then ival = string_to_integer ( tmp ) call to_integer ( value , ival ) else rval = string_to_double ( tmp ) call to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number !***************************************************************************************** !***************************************************************************************** !> !  Get the next character from the file (or string). ! !# See also !  * [[push_char]] ! !@note This routine ignores non-printing ASCII characters (iachar<=31) that are in strings. recursive function pop_char ( unit , str , eof , skip_ws ) result ( popped ) implicit none character ( kind = CK , len = 1 ) :: popped !! the popped character. integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) -- only used if unit=0 logical ( LK ), intent ( out ) :: eof !! true if the end of the file has been reached. logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace. integer ( IK ) :: ios , str_len character ( kind = CK , len = 1 ) :: c logical ( LK ) :: ignore if (. not . exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if do if ( pushed_index > 0 ) then ! there is a character pushed back on, most likely from the number parsing ! NOTE: this can only occur if reading from a file when use_unformatted_stream=.false. c = pushed_char ( pushed_index : pushed_index ) pushed_index = pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if ipos = ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( ipos <= str_len ) then c = str ( ipos : ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if ipos = ipos + 1 end if char_count = char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file char_count = 0 eof = . true . exit elseif ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record char_count = 0 line_count = line_count + 1 cycle end if end if if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then cycle else popped = c exit end if end do end if end function pop_char !***************************************************************************************** !***************************************************************************************** !> !  Core routine. ! !# See also !  * [[pop_char]] ! !# History !  * Jacob Williams : 5/3/2015 : replaced original version of this routine. subroutine push_char ( c ) implicit none character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = max_numeric_str_len ) :: istr if (. not . exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: ipos = ipos - 1 else pushed_index = pushed_index + 1 if ( pushed_index > 0 . and . pushed_index <= len ( pushed_char )) then pushed_char ( pushed_index : pushed_index ) = c else call integer_to_string ( pushed_index , istr ) call throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if end if end subroutine push_char !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert an integer to a string. pure subroutine integer_to_string ( ival , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CK , len =* ), intent ( out ) :: str !! ival converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 12/4/2013 ! !  Convert a real value to a string. ! !# Modified !  * Izaak Beekman : 02/24/2015 : added the compact option. subroutine real_to_string ( rval , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CK , len =* ), intent ( out ) :: str !! rval converted to a string. integer ( IK ) :: istat !default format: write ( str , fmt = real_fmt , iostat = istat ) rval if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman !  date: 02/24/2015 ! !  Compact a string representing a real number, so that !  the same value is displayed with fewer characters. ! !# See also !  * [[real_to_string]] subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand , expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start , decimal_pos , sig_trim , exp_trim , i str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:6/14/2014 ! !  Returns true if the string is a valid 4-digit hex string. ! !# Examples !```fortran !    valid_json_hex('0000')  !returns true !    valid_json_hex('ABC4')  !returns true !    valid_json_hex('AB')    !returns false (< 4 characters) !    valid_json_hex('WXYZ')  !returns false (invalid characters) !``` pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n , i !an array of the valid hex characters: character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert string to unicode (CDK to CK). pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  Convert array of strings to unicode (CDK to CK). ! !@note JW: may be able to remove this by making [[to_uni]] PURE ELEMENTAL ? pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  CK//CDK operator. function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  CDK//CK operator. function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  CK==CDK operator. function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default !***************************************************************************************** !***************************************************************************************** !> author: Izaak Beekman ! !  CDK==CK operator. function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4 !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Print any error message, and then clear the exceptions. ! !@note This routine is used by the unit tests. !      It was originally in json_example.f90, and was !      moved here 2/26/2015 by Izaak Beekman. subroutine json_print_error_message ( io_unit ) implicit none integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg logical :: status_ok !get error message: call json_check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( * , '(A)' ) error_msg end if deallocate ( error_msg ) call json_clear_exceptions () end if end subroutine json_print_error_message !***************************************************************************************** !***************************************************************************************** end module json_module !*****************************************************************************************","tags":"","loc":"sourcefile/json_module.f90.html","title":"json_module.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the first unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_1_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename1 = 'test1.json' contains subroutine test_1 ( error_cnt ) !! Read a sample JSON file and retrieve some data from it implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval logical :: found type ( json_value ), pointer :: p error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 1' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file ' // dir // filename1 call json % load_file ( filename = dir // filename1 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the file...' write ( output_unit , '(A)' ) '{ \"part a\" :' !Wrap 3 outputs to make stdout valid json call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'get some data from the file...' write ( error_unit , '(A)' ) '' call json % get ( 'version.svn' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,I5)' ) 'version.svn = ' , ival end if write ( error_unit , '(A)' ) '' call json % get ( 'data(1).array(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'data(1).array(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(1)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(1) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(3)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(3) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'data(2).real' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,E30.16)' ) 'data(2).real = ' , rval end if write ( error_unit , '(A)' ) '' call json % get ( 'files[4]' , cval ) !has hex characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[4] = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files[5]' , cval ) !string with spaces and no escape characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[5] = ' // trim ( cval ) end if ! ! Test of values that aren't there: ! Note: when using the \"found\" output, the exceptions are cleared automatically. ! write ( error_unit , '(A)' ) '' call json % get ( 'files[10]' , cval , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'files[10] not in file.' else write ( error_unit , '(1x,A)' ) 'files[10] = ' // trim ( cval ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' call json % get ( 'version.blah' , ival , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'version.blah not in file.' else write ( error_unit , '(A)' ) 'version.blah = ' , ival error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test removing data from the json structure:' call json % get ( 'files' , p ) !in the middle of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(1).array' , p ) !at the end of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(2).number' , p ) !at the beginning of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part b\" : ' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test replacing data from the json structure:' call json % get ( 'data(1)' , p ) call json_update ( p , 'name' , 'Cuthbert' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !call json%get('data(2)', p) !call json_update(p,'real',[1.0_wp, 2.0_wp, 3.0_wp],found)   !don't have one like this yet... !use the json_file procedure to update a variable: call json % update ( 'version.svn' , 999 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part c\" : ' call json % print_file () write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_1 end module jf_test_1_mod !***************************************************************************************** !***************************************************************************************** program jf_test_1 !! First unit test. use jf_test_1_mod , only : test_1 implicit none integer :: n_errors n_errors = 0 call test_1 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_1 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_1.f90.html","title":"jf_test_1.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 3/10/2015 ! ! Module for the tenth unit test. module jf_test_10_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: filename = 'test1.json' character ( len =* ), parameter :: dir = '../files/inputs/' !working directory contains subroutine test_10 ( error_cnt ) !! Test some of the lesser-used features of the library implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = 256 ), dimension (:), allocatable :: str_vec type ( json_file ) :: f , f2 type ( json_value ), pointer :: p character ( kind = CK , len = :), allocatable :: str , name logical :: found , lval integer :: var_type , n_children character ( kind = CDK , len =* ), parameter :: json_str = '{ \"blah\": 123 }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 10 ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) // '...' call f % load_file ( dir // filename ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_move_pointer...' call f2 % move ( f ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_load_from_string...' call f % load_from_string ( json_str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_print_to_string...' call f % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_variable_info...' call f % info ( 'blah' , found , var_type , n_children ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( var_type == json_integer . and . n_children == 0 ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error invalid values:' , var_type , n_children error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_get_logical...' call f2 % get ( 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . lval ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result.' error_cnt = error_cnt + 1 end if end if ! json_file_get_logical_vec .... [add this] write ( error_unit , '(A)' ) 'json_file_get_string_vec...' call f2 % get ( 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable present]...' call f2 % update ( 'data(1).tf1' ,. false ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable not present]...' call f2 % update ( 'new_logical' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_real [variable present]...' call f2 % update ( 'data[2].real' , 10 0.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_real [variable not present]...' call f2 % update ( 'new_real' , 177 6.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_string [variable present]...' call f2 % update ( 'version.string' , '10.0.0' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_string [variable not present]...' call f2 % update ( 'new_string' , 'foo' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_get_integer...' call f2 % get ( '$' , p , found ) !get root if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' write ( error_unit , '(A)' ) 'json_info...' call json_info ( p , var_type , n_children , name ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_remove_if_present...' call json_remove_if_present ( p , 'version.patch' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_logical...' call json_update ( p , 'data(1).tf1' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_double...' call json_update ( p , 'data(2).real' , - 1.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_logical...' call json_get ( p , 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_string_vec...' call json_get ( p , 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_create...' write ( error_unit , '(A)' ) 'json_create_logical...' ; call json_destroy ( p ); call json_create_logical ( p ,. true ., 'foo' ) write ( error_unit , '(A)' ) 'json_create_integer...' ; call json_destroy ( p ); call json_create_integer ( p , 1000 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_double ...' ; call json_destroy ( p ); call json_create_double ( p , 9.0 d0 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_string ...' ; call json_destroy ( p ); call json_create_string ( p , 'foo' , 'bar' ) write ( error_unit , '(A)' ) 'json_create_null   ...' ; call json_destroy ( p ); call json_create_null ( p , 'foo' ) write ( error_unit , '(A)' ) 'json_create_object ...' ; call json_destroy ( p ); call json_create_object ( p , 'foo' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- !cleanup: !call f%destroy()   !WARNING: causing \"pointer being freed was not allocated\" errors.... need to investigate !call f2%destroy() end subroutine test_10 end module jf_test_10_mod !***************************************************************************************** !***************************************************************************************** program jf_test_10 !! Tenth unit test. use jf_test_10_mod , only : test_10 implicit none integer :: n_errors n_errors = 0 call test_10 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_10 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_10.f90.html","title":"jf_test_10.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Izaak Beekman !  date: 3/13/2015 ! ! Module for the 11th unit test to test unicode support if enabled. module jf_test_11_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory # ifdef USE_UCS4 character ( len =* ), parameter :: unicode_file = 'hello-world-ucs4.json' #endif character ( len =* ), parameter :: ascii_equivalent = 'hello-world-ascii.json' contains subroutine test_11 ( error_cnt ) !! Read the file and extract some data from it. implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = :), allocatable :: cval type ( json_file ) :: json !the JSON structure read from the file: # ifdef USE_UCS4 type ( json_file ) :: clone # endif error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 11' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' # ifdef USE_UCS4 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // unicode_file call json % load_file ( filename = dir // unicode_file ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' call clone % load_from_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call clone % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // unicode_file // '\"' call clone % print_file ( '../files/' // unicode_file ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call clone % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if # endif ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // ascii_equivalent write ( error_unit , '(A)' ) 'This is the ascii equivalent of \"../files/inputs/hello-world-ucs4.json\"' call json % load_file ( filename = dir // ascii_equivalent ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call json % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // ascii_equivalent // '\"' call json % print_file ( '../files/' // ascii_equivalent ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_11 end module jf_test_11_mod !***************************************************************************************** !***************************************************************************************** program jf_test_11 !! 11th unit test. use jf_test_11_mod , only : test_11 implicit none integer :: n_errors n_errors = 0 call test_11 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_11 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_11.f90.html","title":"jf_test_11.F90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Izaak Beekman !  date: 07/27/2015 ! ! Module for the 12th unit test. module jf_test_12_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! Path to write JSON file to character ( len =* ), parameter :: file = 'test12.json' !! Filename to write real ( wp ), parameter :: TOL = 100 * epsilon ( 1.0_wp ) !! Tolerance for real comparisons contains subroutine test_12 ( error_cnt ) implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller integer , parameter :: imx = 5 , jmx = 3 , kmx = 4 !! dimensions for raw work array of primitive type integer , dimension ( 3 ) :: shape !! shape of work array integer , dimension (:), allocatable :: fetched_shape !! retrieved shape type ( json_value ), pointer :: root , meta_array !! json nodes to work with type ( json_value ), pointer :: tmp_json_ptr type ( json_file ) :: my_file real ( wp ), dimension ( imx , jmx , kmx ) :: raw_array !! raw work array real ( wp ) :: array_element real ( wp ), dimension (:), allocatable :: fetched_array character ( kind = CK , len = :), allocatable :: description integer :: i , j , k !! loop indices integer :: array_length , lun logical :: existed logical , dimension (:), allocatable :: SOS error_cnt = 0 call json_initialize ( verbose = . true ., real_format = 'G' ) call check_errors () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 12' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! populate the raw array forall ( i = 1 : imx , j = 1 : jmx , k = 1 : kmx ) ! could use size(... , dim=...) instead of constants raw_array ( i , j , k ) = i + ( j - 1 ) * imx + ( k - 1 ) * imx * jmx end forall call json_create_object ( root , dir // file ) call check_errors () call json_create_object ( meta_array , 'array data' ) call check_errors () shape = [ size ( raw_array , dim = 1 ), size ( raw_array , dim = 2 ), size ( raw_array , dim = 3 )] call json_add ( meta_array , 'shape' , shape ) call check_errors () call json_add ( meta_array , 'total size' , size ( raw_array )) call check_errors () call json_update ( meta_array , 'total size' , size ( raw_array ), found = existed ) call check_errors ( existed ) call json_add ( meta_array , CK_ 'description' , 'test data' ) call check_errors () ! now add the array ! N.B. `json_add()` only accepts 1-D arrays and scalars, so transform with `reshape` ! N.B. reshape populates new array in \"array element order\". ! C.F. \"Modern Fortran Explained\", by Metcalf, Cohen and Reid, p. 24. ! N.B. Fortran is a column major language call json_add ( meta_array , 'data' , reshape ( raw_array , [ size ( raw_array ) ] ) ) call check_errors () ! now put it all together call json_add ( root , meta_array ) call check_errors () write ( error_unit , '(A)' ) \"Print the JSON object to stderr:\" call json_print ( root , error_unit ) call check_errors () call json_get ( root , '$.array data.data(1)' , array_element ) call check_errors ( abs ( array_element - 1.0_wp ) <= TOL ) call json_get ( root , '@.array data.shape' , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_update ( meta_array , 'description' , CK_ 'Test Data' , found = existed ) call check_errors ( existed ) call json_update ( meta_array , CK_ 'description' , 'Test data' , found = existed ) call check_errors ( existed ) call json_get ( meta_array , 'description' , description ) call check_errors ( 'Test data' == description ) call json_get ( root , 'array data.total size' , array_length ) call check_errors ( array_length == imx * jmx * kmx ) sos = [. true ., . true ., . true ., & . false ., . false ., . false ., & . true ., . true ., . true .] call json_add ( root , 'SOS' , sos ) call check_errors () call json_get ( root , 'SOS' , sos ) call check_errors () call json_add ( root , 'vector string' , [ CK_ 'only one value' ]) call check_errors () call json_add ( root , CK_ 'page' , [ 'The quick brown fox     ' , 'jumps over the lazy dog.' ]) call check_errors () call json_get ( root , 'SOS' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , sos ) call check_errors () call json_get ( meta_array , 'shape' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_get ( meta_array , 'data' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call json_get ( root , 'array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) raw_array = 0 call json_get ( me = root , path = 'array data.data' , array_callback = get_3D_from_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) my_file = json_file ( root ) call my_file % update ( 'array data.description' , CK_ 'vector data' , found = existed ) call check_errors ( existed ) call my_file % update ( CK_ 'array data.description' , 'Vector data' , found = existed ) call check_errors ( existed ) call my_file % get ( 'SOS' , sos ) call check_errors () call my_file % get ( '$array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call my_file % get ( tmp_json_ptr ) call check_errors ( associated ( tmp_json_ptr , root )) open ( file = dir // file , newunit = lun , form = 'formatted' , action = 'write' ) call my_file % print_file ( lun ) call check_errors () close ( lun ) contains subroutine check_errors ( assertion ) logical , optional , intent ( in ) :: assertion if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( present ( assertion )) then if (. not . assertion ) error_cnt = error_cnt + 1 end if end subroutine check_errors subroutine get_3D_from_array ( element , i , count ) type ( json_value ), pointer , intent ( in ) :: element integer , intent ( in ) :: i !!index integer , intent ( in ) :: count !!size of array integer :: useless !! assign count to this to silence warnings ! let's pretend we're c programmers! call json_get ( element , raw_array ( & mod ( i - 1 , imx ) + 1 , & ! i index mod (( i - 1 ) / imx , jmx ) + 1 , & ! j index mod (( i - 1 ) / imx / jmx , kmx ) + 1 ) ) ! k inded useless = count end subroutine get_3D_from_array end subroutine test_12 end module jf_test_12_mod !***************************************************************************************** !***************************************************************************************** program jf_test_12 !! 12th unit test. use jf_test_12_mod , only : test_12 implicit none integer :: n_errors n_errors = 0 call test_12 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_12 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_12.f90.html","title":"jf_test_12.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 09/01/2015 ! ! Module for the 13th unit test. module jf_test_13_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none contains subroutine test_13 ( error_cnt ) !! Tests different real format strings using repeated calls to [[json_initialize]]. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_file ) :: my_file character ( kind = CK , len = :), allocatable :: str integer :: i character ( len = 2 ), dimension ( 4 ), parameter :: fmts = [ 'g ' , 'e ' , 'en' , 'es' ] !! format statements to test write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 13' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 do i = 1 , size ( fmts ) call json_initialize ( real_format = trim ( fmts ( i ))) call my_file % load_from_string ( '{ \"value\": 1234.56789 }' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call my_file % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( output_unit , '(A)' ) str end if call my_file % destroy () end do end subroutine test_13 end module jf_test_13_mod !***************************************************************************************** !***************************************************************************************** program jf_test_13 !! 13th unit test. use jf_test_13_mod , only : test_13 implicit none integer :: n_errors call test_13 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_13 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_13.f90.html","title":"jf_test_13.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 09/02/2015 ! ! Module for the 14th unit test. module jf_test_14_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename1 = 'test1.json' !! the file to read integer :: icount = 0 !! a count of the number of \"name\" variables found contains subroutine test_14 ( error_cnt ) !! Tests the traversal of a JSON structure !! !! It traverses the structure, looks for all \"name\" variables, and changes the name. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_value ), pointer :: json write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 14' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 icount = 0 !number of name changes (should be 2) call json_initialize () !initialize the module call json_parse ( dir // filename1 , json ) !read the file if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_traverse ( json , rename ) !traverse all nodes in the structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( icount /= 2 ) then write ( error_unit , '(A)' ) 'Error: should be 2 \"name\" variables in this file: ' // filename1 error_cnt = error_cnt + 1 end if if ( error_cnt == 0 ) then write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' All names changed to Fred:' write ( error_unit , '(A)' ) '' call json_print ( json , output_unit ) write ( error_unit , '(A)' ) '' end if call json_destroy ( json ) !clean up if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_14 subroutine rename ( p , finished ) !! change all \"name\" variable values to \"Fred\" implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( out ) :: finished integer :: var_type character ( kind = CK , len = :), allocatable :: str logical :: found !get info about this variable: call json_info ( p , var_type = var_type , name = str ) !it must be a string named \"name\": if ( var_type == json_string . and . str == 'name' ) then call json_get ( p , '@' , str ) ! get original name call json_update ( p , '@' , 'Fred' , found ) !change it write ( error_unit , '(A)' ) str // ' name changed' icount = icount + 1 end if !cleanup: if ( allocated ( str )) deallocate ( str ) !always false, since we want to traverse all nodes: finished = . false . end subroutine rename end module jf_test_14_mod !***************************************************************************************** !***************************************************************************************** program jf_test_14 !! 14th unit test. use jf_test_14_mod , only : test_14 implicit none integer :: n_errors call test_14 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_14 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_14.f90.html","title":"jf_test_14.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the second unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_2_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! working directory character ( len =* ), parameter :: filename2 = 'test2.json' contains subroutine test_2 ( error_cnt ) !! Populate a JSON structure and write it to a file. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp , traj integer :: iunit error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 2' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !root: call json_create_object ( p , dir // filename2 ) ! create the value and associate the pointer ! add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'initialize the structure...' !config structure: call json_create_object ( inp , 'inputs' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory structure: call json_create_array ( traj , 'trajectory' ) !an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , traj ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'adding some data to structure...' !add some variables: !input variables: call json_add ( inp , 't0' , 0.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'tf' , 1.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'x0' , 999 9.000_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_scalar' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_scalar' , . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) !trajectory variables: call add_variables_to_input ( traj , 'Rx' , 'km' , 'J2000' , 'EARTH' , [ 1.0_wp , 2.0_wp , 3.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Ry' , 'km' , 'J2000' , 'EARTH' , [ 1 0.0_wp , 2 0.0_wp , 3 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Rz' , 'km' , 'J2000' , 'EARTH' , [ 10 0.0_wp , 20 0.0 d0 , 30 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vx' , 'km/s' , 'J2000' , 'EARTH' , [ 1.0e-3_wp , 2.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vy' , 'km/s' , 'J2000' , 'EARTH' , [ 2.0e-3_wp , 2 0.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vz' , 'km/s' , 'J2000' , 'EARTH' , [ 3.0e-3_wp , 3 0.0e-3_wp , 4 0.0e-3_wp ], error_cnt ) nullify ( traj ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'writing file ' // trim ( dir // filename2 ) // '...' open ( newunit = iunit , file = dir // filename2 , status = 'REPLACE' ) call json_print ( p , iunit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if close ( iunit ) !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_2 subroutine add_variables_to_input ( me , variable , units , frame , center , rdata , error_cnt ) !Used by test_2. implicit none type ( json_value ), pointer :: me character ( len =* ), intent ( in ) :: variable , units , frame , center real ( wp ), dimension (:), intent ( in ) :: rdata integer , intent ( inout ) :: error_cnt type ( json_value ), pointer :: var !a variable in the trajectory: !initialize: nullify ( var ) !create the object before data can be added: call json_create_object ( var , '' ) !name does not matter if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !variable info: call json_add ( var , 'VARIABLE' , trim ( variable )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'UNITS' , trim ( units )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'FRAME' , trim ( frame )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'CENTER' , trim ( center )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory [vector of reals]: call json_add ( var , 'DATA' , rdata ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add this variable to trajectory structure: call json_add ( me , var ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !cleanup: nullify ( var ) end subroutine add_variables_to_input end module jf_test_2_mod !***************************************************************************************** !***************************************************************************************** program jf_test_2 !! Second unit test. use jf_test_2_mod , only : test_2 implicit none integer :: n_errors n_errors = 0 call test_2 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_2 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_2.f90.html","title":"jf_test_2.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the third unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_3_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !working directory character ( len =* ), parameter :: filename2 = 'test2.json' contains subroutine test_3 ( error_cnt ) !! Read the file generated in [[test_2]], and extract some data from it. implicit none integer , intent ( out ) :: error_cnt integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval type ( json_file ) :: json !the JSON structure read from the file: integer :: i character ( kind = CK , len = 10 ) :: str real ( wp ), dimension (:), allocatable :: rvec error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 3' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // filename2 call json % load_file ( filename = dir // filename2 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' !get scalars: write ( error_unit , '(A)' ) '' call json % get ( 'inputs.integer_scalar' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,I5)' ) 'inputs.integer_scalar = ' , ival end if !get one element from a vector: write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(1).DATA(2)' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,F30.16)' ) 'trajectory(1).DATA(2) = ' , rval end if !get vectors: do i = 1 , 4 write ( str , fmt = '(I10)' ) i str = adjustl ( str ) write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(' // trim ( str ) // ').VARIABLE' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'trajectory(' // trim ( str ) // ').VARIABLE = ' // trim ( cval ) !...get the vector using the callback method: call json % get ( 'trajectory(' // trim ( str ) // ').DATA' , rvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,*(F30.16,1X))' ) 'trajectory(' // trim ( str ) // ').DATA = ' , rvec end if end if end do end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_3 end module jf_test_3_mod !***************************************************************************************** !***************************************************************************************** program jf_test_3 !! Third unit test. use jf_test_3_mod , only : test_3 implicit none integer :: n_errors n_errors = 0 call test_3 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_3 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_3.f90.html","title":"jf_test_3.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the forth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_4_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/' !! working directory character ( len =* ), parameter :: filename4 = 'test4.json' contains subroutine test_4 ( error_cnt ) !! Populate a JSON structure, write it to a file, !! then read it. !! !! Also tests the json_value_to_string routine to write !! the file to a character string. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp type ( json_file ) :: json integer :: i character ( kind = CK , len = 10 ) :: istr character ( kind = CK , len = :), allocatable :: string error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 4' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'creating structure' call json_create_object ( p , dir // filename4 ) !create the value and associate the pointer !add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !config structure: call json_create_object ( inp , 'INPUTS' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add just integers: do i = 1 , 100 write ( istr , fmt = '(I10)' ) i istr = adjustl ( istr ) call json_add ( inp , 'x' // trim ( istr ), i ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to file' !write the file: call json_print ( p , trim ( dir // filename4 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to string' write ( error_unit , '(A)' ) '' !write it to a string, and print to console: call json_print_to_string ( p , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) string deallocate ( string ) !cleanup !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'read file' call json % load_file ( filename = dir // filename4 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'cleanup' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_4 end module jf_test_4_mod !***************************************************************************************** !***************************************************************************************** program jf_test_4 !! Fourth unit test. use jf_test_4_mod , only : test_4 implicit none integer :: n_errors n_errors = 0 call test_4 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_4 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_4.f90.html","title":"jf_test_4.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the fifth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_5_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory character ( len =* ), parameter :: filename5 = 'test5.json' contains subroutine test_5 ( error_cnt ) !! Github issue example: https://github.com/josephalevin/fson/issues/12 !! !! Read an existing file and extract some variables. implicit none integer , intent ( out ) :: error_cnt integer :: vv integer , dimension (:), allocatable :: vvv real ( wp ) :: d type ( json_file ) :: json logical :: found error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 5' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) 'load file...' call json % load_file ( filename = dir // filename5 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console: write ( error_unit , '(A)' ) 'print file...' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'extract data...' write ( error_unit , '(A)' ) '--------------------------' call json % get ( 'Correl.ID2' , vv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,I5)' ) 'vv = ' , vv call json % get ( 'Correl.ID1' , vvv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,*(I5,1X))' ) 'vvv= ' , vvv call json % get ( 'Prior[3].mode' , d , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,E30.16)' ) 'd  = ' , d write ( error_unit , '(A)' ) '' end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_5 end module jf_test_5_mod !***************************************************************************************** !***************************************************************************************** program jf_test_5 !! Fifth unit test. use jf_test_5_mod , only : test_5 implicit none integer :: n_errors n_errors = 0 call test_5 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_5 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_5.f90.html","title":"jf_test_5.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the sixth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_6_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none character ( len =* ), parameter :: dir = '../files/inputs/' !! working directory contains subroutine test_6 ( error_cnt ) !! This example tries to read an invalid JSON file. implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json integer :: i character ( len =* ), dimension ( 2 ), parameter :: files = [ 'invalid.json ' ,& 'invalid2.json' ] error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 6 : invalid JSON files' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' do i = 1 , 2 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'load file: ' // trim ( files ( i )) write ( error_unit , '(A)' ) '' call json % load_file ( filename = dir // trim ( files ( i ))) if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'An error should have been raised!' error_cnt = error_cnt + 1 end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do end subroutine test_6 end module jf_test_6_mod !***************************************************************************************** !***************************************************************************************** program jf_test_6 !! Sixth unit test. use jf_test_6_mod , only : test_6 implicit none integer :: n_errors n_errors = 0 call test_6 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_6 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_6.f90.html","title":"jf_test_6.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the seventh unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_7_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_7 ( error_cnt ) !! Indent test implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: root , a , b , c , d , e , e1 , e2 , escaped_string , p logical :: found character ( kind = CK , len = 1 ), dimension (:), allocatable :: strvec character ( kind = CK , len = :), allocatable :: string found = . false . error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 7 : indent test' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !----------------------- ! jsonlint indention is !----------------------- !{ !    \"a\": { !        \"ints\": [ !            1, !            2, !            3 !        ], !        \"chars\": [ !            \"a\", !            \"b\", !            \"c\" !        ] !    }, !    \"b\": { !        \"c\": { !            \"val1\": 1066 !        } !    }, !    \"d\": { !        \"val2\": 1815 !    }, !    \"array\": [ !        { !            \"int1\": 1 !        }, !        { !            \"int1\": 1, !            \"int2\": 2 !        } !    ] !    \"escaped string\": \"\\\\\\/\\b\\f\\n\\r\\t\" !} !create a json structure: call json_create_object ( root , 'root' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( a , 'a' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'ints' , [ 1 , 2 , 3 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( b , 'b' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'chars' , [ 'a' , 'b' , 'c' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get_child ( a , 'chars' , p ) call json_get ( p , strvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( c , 'c' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( c , 'val1' , 1066 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( d , 'd' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( d , 'val2' , 1815 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_array ( e , 'array' ) !objects in an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e1 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e1 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e2 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int2' , 2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , a ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , b ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( b , c ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , d ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , e ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'escaped string' ,& '\\/' // & achar ( 8 ) // & achar ( 12 ) // & achar ( 10 ) // & achar ( 13 ) // & achar ( 9 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'wacky string' ,[ 'trim   ' , '  and  ' , ' adjust' , '   left' ],& trim_str = . true ., adjustl_str = . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( a ) !don't need these anymore nullify ( b ) nullify ( c ) nullify ( d ) nullify ( e ) nullify ( e1 ) nullify ( e2 ) nullify ( escaped_string ) call json_print ( root , output_unit ) !print to the console if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! look for the 'escaped string' entry call json_get ( root , 'escaped string' , escaped_string , found ) if ( json_failed () . or . . not . found ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get ( escaped_string , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) \"Fetched unescaped 'escaped string': \" // string ! remove the escaped string entry if ( found ) call json_remove ( escaped_string , destroy = . true .) call json_print ( root , error_unit ) !print to stderr if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( root ) !cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_7 end module jf_test_7_mod !***************************************************************************************** !***************************************************************************************** program jf_test_7 !! Seventh unit test. use jf_test_7_mod , only : test_7 implicit none integer :: n_errors n_errors = 0 call test_7 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_7 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_7.f90.html","title":"jf_test_7.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> ! Module for the eighth unit test. ! !# HISTORY !  * Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) module jf_test_8_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none contains subroutine test_8 ( error_cnt ) !! read a JSON structure from a string implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p character ( len =* ), parameter :: newline = achar ( 10 ) character ( len =* ), parameter :: str = '{ \"label\": \"foo\",' // newline // ' \"value\": \"bar\" }' character ( len =* ), parameter :: str2 = '{ \"label\": \"foo\",' // newline // & '  \"value\": \"bar\",' // newline // & '  \"empty_array\": [],' // newline // & '  \"empty_object\": {}' // newline // & '}' character ( len =* ), parameter :: str_invalid = '{ \"label\": \"foo\",' // newline // ' \"value : \"bar\" }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 8 : read JSON from string' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 1:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '{ \"part a\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 2:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str2 , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part b\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Invalid test:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str_invalid , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'This should have failed!' error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part c\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_8 end module jf_test_8_mod !***************************************************************************************** !***************************************************************************************** program jf_test_8 !! Eighth unit test. use jf_test_8_mod , only : test_8 implicit none integer :: n_errors n_errors = 0 call test_8 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_8 !***************************************************************************************** !*******************************************************************************************************","tags":"","loc":"sourcefile/jf_test_8.f90.html","title":"jf_test_8.f90 â€“ JSON-Fortran"},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 3/2/2015 ! ! Module for the ninth unit test. module jf_test_9_mod use json_module use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none !small file - 0.0 sec : http://www.json-generator.com !character(len=*),parameter :: filename = 'random1.json' !7 MB - 5.4 sec : http://www.json-generator.com character ( len =* ), parameter :: filename = 'big.json' !13 MB - 7.6 sec : http://mtgjson.com !character(len=*),parameter :: filename = 'AllSets.json' !....WARNING: this file is causing some error.... (bug in code?) !100 MB - takes forever... : https://github.com/seductiveapps/largeJSON !character(len=*),parameter :: filename = '100mb.json' !small file that contains unicode characters: !character(len=*),parameter :: filename = 'hello-world-ucs4.json'  !!!! test !!!! character ( len =* ), parameter :: dir = '../files/inputs/' !working directory contains subroutine test_9 ( error_cnt ) !! Open a random JSON file generated by http://www.json-generator.com implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: f real :: tstart , tend character ( len = :), allocatable :: str error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9a ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_file' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call f % load_file ( dir // filename ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !cleanup: call f % destroy () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9b ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_from_string' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call read_file ( dir // filename , str ) if ( allocated ( str )) then call f % load_from_string ( str ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time to parse: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !write(error_unit,'(A)') str   !!!! test !!!! !write(error_unit,'(A)') ''    !!!! test !!!! else write ( error_unit , '(A)' ) 'Error loading file' end if !cleanup: call f % destroy () end subroutine test_9 subroutine read_file ( filename , str ) !! Reads the contents of the file into the allocatable string str. !! If there are any problems, str will be returned unallocated. !! !!@warning Will this routine work if the file contains unicode characters?? implicit none character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable , intent ( out ) :: str integer :: iunit , istat , filesize open ( newunit = iunit ,& file = filename ,& status = 'OLD' ,& form = 'UNFORMATTED' ,& access = 'STREAM' ,& iostat = istat ) if ( istat == 0 ) then inquire ( file = filename , size = filesize ) if ( filesize > 0 ) then allocate ( character ( len = filesize ) :: str ) read ( iunit , pos = 1 , iostat = istat ) str if ( istat /= 0 ) deallocate ( str ) close ( iunit , iostat = istat ) end if end if end subroutine read_file end module jf_test_9_mod !***************************************************************************************** !***************************************************************************************** program jf_test_9 !! Ninth unit test. use jf_test_9_mod , only : test_9 implicit none integer :: n_errors n_errors = 0 call test_9 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_9 !*****************************************************************************************","tags":"","loc":"sourcefile/jf_test_9.f90.html","title":"jf_test_9.f90 â€“ JSON-Fortran"},{"text":"Source Code !******************************************************************************************************* !> author: Izaak Beekman ! ! This program is run when configuring the json-fortran build, ! to determine whether or not ISO 10646/UCS4 characters are ! supported by the compiler. program test_iso_10646_support use iso_fortran_env , only : output_unit , error_unit implicit none integer , parameter :: UCS4_K = selected_char_kind ( 'ISO_10646' ) if ( UCS4_K == - 1 ) then !Not supported! write ( error_unit , '(A)' ) 'Your compiler does not support ISO 10646/UCS4 characters!' write ( error_unit , '(A)' ) 'JSON-Fortran must/will be configured to use the \"DEFAULT\"' write ( error_unit , '(A)' ) 'character set. (Should be \"ASCII\" on a reasonable system.)' stop 2 else write ( error_unit , '(A)' ) 'Congratulations! Your compiler supports ISO 10646/UCS4!' write ( error_unit , '(A)' ) 'JSON-Fortran may be configured to enable UCS4 support.' write ( output_unit , '(A)' ) 'UCS4_SUPPORTED' end if end program test_iso_10646_support !*******************************************************************************************************","tags":"","loc":"sourcefile/test_iso_10646_support.f90.html","title":"test_iso_10646_support.f90 â€“ JSON-Fortran"},{"text":"Type used to construct the linked-list JSON structure.\n  Normally, this should always be a pointer variable. Example The following test program: program test use json_module implicit none type ( json_value ), pointer :: p call json_initialize () !initialize the module call json_create_object ( p , '' ) !create the root call json_add ( p , 'year' , 1805 ) !add some data call json_add ( p , 'value' , 1.0 d0 ) !add some data call json_print ( p , 'test.json' ) !write it to a file call json_destroy ( p ) !cleanup end program test Produces the JSON file test.json : { \"year\" : 1805 , \"value\" : 0.1E+1 } Components Type Visibility Attributes Name Initial type( json_value ), private, pointer :: previous => null() previous item in the list type( json_value ), private, pointer :: next => null() next item in the list type( json_value ), private, pointer :: parent => null() parent item of this type( json_value ), private, pointer :: children => null() first child item of this type( json_value ), private, pointer :: tail => null() last child item of this character(kind=CK,len=:), private, allocatable :: name variable name real(kind=RK), private, allocatable :: dbl_value real data for this variable logical(kind=LK), private, allocatable :: log_value logical data for this variable character(kind=CK,len=:), private, allocatable :: str_value string data for this variable integer(kind=IK), private, allocatable :: int_value integer data for this variable integer(kind=IK), private :: var_type = json_unknown variable type integer(kind=IK), private :: n_children = 0 number of children Source Code type , public :: json_value !force the constituents to be stored contiguously ![note: on Intel, the order of the variables below ! is significant to avoid the misaligned field warnings] sequence private !for the linked list: type ( json_value ), pointer :: previous => null () !! previous item in the list type ( json_value ), pointer :: next => null () !! next item in the list type ( json_value ), pointer :: parent => null () !! parent item of this type ( json_value ), pointer :: children => null () !! first child item of this type ( json_value ), pointer :: tail => null () !! last child item of this character ( kind = CK , len = :), allocatable :: name !! variable name real ( RK ), allocatable :: dbl_value !! real data for this variable logical ( LK ), allocatable :: log_value !! logical data for this variable character ( kind = CK , len = :), allocatable :: str_value !! string data for this variable integer ( IK ), allocatable :: int_value !! integer data for this variable integer ( IK ) :: var_type = json_unknown !! variable type integer ( IK ), private :: n_children = 0 !! number of children end type json_value","tags":"","loc":"type/json_value.html","title":"json_value â€“ JSON-Fortran "},{"text":"The json_file is the main public class that is\n  used to open a file and get data from it. Example program test use json_module implicit none type ( json_file ) :: json integer :: ival real ( real64 ) :: rval character ( len = :), allocatable :: cval logical :: found call json_initialize () call json % load_file ( filename = 'myfile.json' ) call json % print_file () !print to the console call json % get ( 'var.i' , ival , found ) call json % get ( 'var.r(3)' , rval , found ) call json % get ( 'var.c' , cval , found ) call json % destroy () end program test Components Type Visibility Attributes Name Initial type( json_value ), private, pointer :: p => null() the JSON structure read from the file Constructor private interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object private  function initialize_json_file (p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object Return Value type( json_file ) Description Cast a json_value object as a json_file object Type-Bound Procedures procedure, public :: load_file => json_file_load private  subroutine json_file_load (me, filename, unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use Description Load the JSON data from a file. generic, public :: load_from_string => json_file_load_from_string private  subroutine json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Load the JSON data from a string. procedure, public :: destroy => json_file_destroy private  subroutine json_file_destroy (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Destroy the json_file . procedure, public :: move => json_file_move_pointer private  subroutine json_file_move_pointer (to, from) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from Description Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. generic, public :: info => json_file_variable_info private  subroutine json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Returns information about a variable in a json_file . procedure, public :: print_to_string => json_file_print_to_string private  subroutine json_file_print_to_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to Description Print the JSON file to a string. generic, public :: print_file => json_file_print_to_console , json_file_print_1 , json_file_print_2 private  subroutine json_file_print_to_console (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Print the JSON file to the console. private  subroutine json_file_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Prints the JSON file to the specified file unit number. private  subroutine json_file_print_2 (me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. generic, public :: get => json_file_get_object , json_file_get_integer , json_file_get_double , json_file_get_logical , json_file_get_string , json_file_get_integer_vec , json_file_get_double_vec , json_file_get_logical_vec , json_file_get_string_vec , json_file_get_root private  subroutine json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Get a json_value pointer to an object from a JSON file. private  subroutine json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer value from a JSON file. private  subroutine json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a real(RK) variable value from a JSON file. private  subroutine json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) value from a JSON file. private  subroutine json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Get a character string from a json file.\n  The output val is an allocatable character string. private  subroutine json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer vector from a JSON file. private  subroutine json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a real(RK) vector from a JSON file. private  subroutine json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) vector from a JSON file. private  subroutine json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a JSON file. private  subroutine json_file_get_root (me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Get a json_value pointer to the JSON file root. generic, public :: update => json_file_update_integer , json_file_update_logical , json_file_update_real , json_file_update_string private  subroutine json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: json_file_load_from_string private  subroutine json_file_load_from_string (me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Load the JSON data from a string. procedure, public :: json_file_variable_info private  subroutine json_file_variable_info (me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Returns information about a variable in a json_file . procedure, public :: json_file_get_object private  subroutine json_file_get_object (me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Get a json_value pointer to an object from a JSON file. procedure, public :: json_file_get_integer private  subroutine json_file_get_integer (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer value from a JSON file. procedure, public :: json_file_get_double private  subroutine json_file_get_double (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a real(RK) variable value from a JSON file. procedure, public :: json_file_get_logical private  subroutine json_file_get_logical (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) value from a JSON file. procedure, public :: json_file_get_string private  subroutine json_file_get_string (me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Get a character string from a json file.\n  The output val is an allocatable character string. procedure, public :: json_file_get_integer_vec private  subroutine json_file_get_integer_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer vector from a JSON file. procedure, public :: json_file_get_double_vec private  subroutine json_file_get_double_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a real(RK) vector from a JSON file. procedure, public :: json_file_get_logical_vec private  subroutine json_file_get_logical_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) vector from a JSON file. procedure, public :: json_file_get_string_vec private  subroutine json_file_get_string_vec (me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a JSON file. procedure, public :: json_file_get_root private  subroutine json_file_get_root (me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Get a json_value pointer to the JSON file root. procedure, public :: json_file_update_integer private  subroutine json_file_update_integer (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: json_file_update_logical private  subroutine json_file_update_logical (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: json_file_update_real private  subroutine json_file_update_real (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: json_file_update_string private  subroutine json_file_update_string (me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. procedure, public :: json_file_print_to_console private  subroutine json_file_print_to_console (me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Print the JSON file to the console. procedure, public :: json_file_print_1 private  subroutine json_file_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Prints the JSON file to the specified file unit number. procedure, public :: json_file_print_2 private  subroutine json_file_print_2 (me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Source Code type , public :: json_file private type ( json_value ), pointer :: p => null () !! the JSON structure read from the file contains procedure , public :: load_file => json_file_load generic , public :: load_from_string => MAYBEWRAP ( json_file_load_from_string ) procedure , public :: destroy => json_file_destroy procedure , public :: move => json_file_move_pointer generic , public :: info => MAYBEWRAP ( json_file_variable_info ) procedure , public :: print_to_string => json_file_print_to_string generic , public :: print_file => json_file_print_to_console , & json_file_print_1 , & json_file_print_2 generic , public :: get => MAYBEWRAP ( json_file_get_object ), & MAYBEWRAP ( json_file_get_integer ), & MAYBEWRAP ( json_file_get_double ), & MAYBEWRAP ( json_file_get_logical ), & MAYBEWRAP ( json_file_get_string ), & MAYBEWRAP ( json_file_get_integer_vec ), & MAYBEWRAP ( json_file_get_double_vec ), & MAYBEWRAP ( json_file_get_logical_vec ), & MAYBEWRAP ( json_file_get_string_vec ), & json_file_get_root generic , public :: update => MAYBEWRAP ( json_file_update_integer ), & MAYBEWRAP ( json_file_update_logical ), & MAYBEWRAP ( json_file_update_real ), & MAYBEWRAP ( json_file_update_string ) #     ifdef USE_UCS4 generic , public :: update => json_file_update_string_name_ascii , & json_file_update_string_val_ascii #     endif !load from string: procedure :: MAYBEWRAP ( json_file_load_from_string ) !git info: procedure :: MAYBEWRAP ( json_file_variable_info ) !get: procedure :: MAYBEWRAP ( json_file_get_object ) procedure :: MAYBEWRAP ( json_file_get_integer ) procedure :: MAYBEWRAP ( json_file_get_double ) procedure :: MAYBEWRAP ( json_file_get_logical ) procedure :: MAYBEWRAP ( json_file_get_string ) procedure :: MAYBEWRAP ( json_file_get_integer_vec ) procedure :: MAYBEWRAP ( json_file_get_double_vec ) procedure :: MAYBEWRAP ( json_file_get_logical_vec ) procedure :: MAYBEWRAP ( json_file_get_string_vec ) procedure :: json_file_get_root !update: procedure :: MAYBEWRAP ( json_file_update_integer ) procedure :: MAYBEWRAP ( json_file_update_logical ) procedure :: MAYBEWRAP ( json_file_update_real ) procedure :: MAYBEWRAP ( json_file_update_string ) #     ifdef USE_UCS4 procedure :: json_file_update_string_name_ascii procedure :: json_file_update_string_val_ascii #     endif !print_file: procedure :: json_file_print_to_console procedure :: json_file_print_1 procedure :: json_file_print_2 end type json_file","tags":"","loc":"type/json_file.html","title":"json_file â€“ JSON-Fortran "},{"text":"abstract interface private  subroutine array_callback_func(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Description Array element callback function.  Used by json_get_array","tags":"","loc":"interface/array_callback_func.html","title":"array_callback_func â€“ JSON-Fortran"},{"text":"abstract interface private  subroutine traverse_callback_func(p, finished) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: p logical(kind=LK), intent(out) :: finished Description Callback function used by json_traverse","tags":"","loc":"interface/traverse_callback_func.html","title":"traverse_callback_func â€“ JSON-Fortran"},{"text":"private  function initialize_json_file(p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object Return Value type([ , '']) Description Cast a json_value object as a json_file object Source Code function initialize_json_file ( p ) result ( file_object ) implicit none type ( json_value ), pointer , optional , intent ( in ) :: p !! `json_value` object to cast !! as a `json_file` object type ( json_file ) :: file_object if ( present ( p )) file_object % p => p end function initialize_json_file","tags":"","loc":"proc/initialize_json_file.html","title":"initialize_json_file â€“ JSON-Fortran"},{"text":"public  function json_failed() Arguments None Return Value logical(kind=LK) Description Logical function to indicate if an exception has been thrown. Example type ( json_file ) :: json logical :: status_ok character ( len = :), allocatable :: error_msg call json % load_file ( filename = 'myfile.json' ) if ( json_failed ()) then call json_check_for_errors ( status_ok , error_msg ) write ( * , * ) 'Error: ' // error_msg call json_clear_exceptions () call json % destroy () end if See also json_check_for_errors Source Code function json_failed () result ( failed ) implicit none logical ( LK ) :: failed failed = exception_thrown end function json_failed","tags":"","loc":"proc/json_failed.html","title":"json_failed â€“ JSON-Fortran"},{"text":"public pure function json_count(me) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me Return Value integer(kind=IK) number of children Description Count the number of children. History JW : 1/4/2014 : Original routine removed.\n    Now using n_children variable.\n    Renamed from json_value_count. Source Code pure function json_count ( me ) result ( count ) implicit none integer ( IK ) :: count !! number of children type ( json_value ), pointer , intent ( in ) :: me count = me % n_children end function json_count","tags":"","loc":"proc/json_count.html","title":"json_count â€“ JSON-Fortran"},{"text":"private  function string_to_integer(str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str Return Value integer(kind=IK) Description Convert a string into an integer. History Jacob Williams : 12/10/2013 : Rewrote routine.  Added error checking. Modified by Izaak Beekman Note Replacement for the parse_integer function in the original code. Variables Type Visibility Attributes Name Initial character(kind=CDK,len=:), public, allocatable :: digits integer(kind=IK), public :: ndigits_digits integer(kind=IK), public :: ndigits integer(kind=IK), public :: ierr Source Code function string_to_integer ( str ) result ( ival ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ival character ( kind = CDK , len = :), allocatable :: digits integer ( IK ) :: ndigits_digits , ndigits , ierr if (. not . exception_thrown ) then ! Compute how many digits we need to read ndigits = 2 * len_trim ( str ) ndigits_digits = floor ( log10 ( real ( ndigits ))) + 1 allocate ( character ( kind = CDK , len = ndigits_digits ) :: digits ) write ( digits , '(I0)' ) ndigits !gfortran will have a runtime error with * edit descriptor here ! gfortran bug: '*' edit descriptor for ISO_10646 strings does bad stuff. read ( str , '(I' // trim ( digits ) // ')' , iostat = ierr ) ival !string to integer if ( ierr /= 0 ) then !if there was an error ival = 0 call throw_exception ( 'Error in string_to_integer:' // & ' string cannot be converted to an integer: ' // trim ( str )) end if else ival = 0 end if end function string_to_integer","tags":"","loc":"proc/string_to_integer.html","title":"string_to_integer â€“ JSON-Fortran"},{"text":"private  function string_to_double(str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str Return Value real(kind=RK) Description Convert a string into a double. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: ierr Source Code function string_to_double ( str ) result ( rval ) implicit none real ( RK ) :: rval character ( kind = CK , len =* ), intent ( in ) :: str integer ( IK ) :: ierr if (. not . exception_thrown ) then read ( str , fmt = real_fmt , iostat = ierr ) rval !string to double if ( ierr /= 0 ) then !if there was an error rval = 0.0_RK call throw_exception ( 'Error in string_to_double:' // & ' string cannot be converted to a double: ' // trim ( str )) end if end if end function string_to_double","tags":"","loc":"proc/string_to_double.html","title":"string_to_double â€“ JSON-Fortran"},{"text":"private recursive function pop_char(unit, str, eof, skip_ws) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) â€“ only used if unit=0 logical(kind=LK), intent(out) :: eof true if the end of the file has been reached. logical(kind=LK), intent(in), optional :: skip_ws to ignore whitespace. Return Value character(kind=CK,len=1) the popped character. Description Get the next character from the file (or string). See also push_char Note This routine ignores non-printing ASCII characters (iachar<=31) that are in strings. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: ios integer(kind=IK), public :: str_len character(kind=CK,len=1), public :: c logical(kind=LK), public :: ignore Source Code recursive function pop_char ( unit , str , eof , skip_ws ) result ( popped ) implicit none character ( kind = CK , len = 1 ) :: popped !! the popped character. integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) -- only used if unit=0 logical ( LK ), intent ( out ) :: eof !! true if the end of the file has been reached. logical ( LK ), intent ( in ), optional :: skip_ws !! to ignore whitespace. integer ( IK ) :: ios , str_len character ( kind = CK , len = 1 ) :: c logical ( LK ) :: ignore if (. not . exception_thrown ) then eof = . false . if (. not . present ( skip_ws )) then ignore = . false . else ignore = skip_ws end if do if ( pushed_index > 0 ) then ! there is a character pushed back on, most likely from the number parsing ! NOTE: this can only occur if reading from a file when use_unformatted_stream=.false. c = pushed_char ( pushed_index : pushed_index ) pushed_index = pushed_index - 1 else if ( unit /= 0 ) then !read from the file !read the next character: if ( use_unformatted_stream ) then read ( unit = unit , pos = ipos , iostat = ios ) c else read ( unit = unit , fmt = '(A1)' , advance = 'NO' , iostat = ios ) c end if ipos = ipos + 1 !....note: maybe try read the file in chunks... !.... or use asynchronous read with double buffering !     (see Modern Fortran: Style and Usage) else !read from the string str_len = len ( str ) !length of the string if ( ipos <= str_len ) then c = str ( ipos : ipos ) ios = 0 else ios = IOSTAT_END !end of the string end if ipos = ipos + 1 end if char_count = char_count + 1 !character count in the current line if ( IS_IOSTAT_END ( ios )) then !end of file char_count = 0 eof = . true . exit elseif ( IS_IOSTAT_EOR ( ios ) . or . c == newline ) then !end of record char_count = 0 line_count = line_count + 1 cycle end if end if if ( any ( c == control_chars )) then ! non printing ascii characters cycle else if ( ignore . and . c == space ) then cycle else popped = c exit end if end do end if end function pop_char","tags":"","loc":"proc/pop_char.html","title":"pop_char â€“ JSON-Fortran"},{"text":"private pure function valid_json_hex(str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str the string to check. Return Value logical(kind=LK) is str a value 4-digit hex string Description Returns true if the string is a valid 4-digit hex string. Examples valid_json_hex ( '0000' ) !returns true valid_json_hex ( 'ABC4' ) !returns true valid_json_hex ( 'AB' ) !returns false (< 4 characters) valid_json_hex ( 'WXYZ' ) !returns false (invalid characters) Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: n integer(kind=IK), public :: i character(kind=CK,len=1), public, parameter, dimension(22) :: valid_chars = [(achar(i),i=48,57),(achar(i),i=65,70),(achar(i),i=97,102)] Source Code pure function valid_json_hex ( str ) result ( valid ) implicit none logical ( LK ) :: valid !! is str a value 4-digit hex string character ( kind = CK , len =* ), intent ( in ) :: str !! the string to check. integer ( IK ) :: n , i !an array of the valid hex characters: character ( kind = CK , len = 1 ), dimension ( 22 ), parameter :: valid_chars = & [ ( achar ( i ), i = 48 , 57 ), & ! decimal digits ( achar ( i ), i = 65 , 70 ), & ! capital A-F ( achar ( i ), i = 97 , 102 ) ] ! lowercase a-f !initialize valid = . false . !check all the characters in the string: n = len ( str ) if ( n == 4 ) then do i = 1 , n if (. not . any ( str ( i : i ) == valid_chars )) return end do valid = . true . !all are in the set, so it is OK end if end function valid_json_hex","tags":"","loc":"proc/valid_json_hex.html","title":"valid_json_hex â€“ JSON-Fortran"},{"text":"private pure function to_uni(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Convert string to unicode (CDK to CK). Source Code pure function to_uni ( str ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: str character ( kind = CK , len = len ( str )) :: to_uni to_uni = str end function to_uni","tags":"","loc":"proc/to_uni.html","title":"to_uni â€“ JSON-Fortran"},{"text":"private pure function to_uni_vec(str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n    dimension(size(str)) Description Convert array of strings to unicode (CDK to CK). Note JW: may be able to remove this by making to_uni PURE ELEMENTAL ? Source Code pure function to_uni_vec ( str ) implicit none character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: str character ( kind = CK , len = len ( str )), dimension ( size ( str )) :: to_uni_vec to_uni_vec = str end function to_uni_vec","tags":"","loc":"proc/to_uni_vec.html","title":"to_uni_vec â€“ JSON-Fortran"},{"text":"private  function ucs4_join_default(ucs4_str, def_str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value character(kind=CK,len=(len(ucs4_str)+len(def_str))) Description CK//CDK operator. Source Code function ucs4_join_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len = ( len ( ucs4_str ) + len ( def_str ))) :: res res = ucs4_str // to_unicode ( def_str ) end function ucs4_join_default","tags":"","loc":"proc/ucs4_join_default.html","title":"ucs4_join_default â€“ JSON-Fortran"},{"text":"private  function default_join_ucs4(def_str, ucs4_str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value character(kind=CK,len=(len(def_str)+len(ucs4_str))) Description CDK//CK operator. Source Code function default_join_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CK , len = ( len ( def_str ) + len ( ucs4_str ))) :: res res = to_unicode ( def_str ) // ucs4_str end function default_join_ucs4","tags":"","loc":"proc/default_join_ucs4.html","title":"default_join_ucs4 â€“ JSON-Fortran"},{"text":"private  function ucs4_comp_default(ucs4_str, def_str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: ucs4_str character(kind=CDK,len=*), intent(in) :: def_str Return Value logical(kind=LK) Description CK==CDK operator. Source Code function ucs4_comp_default ( ucs4_str , def_str ) result ( res ) implicit none character ( kind = CK , len =* ), intent ( in ) :: ucs4_str character ( kind = CDK , len =* ), intent ( in ) :: def_str logical ( LK ) :: res res = ( ucs4_str == to_unicode ( def_str ) ) end function ucs4_comp_default","tags":"","loc":"proc/ucs4_comp_default.html","title":"ucs4_comp_default â€“ JSON-Fortran"},{"text":"private  function default_comp_ucs4(def_str, ucs4_str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: def_str character(kind=CK,len=*), intent(in) :: ucs4_str Return Value logical(kind=LK) Description CDK==CK operator. Source Code function default_comp_ucs4 ( def_str , ucs4_str ) result ( res ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: def_str character ( kind = CK , len =* ), intent ( in ) :: ucs4_str logical ( LK ) :: res res = ( to_unicode ( def_str ) == ucs4_str ) end function default_comp_ucs4","tags":"","loc":"proc/default_comp_ucs4.html","title":"default_comp_ucs4 â€“ JSON-Fortran"},{"text":"private  subroutine destroy_json_data(d) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: d Description Destroy the data within a json_value , and rest type to json_unknown . Source Code subroutine destroy_json_data ( d ) implicit none type ( json_value ), intent ( inout ) :: d d % var_type = json_unknown if ( allocated ( d % log_value )) deallocate ( d % log_value ) if ( allocated ( d % int_value )) deallocate ( d % int_value ) if ( allocated ( d % dbl_value )) deallocate ( d % dbl_value ) if ( allocated ( d % str_value )) deallocate ( d % str_value ) end subroutine destroy_json_data","tags":"","loc":"proc/destroy_json_data.html","title":"destroy_json_data â€“ JSON-Fortran"},{"text":"private  subroutine json_file_destroy(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Destroy the json_file . Source Code subroutine json_file_destroy ( me ) implicit none class ( json_file ), intent ( inout ) :: me if ( associated ( me % p )) call json_value_destroy ( me % p ) end subroutine json_file_destroy","tags":"","loc":"proc/json_file_destroy.html","title":"json_file_destroy â€“ JSON-Fortran"},{"text":"private  subroutine json_file_move_pointer(to, from) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: to class( json_file ), intent(inout) :: from Description Move the json_value pointer from one json_file to another.\n  The \"from\" pointer is then nullified, but not destroyed. Note If \"from%p\" is not associated, then an error is thrown. Source Code subroutine json_file_move_pointer ( to , from ) implicit none class ( json_file ), intent ( inout ) :: to class ( json_file ), intent ( inout ) :: from if ( associated ( from % p )) then to % p => from % p nullify ( from % p ) else call throw_exception ( 'Error in json_file_move_pointer: ' // & 'pointer is not associated.' ) end if end subroutine json_file_move_pointer","tags":"","loc":"proc/json_file_move_pointer.html","title":"json_file_move_pointer â€“ JSON-Fortran"},{"text":"private  subroutine json_file_load(me, filename, unit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename the filename to open integer(kind=IK), intent(in), optional :: unit the unit number to use Description Load the JSON data from a file. Example type ( json_file ) :: f call f % load_file ( 'my_file.json' ) Source Code subroutine json_file_load ( me , filename , unit ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to open integer ( IK ), intent ( in ), optional :: unit !! the unit number to use call json_parse ( file = filename , p = me % p , unit = unit ) end subroutine json_file_load","tags":"","loc":"proc/json_file_load.html","title":"json_file_load â€“ JSON-Fortran"},{"text":"private  subroutine json_file_load_from_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: str string to load JSON data from Description Load the JSON data from a string. Example Load JSON from a string: type ( json_file ) :: f call f % load_from_string ( '{ \"name\": \"Leonidas\" }' ) Source Code subroutine json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: str !! string to load JSON data from call json_parse ( str = str , p = me % p ) end subroutine json_file_load_from_string","tags":"","loc":"proc/json_file_load_from_string.html","title":"json_file_load_from_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_load_from_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: str Description Alternate version of json_file_load_from_string , where \"str\" is kind=CDK. Source Code subroutine wrap_json_file_load_from_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: str call json_file_load_from_string ( me , to_unicode ( str )) end subroutine wrap_json_file_load_from_string","tags":"","loc":"proc/wrap_json_file_load_from_string.html","title":"wrap_json_file_load_from_string â€“ JSON-Fortran"},{"text":"private  subroutine json_file_print_to_console(me) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me Description Print the JSON file to the console. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: dummy Source Code subroutine json_file_print_to_console ( me ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable :: dummy call json_value_print ( me % p , iunit = output_unit , str = dummy , indent = 1 , colon = . true .) end subroutine json_file_print_to_console","tags":"","loc":"proc/json_file_print_to_console.html","title":"json_file_print_to_console â€“ JSON-Fortran"},{"text":"private  subroutine json_file_print_1(me, iunit) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me integer(kind=IK), intent(in) :: iunit file unit number (must not be -1) Description Prints the JSON file to the specified file unit number. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i character(kind=CK,len=:), public, allocatable :: dummy Source Code subroutine json_file_print_1 ( me , iunit ) implicit none class ( json_file ), intent ( inout ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit number (must not be -1) integer ( IK ) :: i character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then i = iunit call json_value_print ( me % p , iunit = i , str = dummy , indent = 1 , colon = . true .) else call throw_exception ( 'Error in json_file_print_1: iunit must not be -1.' ) end if end subroutine json_file_print_1","tags":"","loc":"proc/json_file_print_1.html","title":"json_file_print_1 â€“ JSON-Fortran"},{"text":"private  subroutine json_file_print_2(me, filename) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: filename filename to print to Description Print the JSON structure to the specified filename.\n  The file is opened, printed, and then closed. Example Example loading a JSON file, changing a value, and then printing\n  result to a new file: type ( json_file ) :: f logical :: found call f % load_file ( 'my_file.json' ) !open the original file call f % update ( 'version' , 4 , found ) !change the value of a variable call f % print_file ( 'my_file_2.json' ) !save file as new name Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: iunit integer(kind=IK), public :: istat Source Code subroutine json_file_print_2 ( me , filename ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! filename to print to integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call me % print_file ( iunit ) !call the other routine close ( iunit , iostat = istat ) else call throw_exception ( 'Error in json_file_print_2: could not open file: ' // & trim ( filename )) end if end subroutine json_file_print_2","tags":"","loc":"proc/json_file_print_2.html","title":"json_file_print_2 â€“ JSON-Fortran"},{"text":"private  subroutine json_file_print_to_string(me, str) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=:), intent(out), allocatable :: str string to print JSON data to Description Print the JSON file to a string. Example Open a JSON file, and then print the contents to a string: type ( json_file ) :: f character ( kind = CK , len = :), allocatable :: str call f % load_file ( 'my_file.json' ) call f % print_file ( str ) Source Code subroutine json_file_print_to_string ( me , str ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: str !! string to print JSON data to call json_value_to_string ( me % p , str ) end subroutine json_file_print_to_string","tags":"","loc":"proc/json_file_print_to_string.html","title":"json_file_print_to_string â€“ JSON-Fortran"},{"text":"private  subroutine json_file_variable_info(me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path path to the variable logical(kind=LK), intent(out) :: found the variable exists in the structure integer(kind=IK), intent(out) :: var_type variable type integer(kind=IK), intent(out) :: n_children number of children Description Returns information about a variable in a json_file . Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! path to the variable logical ( LK ), intent ( out ) :: found !! the variable exists in the structure integer ( IK ), intent ( out ) :: var_type !! variable type integer ( IK ), intent ( out ) :: n_children !! number of children type ( json_value ), pointer :: p !initialize: nullify ( p ) !get a pointer to the variable (if it is there): call me % get ( path , p , found ) if ( found ) then !get info: call json_info ( p , var_type , n_children ) else !set to dummy values: var_type = json_unknown n_children = 0 end if !cleanup: nullify ( p ) end subroutine json_file_variable_info","tags":"","loc":"proc/json_file_variable_info.html","title":"json_file_variable_info â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_variable_info(me, path, found, var_type, n_children) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: found integer(kind=IK), intent(out) :: var_type integer(kind=IK), intent(out) :: n_children Description Alternate version of json_file_variable_info , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_variable_info ( me , path , found , var_type , n_children ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: found integer ( IK ), intent ( out ) :: var_type integer ( IK ), intent ( out ) :: n_children call json_file_variable_info ( me , to_unicode ( path ), found , var_type , n_children ) end subroutine wrap_json_file_variable_info","tags":"","loc":"proc/wrap_json_file_variable_info.html","title":"wrap_json_file_variable_info â€“ JSON-Fortran"},{"text":"public  subroutine json_info(p, var_type, n_children, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p integer(kind=IK), intent(out), optional :: var_type variable type integer(kind=IK), intent(out), optional :: n_children number of children character(kind=CK,len=:), intent(out), optional allocatable :: name variable name Description Returns information about a json_value . Source Code subroutine json_info ( p , var_type , n_children , name ) implicit none type ( json_value ), pointer :: p integer ( IK ), intent ( out ), optional :: var_type !! variable type integer ( IK ), intent ( out ), optional :: n_children !! number of children character ( kind = CK , len = :), allocatable , intent ( out ), optional :: name !! variable name if ( present ( var_type )) var_type = p % var_type if ( present ( n_children )) n_children = json_count ( p ) if ( present ( name )) name = p % name end subroutine json_info","tags":"","loc":"proc/json_info.html","title":"json_info â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_object(me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable type( json_value ), intent(out), pointer :: p pointer to the variable logical(kind=LK), intent(out), optional :: found if it was really found Description Get a json_value pointer to an object from a JSON file. Source Code subroutine json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable logical ( LK ), intent ( out ), optional :: found !! if it was really found call json_get_by_path ( me % p , path = path , p = p , found = found ) end subroutine json_file_get_object","tags":"","loc":"proc/json_file_get_object.html","title":"json_file_get_object â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_root(me, p) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me type( json_value ), intent(out), pointer :: p pointer to the variable Description Get a json_value pointer to the JSON file root. Note This is equivalent to calling json_file %get('$',p) Source Code subroutine json_file_get_root ( me , p ) implicit none class ( json_file ), intent ( inout ) :: me type ( json_value ), pointer , intent ( out ) :: p !! pointer to the variable p => me % p end subroutine json_file_get_root","tags":"","loc":"proc/json_file_get_root.html","title":"json_file_get_root â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_object(me, path, p, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_object , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_object ( me , path , p , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json_file_get_object ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_file_get_object","tags":"","loc":"proc/wrap_json_file_get_object.html","title":"wrap_json_file_get_object â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_integer(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out) :: val value logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer value from a JSON file. Source Code subroutine json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), intent ( out ) :: val !! value logical ( LK ), intent ( out ), optional :: found !! if it was really found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_integer","tags":"","loc":"proc/json_file_get_integer.html","title":"json_file_get_integer â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_integer(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_integer ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_integer ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_integer","tags":"","loc":"proc/wrap_json_file_get_integer.html","title":"wrap_json_file_get_integer â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_integer_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path the path to the variable integer(kind=IK), intent(out), dimension(:), allocatable :: vec the value vector logical(kind=LK), intent(out), optional :: found if it was really found Description Get an integer vector from a JSON file. Source Code subroutine json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path !! the path to the variable integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec !! the value vector logical ( LK ), intent ( out ), optional :: found !! if it was really found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_integer_vec","tags":"","loc":"proc/json_file_get_integer_vec.html","title":"json_file_get_integer_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_integer_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_integer_vec , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_integer_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_integer_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_integer_vec","tags":"","loc":"proc/wrap_json_file_get_integer_vec.html","title":"wrap_json_file_get_integer_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_double(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a real(RK) variable value from a JSON file. Source Code subroutine json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_double","tags":"","loc":"proc/json_file_get_double.html","title":"json_file_get_double â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_double(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_double ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_double ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_double","tags":"","loc":"proc/wrap_json_file_get_double.html","title":"wrap_json_file_get_double â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_double_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a real(RK) vector from a JSON file. Source Code subroutine json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_double_vec","tags":"","loc":"proc/json_file_get_double_vec.html","title":"json_file_get_double_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_double_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_double_vec , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_double_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_double_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_double_vec","tags":"","loc":"proc/wrap_json_file_get_double_vec.html","title":"wrap_json_file_get_double_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_logical(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) value from a JSON file. Source Code subroutine json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_logical","tags":"","loc":"proc/json_file_get_logical.html","title":"json_file_get_logical â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_logical(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out) :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_logical ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_logical ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_logical","tags":"","loc":"proc/wrap_json_file_get_logical.html","title":"wrap_json_file_get_logical â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_logical_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical(LK) vector from a JSON file. Source Code subroutine json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_logical_vec","tags":"","loc":"proc/json_file_get_logical_vec.html","title":"json_file_get_logical_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_logical_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_logical_vec , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_logical_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_logical_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_logical_vec","tags":"","loc":"proc/wrap_json_file_get_logical_vec.html","title":"wrap_json_file_get_logical_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_string(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Get a character string from a json file.\n  The output val is an allocatable character string. Source Code subroutine json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path = path , value = val , found = found ) end subroutine json_file_get_string","tags":"","loc":"proc/json_file_get_string.html","title":"json_file_get_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_string(me, path, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: val logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_string ( me , path , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: val logical ( LK ), intent ( out ), optional :: found call json_file_get_string ( me , to_unicode ( path ), val , found ) end subroutine wrap_json_file_get_string","tags":"","loc":"proc/wrap_json_file_get_string.html","title":"wrap_json_file_get_string â€“ JSON-Fortran"},{"text":"private  subroutine json_file_get_string_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a JSON file. Source Code subroutine json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get ( me % p , path , vec , found ) end subroutine json_file_get_string_vec","tags":"","loc":"proc/json_file_get_string_vec.html","title":"json_file_get_string_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_get_string_vec(me, path, vec, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_file_get_string_vec , where \"path\" is kind=CDK. Source Code subroutine wrap_json_file_get_string_vec ( me , path , vec , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_file_get_string_vec ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_file_get_string_vec","tags":"","loc":"proc/wrap_json_file_get_string_vec.html","title":"wrap_json_file_get_string_vec â€“ JSON-Fortran"},{"text":"public  subroutine json_initialize(verbose, compact_reals, print_signs, real_format) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(in), optional :: verbose mainly useful for debugging (default is false) logical(kind=LK), intent(in), optional :: compact_reals to compact the real number strings for output (default is true) logical(kind=LK), intent(in), optional :: print_signs always print numeric sign (default is false) character(kind=len=*,CDK), intent(in), optional :: real_format exponential (default), scientific, engineering or general Description Initialize the JSON -Fortran module.\n  The routine must be called before any of the routines are used.\n  It can also be called after using the module and encountering exceptions. Modified Izaak Beekman : 02/24/2015 Variables Type Visibility Attributes Name Initial character(kind=CDK,len=10), public :: w character(kind=CDK,len=10), public :: d character(kind=CDK,len=10), public :: e character(kind=CDK,len=2), public :: sgn character(kind=CDK,len=2), public :: rl_edit_desc integer(kind=IK), public :: istat logical(kind=LK), public :: sgn_prnt Source Code subroutine json_initialize ( verbose , compact_reals , print_signs , real_format ) implicit none logical ( LK ), intent ( in ), optional :: verbose !! mainly useful for debugging (default is false) logical ( LK ), intent ( in ), optional :: compact_reals !! to compact the real number strings for output (default is true) logical ( LK ), intent ( in ), optional :: print_signs !! always print numeric sign (default is false) character ( len =* , kind = CDK ), intent ( in ), optional :: real_format !! exponential (default), scientific, engineering or general character ( kind = CDK , len = 10 ) :: w , d , e character ( kind = CDK , len = 2 ) :: sgn , rl_edit_desc integer ( IK ) :: istat logical ( LK ) :: sgn_prnt !clear any errors from previous runs: call json_clear_exceptions () !Ensure gfortran bug work around \"parameters\" are set properly null_str = 'null' true_str = 'true' false_str = 'false' !Just in case, clear these global variables also: pushed_index = 0 pushed_char = '' char_count = 0 line_count = 1 ipos = 1 # ifdef USE_UCS4 ! reopen stdout and stderr with utf-8 encoding open ( output_unit , encoding = 'utf-8' ) open ( error_unit , encoding = 'utf-8' ) # endif !verbose error printing: if ( present ( verbose )) is_verbose = verbose !Set the format for real numbers: ! [if not changing it, then it remains the same] if ( (. not . allocated ( real_fmt )) . or . & ! if this hasn't been done yet present ( compact_reals ) . or . & present ( print_signs ) . or . & present ( real_format ) ) then if ( present ( compact_reals )) compact_real = compact_reals !set defaults sgn_prnt = . false . if ( present ( print_signs ) ) sgn_prnt = print_signs if ( sgn_prnt ) then sgn = 'sp' else sgn = 'ss' end if rl_edit_desc = 'E' if ( present ( real_format ) ) then select case ( real_format ) case ( 'g' , 'G' , 'e' , 'E' , 'en' , 'EN' , 'es' , 'ES' ) rl_edit_desc = real_format case default call throw_exception ( 'Invalid real format, \"' // trim ( real_format ) // '\", passed to json_initialize.' // & new_line ( 'a' ) // 'Acceptable formats are: \"G\", \"E\", \"EN\", and \"ES\".' ) end select end if ! set the default output/input format for reals: write ( w , '(ss,I0)' , iostat = istat ) max_numeric_str_len if ( istat == 0 ) write ( d , '(ss,I0)' , iostat = istat ) real_precision if ( istat == 0 ) write ( e , '(ss,I0)' , iostat = istat ) real_exponent_digits if ( istat == 0 ) then real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // trim ( w ) // '.' // trim ( d ) // 'E' // trim ( e ) // ')' else real_fmt = '(' // sgn // ',' // trim ( rl_edit_desc ) // '30.16E3)' !just use this one (should never happen) end if end if end subroutine json_initialize","tags":"","loc":"proc/json_initialize.html","title":"json_initialize â€“ JSON-Fortran"},{"text":"public  subroutine json_clear_exceptions() Arguments None Description Clear exceptions in the JSON module. Source Code subroutine json_clear_exceptions () implicit none !clear the flag and message: exception_thrown = . false . err_message = '' end subroutine json_clear_exceptions","tags":"","loc":"proc/json_clear_exceptions.html","title":"json_clear_exceptions â€“ JSON-Fortran"},{"text":"private  subroutine json_throw_exception(msg) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: msg Description Throw an exception in the JSON module.\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called. Source Code subroutine json_throw_exception ( msg ) implicit none character ( kind = CK , len =* ), intent ( in ) :: msg !the error message exception_thrown = . true . err_message = trim ( msg ) if ( is_verbose ) then write ( * , '(A)' ) '***********************' write ( * , '(A)' ) 'JSON-Fortran EXCEPTION: ' // trim ( msg ) !call backtrace()     ! gfortran (use -fbacktrace -fall-intrinsics flags) !call tracebackqq(-1) ! intel (requires \"use ifcore\" in this routine) write ( * , '(A)' ) '***********************' end if end subroutine json_throw_exception","tags":"","loc":"proc/json_throw_exception.html","title":"json_throw_exception â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_throw_exception(msg) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: msg Description Alternate version of json_throw_exception , where \"msg\" is kind=CDK. Source Code subroutine wrap_json_throw_exception ( msg ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: msg !the error message call json_throw_exception ( to_unicode ( msg )) end subroutine wrap_json_throw_exception","tags":"","loc":"proc/wrap_json_throw_exception.html","title":"wrap_json_throw_exception â€“ JSON-Fortran"},{"text":"public  subroutine json_check_for_errors(status_ok, error_msg) Arguments Type Intent Optional Attributes Name logical(kind=LK), intent(out) :: status_ok true if there were no errors character(kind=CK,len=:), intent(out), allocatable :: error_msg the error message (if there were errors) Description Retrieve error code from the module.\n  This should be called after json_parse to check for errors.\n  If an error is thrown, before using the module again, json_initialize should be called to clean up before it is used again. Example type ( json_file ) :: json logical :: status_ok character ( kind = CK , len = :), allocatable :: error_msg call json % load_file ( filename = 'myfile.json' ) call json_check_for_errors ( status_ok , error_msg ) if (. not . status_ok ) then write ( * , * ) 'Error: ' // error_msg call json_clear_exceptions () call json % destroy () end if See also json_failed Source Code subroutine json_check_for_errors ( status_ok , error_msg ) implicit none logical ( LK ), intent ( out ) :: status_ok !! true if there were no errors character ( kind = CK , len = :), allocatable , intent ( out ) :: error_msg !! the error message (if there were errors) status_ok = . not . exception_thrown if (. not . status_ok ) then if ( allocated ( err_message )) then error_msg = err_message else error_msg = 'Error: json_initialize() must be called first to initialize the module.' end if else error_msg = '' end if end subroutine json_check_for_errors","tags":"","loc":"proc/json_check_for_errors.html","title":"json_check_for_errors â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create(p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p Description Allocate a json_value pointer variable.\n  This should be called before adding data to it. Example type ( json_value ), pointer :: var call json_value_create ( var ) call to_double ( var , 1.0 d0 ) Notes This routine does not check for exceptions. The pointer should not already be allocated. Source Code subroutine json_value_create ( p ) implicit none type ( json_value ), pointer :: p nullify ( p ) allocate ( p ) end subroutine json_value_create","tags":"","loc":"proc/json_value_create.html","title":"json_value_create â€“ JSON-Fortran"},{"text":"private recursive subroutine json_value_destroy(me, destroy_next) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in), optional :: destroy_next if true, then me%next is also destroyed (default is true) Description Destroy a json_value linked-list structure. Note The original FSON version of this\n      routine was not properly freeing the memory.\n      It was rewritten. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: des_next type( json_value ), public, pointer :: p Source Code recursive subroutine json_value_destroy ( me , destroy_next ) implicit none type ( json_value ), pointer :: me logical ( LK ), intent ( in ), optional :: destroy_next !! if true, then me%next is also destroyed (default is true) logical ( LK ) :: des_next type ( json_value ), pointer :: p if ( associated ( me )) then if ( present ( destroy_next )) then des_next = destroy_next else des_next = . true . end if if ( allocated ( me % name )) deallocate ( me % name ) call destroy_json_data ( me ) if ( associated ( me % children )) then do while ( me % n_children > 0 ) p => me % children me % children => me % children % next me % n_children = me % n_children - 1 call json_value_destroy ( p ,. false .) end do nullify ( me % children ) nullify ( p ) end if if ( associated ( me % next ) . and . des_next ) call json_value_destroy ( me % next ) if ( associated ( me % previous )) nullify ( me % previous ) if ( associated ( me % parent )) nullify ( me % parent ) if ( associated ( me % tail )) nullify ( me % tail ) deallocate ( me ) nullify ( me ) end if end subroutine json_value_destroy","tags":"","loc":"proc/json_value_destroy.html","title":"json_value_destroy â€“ JSON-Fortran"},{"text":"private  subroutine json_value_remove(me, destroy) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Description Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. Examples To extract an object from one JSON structure, and add it to another: type ( json_value ), pointer :: json1 , json2 , p logical :: found !create and populate json1 and json2 call json_get ( json1 , 'name' , p , found ) ! get pointer to name element of json1 call json_remove ( p , destroy = . false .) ! remove it from json1 (don't destroy) call json_add ( json2 , p ) ! add it to json2 To remove an object from a JSON structure (and destroy it): type ( json_value ), pointer :: json1 , p logical :: found !create and populate json1 call json_get ( json1 , 'name' , p , found ) ! get pointer to name element of json1 call json_remove ( p ) ! remove and destroy it History Jacob Williams : 12/28/2014 : added destroy optional argument. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: parent type( json_value ), public, pointer :: previous type( json_value ), public, pointer :: next logical(kind=LK), public :: destroy_it Source Code subroutine json_value_remove ( me , destroy ) implicit none type ( json_value ), pointer :: me logical ( LK ), intent ( in ), optional :: destroy !! If destroy is not present, it is also destroyed. !! If destroy is present and true, it is destroyed. !! If destroy is present and false, it is not destroyed. type ( json_value ), pointer :: parent , previous , next logical ( LK ) :: destroy_it if ( associated ( me )) then !optional input argument: if ( present ( destroy )) then destroy_it = destroy else destroy_it = . true . end if if ( associated ( me % parent )) then parent => me % parent if ( associated ( me % next )) then !there are later items in the list: next => me % next nullify ( me % next ) if ( associated ( me % previous )) then !there are earlier items in the list previous => me % previous previous % next => next next % previous => previous else !this is the first item in the list parent % children => next nullify ( next % previous ) end if else if ( associated ( me % previous )) then !there are earlier items in the list: previous => me % previous nullify ( previous % next ) parent % tail => previous else !this is the only item in the list: nullify ( parent % children ) nullify ( parent % tail ) end if end if parent % n_children = parent % n_children - 1 end if if ( destroy_it ) call json_value_destroy ( me ) end if end subroutine json_value_remove","tags":"","loc":"proc/json_value_remove.html","title":"json_value_remove â€“ JSON-Fortran"},{"text":"private  subroutine json_value_remove_if_present(p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name Description Given the path string, remove the variable from\n  the json_value structure, if it exists. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var logical(kind=LK), public :: found Source Code subroutine json_value_remove_if_present ( p , name ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p_var logical ( LK ) :: found call json_get ( p , name , p_var , found ) if ( found ) call json_remove ( p_var ) end subroutine json_value_remove_if_present","tags":"","loc":"proc/json_value_remove_if_present.html","title":"json_value_remove_if_present â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_remove_if_present(p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CDK,len=*), intent(in) :: name Description Alternate version of json_value_remove_if_present , where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_remove_if_present ( p , name ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_remove_if_present ( p , to_unicode ( name )) end subroutine wrap_json_value_remove_if_present","tags":"","loc":"proc/wrap_json_value_remove_if_present.html","title":"wrap_json_value_remove_if_present â€“ JSON-Fortran"},{"text":"private  subroutine json_file_update_integer(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_integer Source Code subroutine json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_integer","tags":"","loc":"proc/json_file_update_integer.html","title":"json_file_update_integer â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_update_integer(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_integer , where \"name\" is kind=CDK. Source Code subroutine wrap_json_file_update_integer ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_integer ( me , to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_integer","tags":"","loc":"proc/wrap_json_file_update_integer.html","title":"wrap_json_file_update_integer â€“ JSON-Fortran"},{"text":"private  subroutine json_file_update_logical(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_logical Source Code subroutine json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_logical","tags":"","loc":"proc/json_file_update_logical.html","title":"json_file_update_logical â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_update_logical(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_logical , where \"name\" is kind=CDK. Source Code subroutine wrap_json_file_update_logical ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_logical ( me , to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_logical","tags":"","loc":"proc/wrap_json_file_update_logical.html","title":"wrap_json_file_update_logical â€“ JSON-Fortran"},{"text":"private  subroutine json_file_update_real(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_double Source Code subroutine json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_real","tags":"","loc":"proc/json_file_update_real.html","title":"json_file_update_real â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_update_real(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_real , where \"name\" is kind=CDK. Source Code subroutine wrap_json_file_update_real ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_real ( me , to_unicode ( name ), val , found ) end subroutine wrap_json_file_update_real","tags":"","loc":"proc/wrap_json_file_update_real.html","title":"wrap_json_file_update_real â€“ JSON-Fortran"},{"text":"private  subroutine json_file_update_string(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present in the file,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. See also json_update_string Source Code subroutine json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found if (. not . exception_thrown ) call json_update ( me % p , name , val , found ) end subroutine json_file_update_string","tags":"","loc":"proc/json_file_update_string.html","title":"json_file_update_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_file_update_string(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" and \"val\" are kind=CDK. Source Code subroutine wrap_json_file_update_string ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_string ( me , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_file_update_string","tags":"","loc":"proc/wrap_json_file_update_string.html","title":"wrap_json_file_update_string â€“ JSON-Fortran"},{"text":"private  subroutine json_file_update_string_name_ascii(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"name\" is kind=CDK. Source Code subroutine json_file_update_string_name_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_string ( me , to_unicode ( name ), val , found ) end subroutine json_file_update_string_name_ascii","tags":"","loc":"proc/json_file_update_string_name_ascii.html","title":"json_file_update_string_name_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_file_update_string_val_ascii(me, name, val, found) Arguments Type Intent Optional Attributes Name class( json_file ), intent(inout) :: me character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_file_update_string , where \"val\" is kind=CDK. Source Code subroutine json_file_update_string_val_ascii ( me , name , val , found ) implicit none class ( json_file ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_file_update_string ( me , name , to_unicode ( val ), found ) end subroutine json_file_update_string_val_ascii","tags":"","loc":"proc/json_file_update_string_val_ascii.html","title":"json_file_update_string_val_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_update_logical(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_logical ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_logical ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_logical: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_logical","tags":"","loc":"proc/json_update_logical.html","title":"json_update_logical â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_update_logical(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CDK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_logical , where \"name\" is kind=CDK. Source Code subroutine wrap_json_update_logical ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_logical ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_logical","tags":"","loc":"proc/wrap_json_update_logical.html","title":"wrap_json_update_logical â€“ JSON-Fortran"},{"text":"private  subroutine json_update_double(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_double ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_double ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_double: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_double","tags":"","loc":"proc/json_update_double.html","title":"json_update_double â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_update_double(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_double , where \"name\" is kind=CDK. Source Code subroutine wrap_json_update_double ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_double ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_double","tags":"","loc":"proc/wrap_json_update_double.html","title":"wrap_json_update_double â€“ JSON-Fortran"},{"text":"private  subroutine json_update_integer(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_integer ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_integer ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_integer: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_integer","tags":"","loc":"proc/json_update_integer.html","title":"json_update_integer â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_update_integer(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CDK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_integer , where \"name\" is kind=CDK. Source Code subroutine wrap_json_update_integer ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_integer ( p , to_unicode ( name ), val , found ) end subroutine wrap_json_update_integer","tags":"","loc":"proc/wrap_json_update_integer.html","title":"wrap_json_update_integer â€“ JSON-Fortran"},{"text":"private  subroutine json_update_string(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p_var integer(kind=IK), public :: var_type Source Code subroutine json_update_string ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found type ( json_value ), pointer :: p_var integer ( IK ) :: var_type call json_get ( p , name , p_var , found ) if ( found ) then call json_info ( p_var , var_type ) select case ( var_type ) case ( json_null , json_logical , json_integer , json_double , json_string ) call to_string ( p_var , val ) !update the value case default found = . false . call throw_exception ( 'Error in json_update_string: ' // & 'the variable is not a scalar value' ) end select else call json_add ( p , name , val ) !add the new element end if end subroutine json_update_string","tags":"","loc":"proc/json_update_string.html","title":"json_update_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_update_string(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where \"name\" and \"value\" are kind=CDK. Source Code subroutine wrap_json_update_string ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_string ( p , to_unicode ( name ), to_unicode ( val ), found ) end subroutine wrap_json_update_string","tags":"","loc":"proc/wrap_json_update_string.html","title":"wrap_json_update_string â€“ JSON-Fortran"},{"text":"private  subroutine json_update_string_name_ascii(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where \"name\" is kind=CDK. Source Code subroutine json_update_string_name_ascii ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_string ( p , to_unicode ( name ), val , found ) end subroutine json_update_string_name_ascii","tags":"","loc":"proc/json_update_string_name_ascii.html","title":"json_update_string_name_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_update_string_val_ascii(p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Alternate version of json_update_string , where \"val\" is kind=CDK. Source Code subroutine json_update_string_val_ascii ( p , name , val , found ) implicit none type ( json_value ), pointer :: p character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val logical ( LK ), intent ( out ) :: found call json_update_string ( p , name , to_unicode ( val ), found ) end subroutine json_update_string_val_ascii","tags":"","loc":"proc/json_update_string_val_ascii.html","title":"json_update_string_val_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_member(me, member) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me type( json_value ), intent(inout), pointer :: member the child member to add Description Adds \"member\" as a child of \"me\". Source Code subroutine json_value_add_member ( me , member ) implicit none type ( json_value ), pointer :: me type ( json_value ), pointer :: member !! the child member to add if (. not . exception_thrown ) then ! associate the parent member % parent => me ! add to linked list if ( associated ( me % children )) then me % tail % next => member member % previous => me % tail else me % children => member member % previous => null () !first in the list end if ! new member is now the last one in the list me % tail => member me % n_children = me % n_children + 1 end if end subroutine json_value_add_member","tags":"","loc":"proc/json_value_add_member.html","title":"json_value_add_member â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_double(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Add a real value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine json_value_add_double ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value type ( json_value ), pointer :: var !create the variable: call json_value_create ( var ) call to_double ( var , val , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_double","tags":"","loc":"proc/json_value_add_double.html","title":"json_value_add_double â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_double(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Alternate version of json_value_add_double where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_add_double ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! variable name real ( RK ), intent ( in ) :: val !! real value call json_value_add_double ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double","tags":"","loc":"proc/wrap_json_value_add_double.html","title":"wrap_json_value_add_double â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_double_vec(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Add a real vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i Source Code subroutine json_value_add_double_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val type ( json_value ), pointer :: var integer ( IK ) :: i !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json_add ( var , '' , val ( i )) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_double_vec","tags":"","loc":"proc/json_value_add_double_vec.html","title":"json_value_add_double_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_double_vec(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Alternate version of json_value_add_double_vec where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_add_double_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), dimension (:), intent ( in ) :: val call json_value_add_double_vec ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_double_vec","tags":"","loc":"proc/wrap_json_value_add_double_vec.html","title":"wrap_json_value_add_double_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_integer(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Add an integer value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine json_value_add_integer ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val type ( json_value ), pointer :: var !create the variable: call json_value_create ( var ) call to_integer ( var , val , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_integer","tags":"","loc":"proc/json_value_add_integer.html","title":"json_value_add_integer â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_integer(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in) :: val value Description Alternate version of json_value_add_integer where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_add_integer ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), intent ( in ) :: val !! value call json_value_add_integer ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer","tags":"","loc":"proc/wrap_json_value_add_integer.html","title":"wrap_json_value_add_integer â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_integer_vec(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Add an integer vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i Source Code subroutine json_value_add_integer_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !counter !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json_add ( var , '' , val ( i )) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_integer_vec","tags":"","loc":"proc/json_value_add_integer_vec.html","title":"json_value_add_integer_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_integer_vec(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_integer_vec where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_add_integer_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable integer ( IK ), dimension (:), intent ( in ) :: val !! value call json_value_add_integer_vec ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_integer_vec","tags":"","loc":"proc/wrap_json_value_add_integer_vec.html","title":"wrap_json_value_add_integer_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_logical(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Add a logical value child to the json_value variable Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine json_value_add_logical ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value type ( json_value ), pointer :: var !create the variable: call json_value_create ( var ) call to_logical ( var , val , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_logical","tags":"","loc":"proc/json_value_add_logical.html","title":"json_value_add_logical â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_logical(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Alternate version of json_value_add_logical where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_add_logical ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), intent ( in ) :: val !! value call json_value_add_logical ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical","tags":"","loc":"proc/wrap_json_value_add_logical.html","title":"wrap_json_value_add_logical â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_logical_vec(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Add a logical vector to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i Source Code subroutine json_value_add_logical_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the vector logical ( LK ), dimension (:), intent ( in ) :: val !! value type ( json_value ), pointer :: var integer ( IK ) :: i !counter !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) call json_add ( var , '' , val ( i )) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_logical_vec","tags":"","loc":"proc/json_value_add_logical_vec.html","title":"json_value_add_logical_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_logical_vec(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in), dimension(:) :: val value Description Alternate version of json_value_add_logical_vec where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_add_logical_vec ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable logical ( LK ), dimension (:), intent ( in ) :: val !! value call json_value_add_logical_vec ( me , to_unicode ( name ), val ) end subroutine wrap_json_value_add_logical_vec","tags":"","loc":"proc/wrap_json_value_add_logical_vec.html","title":"wrap_json_value_add_logical_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_string(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Add a character string child to the json_value variable. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var character(kind=CK,len=:), public, allocatable :: str Source Code subroutine json_value_add_string ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value type ( json_value ), pointer :: var character ( kind = CK , len = :), allocatable :: str !add escape characters if necessary: call escape_string ( val , str ) !create the variable: call json_value_create ( var ) call to_string ( var , str , name ) !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_string","tags":"","loc":"proc/json_value_add_string.html","title":"json_value_add_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_string(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where \"name\" and \"val\" are kind=CDK. Source Code subroutine wrap_json_value_add_string ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json_value_add_string ( me , to_unicode ( name ), to_unicode ( val )) end subroutine wrap_json_value_add_string","tags":"","loc":"proc/wrap_json_value_add_string.html","title":"wrap_json_value_add_string â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_string_name_ascii(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where \"name\" is kind=CDK. Source Code subroutine json_value_add_string_name_ascii ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CK , len =* ), intent ( in ) :: val !! value call json_value_add_string ( me , to_unicode ( name ), val ) end subroutine json_value_add_string_name_ascii","tags":"","loc":"proc/json_value_add_string_name_ascii.html","title":"json_value_add_string_name_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_string_val_ascii(me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CDK,len=*), intent(in) :: val value Description Alternate version of json_value_add_string where \"val\" is kind=CDK. Source Code subroutine json_value_add_string_val_ascii ( me , name , val ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! name of the variable character ( kind = CDK , len =* ), intent ( in ) :: val !! value call json_value_add_string ( me , name , to_unicode ( val )) end subroutine json_value_add_string_val_ascii","tags":"","loc":"proc/json_value_add_string_val_ascii.html","title":"json_value_add_string_val_ascii â€“ JSON-Fortran"},{"text":"private  subroutine escape_string(str_in, str_out) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: str_in character(kind=CK,len=:), intent(out), allocatable :: str_out Description Add the escape characters to a string for adding to JSON . Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i integer(kind=IK), public :: ipos character(kind=CK,len=1), public :: c character(kind=CK,len=*), public, parameter :: specials = quotation_mark//backslash//slash//bspace//formfeed//newline//carriage_return//horizontal_tab Source Code subroutine escape_string ( str_in , str_out ) implicit none character ( kind = CK , len =* ), intent ( in ) :: str_in character ( kind = CK , len = :), allocatable , intent ( out ) :: str_out integer ( IK ) :: i , ipos character ( kind = CK , len = 1 ) :: c character ( kind = CK , len =* ), parameter :: specials = quotation_mark // & backslash // & slash // & bspace // & formfeed // & newline // & carriage_return // & horizontal_tab !Do a quick scan for the special characters, ! if any are present, then process the string, ! otherwise, return the string as is. if ( scan ( str_in , specials ) > 0 ) then str_out = repeat ( space , chunk_size ) ipos = 1 !go through the string and look for special characters: do i = 1 , len ( str_in ) c = str_in ( i : i ) !get next character in the input string !if the string is not big enough, then add another chunk: if ( ipos + 3 > len ( str_out )) str_out = str_out // repeat ( space , chunk_size ) select case ( c ) case ( quotation_mark , backslash , slash ) str_out ( ipos : ipos + 1 ) = backslash // c ipos = ipos + 2 case ( bspace ) str_out ( ipos : ipos + 1 ) = '\\b' ipos = ipos + 2 case ( formfeed ) str_out ( ipos : ipos + 1 ) = '\\f' ipos = ipos + 2 case ( newline ) str_out ( ipos : ipos + 1 ) = '\\n' ipos = ipos + 2 case ( carriage_return ) str_out ( ipos : ipos + 1 ) = '\\r' ipos = ipos + 2 case ( horizontal_tab ) str_out ( ipos : ipos + 1 ) = '\\t' ipos = ipos + 2 case default str_out ( ipos : ipos ) = c ipos = ipos + 1 end select end do !trim the string if necessary: if ( ipos < len ( str_out ) + 1 ) then if ( ipos == 1 ) then str_out = '' else str_out = str_out ( 1 : ipos - 1 ) end if end if else str_out = str_in end if end subroutine escape_string","tags":"","loc":"proc/escape_string.html","title":"escape_string â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_string_vec(me, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Add an array of character strings to the structure. Note This routine is part of the public API that can be\n      used to build a JSON structure using json_value pointers. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var integer(kind=IK), public :: i logical(kind=LK), public :: trim_string logical(kind=LK), public :: adjustl_string character(kind=CK,len=:), public, allocatable :: str Source Code subroutine json_value_add_string_vec ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! variable name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val !! array of strings logical ( LK ), intent ( in ), optional :: trim_str !! if TRIM() should be called for each element logical ( LK ), intent ( in ), optional :: adjustl_str !! if ADJUSTL() should be called for each element type ( json_value ), pointer :: var integer ( IK ) :: i logical ( LK ) :: trim_string , adjustl_string character ( kind = CK , len = :), allocatable :: str !if the string is to be trimmed or not: if ( present ( trim_str )) then trim_string = trim_str else trim_string = . false . end if if ( present ( adjustl_str )) then adjustl_string = adjustl_str else adjustl_string = . false . end if !create the variable as an array: call json_value_create ( var ) call to_array ( var , name ) !populate the array: do i = 1 , size ( val ) !the string to write: str = val ( i ) if ( adjustl_string ) str = adjustl ( str ) if ( trim_string ) str = trim ( str ) !write it: call json_add ( var , '' , str ) !cleanup deallocate ( str ) end do !add it: call json_add ( me , var ) !cleanup: nullify ( var ) end subroutine json_value_add_string_vec","tags":"","loc":"proc/json_value_add_string_vec.html","title":"json_value_add_string_vec â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_add_string_vec(me, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where \"name\" and \"val\" are kind=CDK. Source Code subroutine wrap_json_value_add_string_vec ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json_value_add_string_vec ( me , to_unicode ( name ), to_unicode ( val ), trim_str , adjustl_str ) end subroutine wrap_json_value_add_string_vec","tags":"","loc":"proc/wrap_json_value_add_string_vec.html","title":"wrap_json_value_add_string_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_string_vec_name_ascii(me, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where \"name\" is kind=CDK. Source Code subroutine json_value_add_string_vec_name_ascii ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json_value_add_string_vec ( me , to_unicode ( name ), val , trim_str , adjustl_str ) end subroutine json_value_add_string_vec_name_ascii","tags":"","loc":"proc/json_value_add_string_vec_name_ascii.html","title":"json_value_add_string_vec_name_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_value_add_string_vec_val_ascii(me, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name character(kind=CDK,len=*), intent(in), dimension(:) :: val logical(kind=LK), intent(in), optional :: trim_str logical(kind=LK), intent(in), optional :: adjustl_str Description Alternate version of json_value_add_string_vec where \"val\" is kind=CDK. Source Code subroutine json_value_add_string_vec_val_ascii ( me , name , val , trim_str , adjustl_str ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), dimension (:), intent ( in ) :: val logical ( LK ), intent ( in ), optional :: trim_str logical ( LK ), intent ( in ), optional :: adjustl_str call json_value_add_string_vec ( me , name , to_unicode ( val ), trim_str , adjustl_str ) end subroutine json_value_add_string_vec_val_ascii","tags":"","loc":"proc/json_value_add_string_vec_val_ascii.html","title":"json_value_add_string_vec_val_ascii â€“ JSON-Fortran"},{"text":"private  subroutine json_value_get_by_index(me, idx, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), intent(inout), pointer :: p pointer to the child Description Returns a child in the object or array given the index. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i Source Code subroutine json_value_get_by_index ( me , idx , p ) implicit none type ( json_value ), pointer , intent ( in ) :: me !! object or array JSON data integer ( IK ), intent ( in ) :: idx !! index of the child type ( json_value ), pointer :: p !! pointer to the child integer ( IK ) :: i nullify ( p ) if (. not . exception_thrown ) then if ( associated ( me % children )) then p => me % children do i = 1 , idx - 1 if ( associated ( p % next )) then p => p % next else call throw_exception ( 'Error in json_value_get_by_index:' // & ' p%next is not associated.' ) nullify ( p ) return end if end do else call throw_exception ( 'Error in json_value_get_by_index:' // & ' me%children is not associated.' ) end if end if end subroutine json_value_get_by_index","tags":"","loc":"proc/json_value_get_by_index.html","title":"json_value_get_by_index â€“ JSON-Fortran"},{"text":"private  subroutine json_value_get_by_name_chars(me, name, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: name the name of a child of \"me\" type( json_value ), intent(inout), pointer :: p pointer to the child Description Returns a child in the object or array given the name string. It is a case-sensitive search, and the name string is not trimmed.\n  So, for example, 'a ' /= 'A ' /= 'a  ' Note The \"name\" input is not a path, and is not parsed like it is in json_get_by_path . Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i integer(kind=IK), public :: n_children Source Code subroutine json_value_get_by_name_chars ( me , name , p ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: name !! the name of a child of \"me\" type ( json_value ), pointer :: p !! pointer to the child integer ( IK ) :: i , n_children nullify ( p ) if (. not . exception_thrown ) then if ( associated ( me )) then if ( me % var_type == json_object ) then n_children = json_count ( me ) p => me % children !start with first one do i = 1 , n_children if ( allocated ( p % name )) then if ( p % name == name ) return end if p => p % next end do end if !did not find anything: call throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'child variable ' // trim ( name ) // ' was not found.' ) nullify ( p ) else call throw_exception ( 'Error in json_value_get_by_name_chars: ' // & 'pointer is not associated.' ) end if end if end subroutine json_value_get_by_name_chars","tags":"","loc":"proc/json_value_get_by_name_chars.html","title":"json_value_get_by_name_chars â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_get_by_name_chars(me, name, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: name type( json_value ), intent(inout), pointer :: p Description Alternate version of json_value_get_by_name_chars where \"name\" is kind=CDK. Source Code subroutine wrap_json_value_get_by_name_chars ( me , name , p ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: name type ( json_value ), pointer :: p call json_value_get_by_name_chars ( me , to_unicode ( name ), p ) end subroutine wrap_json_value_get_by_name_chars","tags":"","loc":"proc/wrap_json_value_get_by_name_chars.html","title":"wrap_json_value_get_by_name_chars â€“ JSON-Fortran"},{"text":"private  subroutine json_value_to_string(me, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Description Print the json_value structure to an allocatable string. Source Code subroutine json_value_to_string ( me , str ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), intent ( out ), allocatable :: str !! prints structure to this string str = '' call json_value_print ( me , iunit = unit2str , str = str , indent = 1 , colon = . true .) end subroutine json_value_to_string","tags":"","loc":"proc/json_value_to_string.html","title":"json_value_to_string â€“ JSON-Fortran"},{"text":"private  subroutine json_print_1(me, iunit) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Print the json_value structure to a file. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: dummy Source Code subroutine json_print_1 ( me , iunit ) implicit none type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( in ) :: iunit !! the file unit (the file must already have been opened, can't be -1). character ( kind = CK , len = :), allocatable :: dummy if ( iunit /= unit2str ) then call json_value_print ( me , iunit , str = dummy , indent = 1 , colon = . true .) else call throw_exception ( 'Error in json_print: iunit must not be -1.' ) end if end subroutine json_print_1","tags":"","loc":"proc/json_print_1.html","title":"json_print_1 â€“ JSON-Fortran"},{"text":"private  subroutine json_print_2(me, filename) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Print the json_value structure to a file. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: iunit integer(kind=IK), public :: istat Source Code subroutine json_print_2 ( me , filename ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: filename !! the filename to print to (should not already be open) integer ( IK ) :: iunit , istat open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat FILE_ENCODING ) if ( istat == 0 ) then call json_print ( me , iunit ) close ( iunit , iostat = istat ) else call throw_exception ( 'Error in json_print: could not open file: ' // & trim ( filename )) end if end subroutine json_print_2","tags":"","loc":"proc/json_print_2.html","title":"json_print_2 â€“ JSON-Fortran"},{"text":"private recursive subroutine json_value_print(me, iunit, str, indent, need_comma, colon, is_array_element) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(in) :: iunit file unit to write to (6=console) character(kind=CK,len=:), intent(inout), allocatable :: str if iunit==unit2str (-1) then the structure is\n printed to this string rather than\n a file. This mode is used by json_value_to_string . integer(kind=IK), intent(in), optional :: indent indention level logical(kind=LK), intent(in), optional :: need_comma if it needs a comma after it logical(kind=LK), intent(in), optional :: colon if the colon was just written logical(kind=LK), intent(in), optional :: is_array_element if this is an array element Description Print the JSON structure to a string or a file. Notes This is an internal routine called by the wrapper routines json_print and json_value_to_string . The reason the str argument is non-optional is because of a\n    bug in v4.9 of the gfortran compiler. Variables Type Visibility Attributes Name Initial character(kind=CK,len=max_numeric_str_len), public :: tmp character(kind=CK,len=:), public, allocatable :: s type( json_value ), public, pointer :: element integer(kind=IK), public :: tab integer(kind=IK), public :: i integer(kind=IK), public :: count integer(kind=IK), public :: spaces logical(kind=LK), public :: print_comma logical(kind=LK), public :: write_file logical(kind=LK), public :: write_string logical(kind=LK), public :: is_array Subroutines subroutine write_it(s, advance, comma) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: s logical(kind=LK), intent(in), optional :: advance logical(kind=LK), intent(in), optional :: comma Source Code recursive subroutine json_value_print ( me , iunit , str , indent , need_comma , colon , is_array_element ) implicit none type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( in ) :: iunit !! file unit to write to (6=console) integer ( IK ), intent ( in ), optional :: indent !! indention level logical ( LK ), intent ( in ), optional :: is_array_element !! if this is an array element logical ( LK ), intent ( in ), optional :: need_comma !! if it needs a comma after it logical ( LK ), intent ( in ), optional :: colon !! if the colon was just written character ( kind = CK , len = :), intent ( inout ), allocatable :: str !! if iunit==unit2str (-1) then the structure is !! printed to this string rather than !! a file. This mode is used by !! [[json_value_to_string]]. character ( kind = CK , len = max_numeric_str_len ) :: tmp !for val to string conversions character ( kind = CK , len = :), allocatable :: s type ( json_value ), pointer :: element integer ( IK ) :: tab , i , count , spaces logical ( LK ) :: print_comma logical ( LK ) :: write_file , write_string logical ( LK ) :: is_array if (. not . exception_thrown ) then !whether to write a string or a file (one or the other): write_string = ( iunit == unit2str ) write_file = . not . write_string !if the comma will be printed after the value ! [comma not printed for the last elements] if ( present ( need_comma )) then print_comma = need_comma else print_comma = . false . end if !number of \"tabs\" to indent: if ( present ( indent )) then tab = indent else tab = 0 end if !convert to number of spaces: spaces = tab * spaces_per_tab !if this is an element in an array: if ( present ( is_array_element )) then is_array = is_array_element else is_array = . false . end if !if the colon was the last thing written if ( present ( colon )) then s = '' else s = repeat ( space , spaces ) end if select case ( me % var_type ) case ( json_object ) count = json_count ( me ) if ( count == 0 ) then !special case for empty object call write_it ( s // start_object // end_object , comma = print_comma ) else call write_it ( s // start_object ) !if an object is in an array, there is an extra tab: if ( is_array ) then tab = tab + 1 spaces = tab * spaces_per_tab end if nullify ( element ) element => me % children do i = 1 , count ! print the name if ( allocated ( element % name )) then call write_it ( repeat ( space , spaces ) // quotation_mark // & element % name // quotation_mark // colon_char // space ,& advance = . false .) else call throw_exception ( 'Error in json_value_print:' // & ' element%name not allocated' ) nullify ( element ) return end if ! recursive print of the element call json_value_print ( element , iunit = iunit , indent = tab + 1 , & need_comma = i < count , colon = . true ., str = str ) ! get the next child the list: element => element % next end do ! [one fewer tab if it isn't an array element] if (. not . is_array ) s = repeat ( space , max ( 0 , spaces - spaces_per_tab )) call write_it ( s // end_object , comma = print_comma ) nullify ( element ) end if case ( json_array ) count = json_count ( me ) if ( count == 0 ) then !special case for empty array call write_it ( s // start_array // end_array , comma = print_comma ) else call write_it ( start_array ) nullify ( element ) element => me % children do i = 1 , count ! recursive print of the element call json_value_print ( element , iunit = iunit , indent = tab ,& need_comma = i < count , is_array_element = . true ., str = str ) ! get the next child the list: element => element % next end do !indent the closing array character: call write_it ( repeat ( space , max ( 0 , spaces - spaces_per_tab )) // end_array ,& comma = print_comma ) nullify ( element ) end if case ( json_null ) call write_it ( s // null_str , comma = print_comma ) case ( json_string ) if ( allocated ( me % str_value )) then call write_it ( s // quotation_mark // & trim ( me % str_value ) // quotation_mark , comma = print_comma ) else call throw_exception ( 'Error in json_value_print:' // & ' me%value_string not allocated' ) return end if case ( json_logical ) if ( me % log_value ) then call write_it ( s // true_str , comma = print_comma ) else call write_it ( s // false_str , comma = print_comma ) end if case ( json_integer ) call integer_to_string ( me % int_value , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case ( json_double ) call real_to_string ( me % dbl_value , tmp ) call write_it ( s // trim ( tmp ), comma = print_comma ) case default call throw_exception ( 'Error in json_value_print: unknown data type' ) end select !cleanup: if ( allocated ( s )) deallocate ( s ) end if contains ! ! write the string to the file (or the output string) ! subroutine write_it ( s , advance , comma ) implicit none character ( kind = CK , len =* ), intent ( in ) :: s !string to print logical ( LK ), intent ( in ), optional :: advance !to add line break or not logical ( LK ), intent ( in ), optional :: comma !print comma after the string logical ( LK ) :: add_line_break , add_comma character ( kind = CK , len = :), allocatable :: s2 if ( present ( comma )) then add_comma = comma else add_comma = . false . !default is not to add comma end if if ( present ( advance )) then add_line_break = advance else add_line_break = . true . !default is to advance end if !string to print: s2 = s if ( add_comma ) s2 = s2 // delimiter if ( write_file ) then if ( add_line_break ) then write ( iunit , fmt = '(A)' ) s2 else write ( iunit , fmt = '(A)' , advance = 'NO' ) s2 end if else !write string str = str // s2 if ( add_line_break ) str = str // newline end if !cleanup: if ( allocated ( s2 )) deallocate ( s2 ) end subroutine write_it end subroutine json_value_print","tags":"","loc":"proc/json_value_print.html","title":"json_value_print â€“ JSON-Fortran"},{"text":"private  subroutine json_get_by_path(me, path, p, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. Example type ( json_value ), pointer :: dat , p logical :: found !... call json_get ( dat , 'data(2).version' , p , found ) Notes The following special characters are used to denote paths: $         - root\n  @         - this\n  .         - child object member\n  [] or ()  - child array element Thus, if any of these characters are present in the name key,\n  this routine cannot be used to get the value.\n  In that case, the json_get_child routines would need to be used. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public, parameter :: start_array_alt = '(' character(kind=CK,len=1), public, parameter :: end_array_alt = ')' integer(kind=IK), public :: i integer(kind=IK), public :: length integer(kind=IK), public :: child_i character(kind=CK,len=1), public :: c logical(kind=LK), public :: array type( json_value ), public, pointer :: tmp Source Code subroutine json_get_by_path ( me , path , p , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found !! true if it was found character ( kind = CK , len = 1 ), parameter :: start_array_alt = '(' character ( kind = CK , len = 1 ), parameter :: end_array_alt = ')' integer ( IK ) :: i , length , child_i character ( kind = CK , len = 1 ) :: c logical ( LK ) :: array type ( json_value ), pointer :: tmp if (. not . exception_thrown ) then nullify ( p ) ! default to assuming relative to this p => me child_i = 1 array = . false . length = len_trim ( path ) do i = 1 , length c = path ( i : i ) select case ( c ) case ( CK_ '$' ) ! root do while ( associated ( p % parent )) p => p % parent end do child_i = i + 1 case ( CK_ '@' ) ! this p => me child_i = i + 1 case ( CK_ '.' ) ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json_get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_by_path:' // & ' Error getting child member.' ) exit end if child_i = i + 1 case ( start_array , start_array_alt ) !....Modified to allow for 'var[3]' style syntax !Note: jmozmoz/fson has a slightly different version of this... ! start looking for the array element index array = . true . ! get child member from p if ( child_i < i ) then nullify ( tmp ) call json_get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) else child_i = i + 1 cycle end if if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_by_path:' // & ' Error getting array element' ) exit end if child_i = i + 1 case ( end_array , end_array_alt ) if (. not . array ) then call throw_exception ( 'Error in json_get_by_path: Unexpected ]' ) exit end if array = . false . child_i = string_to_integer ( path ( child_i : i - 1 )) nullify ( tmp ) call json_get_child ( p , child_i , tmp ) p => tmp nullify ( tmp ) child_i = i + 1 end select end do if ( exception_thrown ) then if ( present ( found )) then found = . false . call json_clear_exceptions () end if else ! grab the last child if present in the path if ( child_i <= length ) then nullify ( tmp ) call json_get_child ( p , path ( child_i : i - 1 ), tmp ) p => tmp nullify ( tmp ) end if if ( associated ( p )) then if ( present ( found )) found = . true . !everything seems to be ok else call throw_exception ( 'Error in json_get_by_path:' // & ' variable not found: ' // trim ( path )) if ( present ( found )) then found = . false . call json_clear_exceptions () end if end if end if else if ( present ( found )) found = . false . end if end subroutine json_get_by_path","tags":"","loc":"proc/json_get_by_path.html","title":"json_get_by_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_by_path(me, path, p, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_by_path where \"path\" is kind=CDK. Source Code subroutine wrap_json_get_by_path ( me , path , p , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path type ( json_value ), pointer , intent ( out ) :: p logical ( LK ), intent ( out ), optional :: found call json_get_by_path ( me , to_unicode ( path ), p , found ) end subroutine wrap_json_get_by_path","tags":"","loc":"proc/wrap_json_get_by_path.html","title":"wrap_json_get_by_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_integer(me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . Source Code subroutine json_get_integer ( me , value ) implicit none type ( json_value ), pointer , intent ( in ) :: me integer ( IK ), intent ( out ) :: value value = 0 if ( exception_thrown ) return select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_double ) value = int ( me % dbl_value ) case ( json_logical ) if ( me % log_value ) then value = 1 else value = 0 end if case default call throw_exception ( 'Error in get_integer:' // & ' Unable to resolve value to integer: ' // me % name ) end select end subroutine json_get_integer","tags":"","loc":"proc/json_get_integer.html","title":"json_get_integer â€“ JSON-Fortran"},{"text":"private  subroutine json_get_integer_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_integer_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0 if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_integer:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_integer ( p , value ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found ) ) then found = . false . call json_clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_integer_with_path","tags":"","loc":"proc/json_get_integer_with_path.html","title":"json_get_integer_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_integer_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_with_path , where \"path\" is kind=CDK. Source Code subroutine wrap_json_get_integer_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_integer_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_integer_with_path","tags":"","loc":"proc/wrap_json_get_integer_with_path.html","title":"wrap_json_get_integer_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_integer_vec(me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Get an integer vector from a json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_int_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_integer_vec ( me , vec ) implicit none type ( json_value ), pointer :: me integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_int_from_array ) contains ! callback function for integer subroutine get_int_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec","tags":"","loc":"proc/json_get_integer_vec.html","title":"json_get_integer_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_get_integer_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_int_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_integer_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . call json_get ( me , path = path , array_callback = get_int_from_array , found = found ) ! need to duplicate callback function, no other way contains ! callback function for integer subroutine get_int_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_int_from_array end subroutine json_get_integer_vec_with_path","tags":"","loc":"proc/json_get_integer_vec_with_path.html","title":"json_get_integer_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_integer_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_integer_vec_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_integer_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path integer ( IK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_integer_vec_with_path ( me , path = to_unicode ( path ), vec = vec , found = found ) end subroutine wrap_json_get_integer_vec_with_path","tags":"","loc":"proc/wrap_json_get_integer_vec_with_path.html","title":"wrap_json_get_integer_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_double(me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . Source Code subroutine json_get_double ( me , value ) implicit none type ( json_value ), pointer :: me real ( RK ), intent ( out ) :: value value = 0.0_RK if ( exception_thrown ) return select case ( me % var_type ) case ( json_integer ) value = me % int_value case ( json_double ) value = me % dbl_value case ( json_logical ) if ( me % log_value ) then value = 1.0_RK else value = 0.0_RK end if case default call throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve value to double: ' // me % name ) end select end subroutine json_get_double","tags":"","loc":"proc/json_get_double.html","title":"json_get_double â€“ JSON-Fortran"},{"text":"private  subroutine json_get_double_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_double_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = 0.0_RK if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_double:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_double ( p , value ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found )) then found = . false . call json_clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_double_with_path","tags":"","loc":"proc/json_get_double_with_path.html","title":"json_get_double_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_double_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_double_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_double_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_double_with_path","tags":"","loc":"proc/wrap_json_get_double_with_path.html","title":"wrap_json_get_double_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_double_vec(me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Get a double vector from a json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_double_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_double_vec ( me , vec ) implicit none type ( json_value ), pointer :: me real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_double_from_array ) contains ! callback function for double subroutine get_double_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec","tags":"","loc":"proc/json_get_double_vec.html","title":"json_get_double_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_get_double_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_double_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_double_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , path = path , array_callback = get_double_from_array , found = found ) contains ! callback function for double subroutine get_double_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_double_from_array end subroutine json_get_double_vec_with_path","tags":"","loc":"proc/json_get_double_vec_with_path.html","title":"json_get_double_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_double_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_double_vec_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_double_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: path real ( RK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_double_vec_with_path ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_double_vec_with_path","tags":"","loc":"proc/wrap_json_get_double_vec_with_path.html","title":"wrap_json_get_double_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_logical(me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(inout) :: value Description Get a logical value from a json_value . Source Code subroutine json_get_logical ( me , value ) implicit none type ( json_value ), pointer , intent ( in ) :: me logical ( LK ) :: value value = . false . if ( exception_thrown ) return select case ( me % var_type ) case ( json_integer ) value = ( me % int_value > 0 ) case ( json_logical ) value = me % log_value case default call throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve value to logical: ' // me % name ) end select end subroutine json_get_logical","tags":"","loc":"proc/json_get_logical.html","title":"json_get_logical â€“ JSON-Fortran"},{"text":"private  subroutine json_get_logical_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(inout) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_logical_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = . false . if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_logical:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_logical ( p , value ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found )) then found = . false . call json_clear_exceptions () end if else if ( present ( found )) found = . true . end if end subroutine json_get_logical_with_path","tags":"","loc":"proc/json_get_logical_with_path.html","title":"json_get_logical_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_logical_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(inout) :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_logical_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_logical_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_logical_with_path","tags":"","loc":"proc/wrap_json_get_logical_with_path.html","title":"wrap_json_get_logical_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_logical_vec(me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Get a logical vector from json_value . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_logical_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_logical_vec ( me , vec ) implicit none type ( json_value ), pointer , intent ( in ) :: me logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_logical_from_array ) contains ! callback function for logical subroutine get_logical_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec","tags":"","loc":"proc/json_get_logical_vec.html","title":"json_get_logical_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_get_logical_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_logical_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_logical_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , path = path , array_callback = get_logical_from_array , found = found ) contains ! callback function for logical subroutine get_logical_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = vec ( i )) end subroutine get_logical_from_array end subroutine json_get_logical_vec_with_path","tags":"","loc":"proc/json_get_logical_vec_with_path.html","title":"json_get_logical_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_logical_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_logical_vec_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_logical_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path logical ( LK ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_logical_vec_with_path ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_logical_vec_with_path","tags":"","loc":"proc/wrap_json_get_logical_vec_with_path.html","title":"wrap_json_get_logical_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_string(me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: s character(kind=CK,len=:), public, allocatable :: pre character(kind=CK,len=:), public, allocatable :: post integer(kind=IK), public :: j integer(kind=IK), public :: jprev integer(kind=IK), public :: n character(kind=CK,len=1), public :: c Source Code subroutine json_get_string ( me , value ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len = :), allocatable , intent ( out ) :: value character ( kind = CK , len = :), allocatable :: s , pre , post integer ( IK ) :: j , jprev , n character ( kind = CK , len = 1 ) :: c value = '' if ( exception_thrown ) return select case ( me % var_type ) case ( json_string ) if ( allocated ( me % str_value )) then !get the value as is: s = me % str_value ! Now, have to remove the escape characters: ! ! '\\\"'        quotation mark ! '\\\\'        reverse solidus ! '\\/'        solidus ! '\\b'        backspace ! '\\f'        formfeed ! '\\n'        newline (LF) ! '\\r'        carriage return (CR) ! '\\t'        horizontal tab ! '\\uXXXX'    4 hexadecimal digits ! !initialize: n = len ( s ) j = 1 do jprev = j !initialize j = index ( s ( j : n ), backslash ) !look for an escape character if ( j > 0 ) then !an escape character was found !index in full string of the escape character: j = j + ( jprev - 1 ) if ( j < n ) then !save the bit before the escape character: if ( j > 1 ) then pre = s ( 1 : j - 1 ) else pre = '' end if !character after the escape character: c = s ( j + 1 : j + 1 ) if ( any ( c == [ quotation_mark , backslash , slash , & to_unicode ([ 'b' , 'f' , 'n' , 'r' , 't' ])])) then !save the bit after the escape characters: if ( j + 2 < n ) then post = s ( j + 2 : n ) else post = '' end if select case ( c ) case ( quotation_mark , backslash , slash ) !use c as is case ( CK_ 'b' ) c = bspace case ( CK_ 'f' ) c = formfeed case ( CK_ 'n' ) c = newline case ( CK_ 'r' ) c = carriage_return case ( CK_ 't' ) c = horizontal_tab end select s = pre // c // post n = n - 1 !backslash character has been ! removed from the string else if ( c == 'u' ) then !expecting 4 hexadecimal digits after !the escape character    [\\uXXXX] !for now, we are just printing them as is ![not checking to see if it is a valid hex value] if ( j + 5 <= n ) then j = j + 4 else call throw_exception ( 'Error in json_get_string:' // & ' Invalid hexadecimal sequence' // & ' in string: ' // trim ( c )) exit end if else !unknown escape character call throw_exception ( 'Error in json_get_string:' // & ' unknown escape sequence in string \"' // & trim ( s ) // '\" [' // backslash // c // ']' ) exit end if j = j + 1 !go to the next character if ( j >= n ) exit !finished else !an escape character is the last character in ! the string [this may not be valid syntax, ! but just keep it] exit end if else exit !no more escape characters in the string end if end do if ( exception_thrown ) then if ( allocated ( value )) deallocate ( value ) else value = s end if else call throw_exception ( 'Error in json_get_string:' // & ' me%value not allocated' ) end if case default call throw_exception ( 'Error in json_get_string:' // & ' Unable to resolve value to characters: ' // me % name ) ! Note: for the other cases, we could do val to string conversions. end select !cleanup: if ( allocated ( s )) deallocate ( s ) if ( allocated ( pre )) deallocate ( pre ) if ( allocated ( post )) deallocate ( post ) end subroutine json_get_string","tags":"","loc":"proc/json_get_string.html","title":"json_get_string â€“ JSON-Fortran"},{"text":"private  subroutine json_get_string_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_string_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p value = '' if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_string:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_string ( p , value ) nullify ( p ) end if if ( allocated ( value ) . and . . not . exception_thrown ) then if ( present ( found )) found = . true . else if ( present ( found )) then found = . false . call json_clear_exceptions () end if end if !cleanup: if ( associated ( p )) nullify ( p ) end subroutine json_get_string_with_path","tags":"","loc":"proc/json_get_string_with_path.html","title":"json_get_string_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_string_with_path(me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_string_with_path ( me , path , value , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len = :), allocatable , intent ( out ) :: value logical ( LK ), intent ( out ), optional :: found call json_get_string_with_path ( me , to_unicode ( path ), value , found ) end subroutine wrap_json_get_string_with_path","tags":"","loc":"proc/wrap_json_get_string_with_path.html","title":"wrap_json_get_string_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_string_vec(me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Get a string vector from a json_file . Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_chars_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_string_vec ( me , vec ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , array_callback = get_chars_from_array ) contains ! callback function for chars subroutine get_chars_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec","tags":"","loc":"proc/json_get_string_vec.html","title":"json_get_string_vec â€“ JSON-Fortran"},{"text":"private  subroutine json_get_string_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_file , given the path. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: initialized Subroutines subroutine get_chars_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer(kind=IK), intent(in) :: i integer(kind=IK), intent(in) :: count Source Code subroutine json_get_string_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found logical ( LK ) :: initialized initialized = . false . if ( allocated ( vec )) deallocate ( vec ) !the callback function is called for each element of the array: call json_get ( me , path = path , array_callback = get_chars_from_array , found = found ) contains ! callback function for chars subroutine get_chars_from_array ( element , i , count ) implicit none type ( json_value ), pointer , intent ( in ) :: element integer ( IK ), intent ( in ) :: i !index integer ( IK ), intent ( in ) :: count !size of array character ( kind = CK , len = :), allocatable :: cval !size the output array: if (. not . initialized ) then allocate ( vec ( count )) initialized = . true . end if !populate the elements: call json_get ( element , value = cval ) if ( allocated ( cval )) then vec ( i ) = cval deallocate ( cval ) else vec ( i ) = '' end if end subroutine get_chars_from_array end subroutine json_get_string_vec_with_path","tags":"","loc":"proc/json_get_string_vec_with_path.html","title":"json_get_string_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_string_vec_with_path(me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_string_vec_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_string_vec_with_path ( me , path , vec , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path character ( kind = CK , len =* ), dimension (:), allocatable , intent ( out ) :: vec logical ( LK ), intent ( out ), optional :: found call json_get_string_vec_with_path ( me , to_unicode ( path ), vec , found ) end subroutine wrap_json_get_string_vec_with_path","tags":"","loc":"proc/wrap_json_get_string_vec_with_path.html","title":"wrap_json_get_string_vec_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_get_array(me, array_callback) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me procedure( array_callback_func ), intent(inout) :: array_callback Description This routine calls the user-supplied array_callback_func subroutine\n      for each element in the array. Note For integer, double, logical, and character arrays,\n      higher-level routines are provided (see json_get ), so\n      this routine does not have to be used for those cases. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: element integer(kind=IK), public :: i integer(kind=IK), public :: count Source Code subroutine json_get_array ( me , array_callback ) implicit none type ( json_value ), pointer , intent ( in ) :: me procedure ( array_callback_func ) :: array_callback type ( json_value ), pointer :: element integer ( IK ) :: i , count if ( exception_thrown ) return nullify ( element ) select case ( me % var_type ) case ( json_array ) count = json_count ( me ) element => me % children do i = 1 , count ! callback for each child call array_callback ( element , i , count ) element => element % next end do case default call throw_exception ( 'Error in json_get_array:' // & ' Resolved value is not an array ' ) end select !cleanup: if ( associated ( element )) nullify ( element ) end subroutine json_get_array","tags":"","loc":"proc/json_get_array.html","title":"json_get_array â€“ JSON-Fortran"},{"text":"public recursive subroutine json_traverse(me, traverse_callback) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me procedure( traverse_callback_func ), intent(inout) :: traverse_callback Description Traverse a JSON structure.\n  This routine calls the user-specified traverse_callback_func for each element of the structure. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: element a child element integer(kind=IK), public :: i counter integer(kind=IK), public :: icount number of children logical(kind=LK), public :: finished can be used to stop the process Source Code recursive subroutine json_traverse ( me , traverse_callback ) implicit none type ( json_value ), pointer , intent ( in ) :: me procedure ( traverse_callback_func ) :: traverse_callback type ( json_value ), pointer :: element !! a child element integer ( IK ) :: i !! counter integer ( IK ) :: icount !! number of children logical ( LK ) :: finished !! can be used to stop the process if ( exception_thrown ) return call traverse_callback ( me , finished ) ! first call for this object if ( finished ) return !for arrays and objects, have to also call for all children: if ( me % var_type == json_array . or . me % var_type == json_object ) then icount = json_count ( me ) ! number of children if ( icount > 0 ) then element => me % children ! first one do i = 1 , icount ! call for each child call json_traverse ( element , traverse_callback ) if ( finished ) exit element => element % next end do end if nullify ( element ) end if end subroutine json_traverse","tags":"","loc":"proc/json_traverse.html","title":"json_traverse â€“ JSON-Fortran"},{"text":"private  subroutine json_get_array_with_path(me, path, array_callback, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( array_callback_func ), intent(inout) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p Source Code subroutine json_get_array_with_path ( me , path , array_callback , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CK , len =* ), intent ( in ) :: path procedure ( array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found type ( json_value ), pointer :: p if ( exception_thrown ) then if ( present ( found ) ) found = . false . return end if nullify ( p ) ! resolve the path to the value call json_get_by_path ( me = me , path = path , p = p ) if (. not . associated ( p )) then call throw_exception ( 'Error in json_get_array:' // & ' Unable to resolve path: ' // trim ( path )) else call json_get_array ( me = p , array_callback = array_callback ) nullify ( p ) end if if ( exception_thrown ) then if ( present ( found ) ) then found = . false . call json_clear_exceptions () end if else if ( present ( found ) ) found = . true . end if end subroutine json_get_array_with_path","tags":"","loc":"proc/json_get_array_with_path.html","title":"json_get_array_with_path â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_get_array_with_path(me, path, array_callback, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: path procedure( array_callback_func ), intent(inout) :: array_callback logical(kind=LK), intent(out), optional :: found Description Alternate version of json_get_array_with_path , where \"path\" is kind=CDK Source Code subroutine wrap_json_get_array_with_path ( me , path , array_callback , found ) implicit none type ( json_value ), pointer , intent ( in ) :: me character ( kind = CDK , len =* ), intent ( in ) :: path procedure ( array_callback_func ) :: array_callback logical ( LK ), intent ( out ), optional :: found call json_get_array_with_path ( me , to_unicode ( path ), array_callback , found ) end subroutine wrap_json_get_array_with_path","tags":"","loc":"proc/wrap_json_get_array_with_path.html","title":"wrap_json_get_array_with_path â€“ JSON-Fortran"},{"text":"private  subroutine json_parse_file(file, p, unit) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), intent(inout), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. Inputs The inputs can be: file and unit : the specified unit is used to read JSON from file.\n                    [note if unit is already open, then the filename is ignored] file          : JSON is read from file using internal unit number Example type ( json_value ), pointer :: p call json_parse ( file = 'myfile.json' , p = p ) History Jacob Williams : 01/13/2015 : added read from string option. Izaak Beekman  : 03/08/2015 : moved read from string to separate\n    subroutine, and error annotation\n    to separate subroutine. Note When calling this routine, any exceptions thrown from previous\n      calls will automatically be cleared. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: iunit integer(kind=IK), public :: istat logical(kind=LK), public :: is_open Source Code subroutine json_parse_file ( file , p , unit ) implicit none character ( kind = CDK , len =* ), intent ( in ) :: file !! JSON file name type ( json_value ), pointer :: p !! output structure integer ( IK ), intent ( in ), optional :: unit !! file unit number (/= 0) integer ( IK ) :: iunit , istat logical ( LK ) :: is_open !clear any exceptions and initialize: call json_initialize () if ( present ( unit ) ) then if ( unit == 0 ) then call throw_exception ( 'Error in json_parse_file: unit number must not be 0.' ) return end if iunit = unit !check to see if the file is already open ! if it is, then use it, otherwise open the file with the name given. inquire ( unit = iunit , opened = is_open , iostat = istat ) if ( istat == 0 . and . . not . is_open ) then ! open the file open ( unit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) else !if the file is already open, then we need to make sure ! that it is open with the correct form/access/etc... end if else ! open the file with a new unit number: open ( newunit = iunit , & file = file , & status = 'OLD' , & action = 'READ' , & form = form_spec , & access = access_spec , & iostat = istat & FILE_ENCODING ) end if if ( istat == 0 ) then ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = trim ( file ) !use the file name ! parse as a value call parse_value ( unit = iunit , str = CK_ '' , value = p ) if ( exception_thrown ) call annotate_invalid_json ( iunit , CK_ '' ) ! close the file if necessary close ( unit = iunit , iostat = istat ) else call throw_exception ( 'Error in json_parse_file: Error opening file: ' // trim ( file )) nullify ( p ) end if end subroutine json_parse_file","tags":"","loc":"proc/json_parse_file.html","title":"json_parse_file â€“ JSON-Fortran"},{"text":"private  subroutine json_parse_string(p, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree. See also json_parse_file Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: iunit = 0 Source Code subroutine json_parse_string ( p , str ) implicit none type ( json_value ), pointer :: p !! output structure character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data integer ( IK ), parameter :: iunit = 0 !indicates that json data will be read from buffer if ( . not . exception_thrown ) then !clear any exceptions and initialize: call json_initialize () ! create the value and associate the pointer call json_value_create ( p ) ! Note: the name of the root json_value doesn't really matter, !  but we'll allocate something here just in case. p % name = '' ! parse as a value call parse_value ( unit = iunit , str = str , value = p ) if ( exception_thrown ) call annotate_invalid_json ( iunit , str ) end if end subroutine json_parse_string","tags":"","loc":"proc/json_parse_string.html","title":"json_parse_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_parse_string(p, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p output structure character(kind=CDK,len=*), intent(in) :: str string with JSON data Description Alternate version of json_parse_string , where \"str\" is kind=CDK. Source Code subroutine wrap_json_parse_string ( p , str ) implicit none type ( json_value ), pointer :: p !! output structure character ( kind = CDK , len =* ), intent ( in ) :: str !! string with JSON data call json_parse_string ( p , to_unicode ( str )) end subroutine wrap_json_parse_string","tags":"","loc":"proc/wrap_json_parse_string.html","title":"wrap_json_parse_string â€“ JSON-Fortran"},{"text":"private  subroutine annotate_invalid_json(iunit, str) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=*), intent(in) :: str string with JSON data Description Generate a warning message if there was an error parsing a JSON file or string. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: line character(kind=CK,len=:), public, allocatable :: arrow_str character(kind=CK,len=10), public :: line_str character(kind=CK,len=10), public :: char_str integer(kind=IK), public :: i integer(kind=IK), public :: i_nl_prev integer(kind=IK), public :: i_nl Source Code subroutine annotate_invalid_json ( iunit , str ) implicit none integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string with JSON data character ( kind = CK , len = :), allocatable :: line , arrow_str character ( kind = CK , len = 10 ) :: line_str , char_str integer ( IK ) :: i , i_nl_prev , i_nl ! !  If there was an error reading the file, then !   print the line where the error occurred: ! if ( exception_thrown ) then !the counters for the current line and the last character read: call integer_to_string ( line_count , line_str ) call integer_to_string ( char_count , char_str ) !draw the arrow string that points to the current character: arrow_str = repeat ( '-' , max ( 0 , char_count - 1 ) ) // '&#94;' if ( line_count > 0 . and . char_count > 0 ) then if ( iunit /= 0 ) then if ( use_unformatted_stream ) then call get_current_line_from_file_stream ( iunit , line ) else call get_current_line_from_file_sequential ( iunit , line ) end if else !get the current line from the string: ! [this is done by counting the newline characters] i_nl_prev = 0 !index of previous newline character i_nl = 2 !just in case line_count = 0 do i = 1 , line_count i_nl = index ( str ( i_nl_prev + 1 :), newline ) if ( i_nl == 0 ) then !last line - no newline character i_nl = len ( str ) + 1 exit end if i_nl = i_nl + i_nl_prev !index of current newline character i_nl_prev = i_nl !update for next iteration end do line = str ( i_nl_prev + 1 : i_nl - 1 ) !extract current line end if else !in this case, it was an empty line or file line = '' end if !create the error message: err_message = err_message // newline // & 'line: ' // trim ( adjustl ( line_str )) // ', ' // & 'character: ' // trim ( adjustl ( char_str )) // newline // & trim ( line ) // newline // arrow_str if ( allocated ( line )) deallocate ( line ) end if end subroutine annotate_invalid_json","tags":"","loc":"proc/annotate_invalid_json.html","title":"annotate_invalid_json â€“ JSON-Fortran"},{"text":"private  subroutine get_current_line_from_file_sequential(iunit, line) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the SEQUENTIAL version (see also get_current_line_from_file_stream ). Variables Type Visibility Attributes Name Initial integer(kind=IK), public, parameter :: n_chunk = 256 character(kind=CDK,len=*), public, parameter :: nfmt = '(A256)' character(kind=CK,len=n_chunk), public :: chunk integer(kind=IK), public :: istat integer(kind=IK), public :: isize Source Code subroutine get_current_line_from_file_sequential ( iunit , line ) implicit none integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ), parameter :: n_chunk = 256 ! chunk size [arbitrary] character ( kind = CDK , len =* ), parameter :: nfmt = '(A256)' ! corresponding format statement character ( kind = CK , len = n_chunk ) :: chunk integer ( IK ) :: istat , isize !initialize: line = '' !rewind to beginning of the current record: backspace ( iunit , iostat = istat ) !loop to read in all the characters in the current record. ![the line is read in chunks until the end of the line is reached] if ( istat == 0 ) then do isize = 0 read ( iunit , fmt = nfmt , advance = 'NO' , size = isize , iostat = istat ) chunk if ( istat == 0 ) then line = line // chunk else if ( isize > 0 . and . isize <= n_chunk ) line = line // chunk ( 1 : isize ) exit end if end do end if end subroutine get_current_line_from_file_sequential","tags":"","loc":"proc/get_current_line_from_file_sequential.html","title":"get_current_line_from_file_sequential â€“ JSON-Fortran"},{"text":"private  subroutine get_current_line_from_file_stream(iunit, line) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: iunit file unit number character(kind=CK,len=:), intent(out), allocatable :: line current line Description Rewind the file to the beginning of the current line, and return this line.\n  The file is assumed to be opened.\n  This is the STREAM version (see also get_current_line_from_file_sequential ). Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istart integer(kind=IK), public :: iend integer(kind=IK), public :: ios character(kind=CK,len=1), public :: c Source Code subroutine get_current_line_from_file_stream ( iunit , line ) implicit none integer ( IK ), intent ( in ) :: iunit !! file unit number character ( kind = CK , len = :), allocatable , intent ( out ) :: line !! current line integer ( IK ) :: istart , iend , ios character ( kind = CK , len = 1 ) :: c !updated for the new STREAM version: istart = ipos do if ( istart <= 1 ) then istart = 1 exit end if read ( iunit , pos = istart , iostat = ios ) c if ( c == newline . or . ios /= 0 ) then if ( istart /= 1 ) istart = istart - 1 exit end if istart = istart - 1 !rewind until the beginning of the line end do iend = ipos do read ( iunit , pos = iend , iostat = ios ) c if ( c == newline . or . ios /= 0 ) exit iend = iend + 1 end do allocate ( character ( kind = CK , len = iend - istart + 1 ) :: line ) read ( iunit , pos = istart , iostat = ios ) line end subroutine get_current_line_from_file_stream","tags":"","loc":"proc/get_current_line_from_file_stream.html","title":"get_current_line_from_file_stream â€“ JSON-Fortran"},{"text":"private recursive subroutine parse_value(unit, str, value) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number character(kind=CK,len=*), intent(in) :: str string containing JSON data (only used if unit=0) type( json_value ), intent(inout), pointer :: value JSON data that is extracted Description Core parsing routine. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c character(kind=CK,len=:), public, allocatable :: tmp Source Code recursive subroutine parse_value ( unit , str , value ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number character ( kind = CK , len =* ), intent ( in ) :: str !! string containing JSON data (only used if unit=0) type ( json_value ), pointer :: value !! JSON data that is extracted logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = :), allocatable :: tmp !this is a work-around for a bug ! in the gfortran 4.9 compiler. if (. not . exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( value )) then call throw_exception ( 'Error in parse_value: value pointer not associated.' ) end if ! pop the next non whitespace character off the file c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then return else select case ( c ) case ( start_object ) ! start object call to_object ( value ) !allocate class call parse_object ( unit , str , value ) case ( start_array ) ! start array call to_array ( value ) !allocate class call parse_array ( unit , str , value ) case ( end_array ) ! end an empty array call push_char ( c ) nullify ( value ) case ( quotation_mark ) ! string call to_string ( value ) !allocate class select case ( value % var_type ) case ( json_string ) call parse_string ( unit , str , tmp ) !write to a tmp variable because of value % str_value = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) ! end select case ( CK_ 't' ) !true_str(1:1) gfortran bug work around !true call parse_for_chars ( unit , str , true_str ( 2 :)) !allocate class and set value: if (. not . exception_thrown ) call to_logical ( value ,. true .) case ( CK_ 'f' ) !false_str(1:1) gfortran bug work around !false call parse_for_chars ( unit , str , false_str ( 2 :)) !allocate class and set value: if (. not . exception_thrown ) call to_logical ( value ,. false .) case ( CK_ 'n' ) !null_str(1:1) gfortran bug work around !null call parse_for_chars ( unit , str , null_str ( 2 :)) if (. not . exception_thrown ) call to_null ( value ) !allocate class case ( CK_ '-' , CK_ '0' : CK_ '9' ) call push_char ( c ) call parse_number ( unit , str , value ) case default call throw_exception ( 'Error in parse_value:' // & ' Unexpected character while parsing value. \"' // & c // '\"' ) end select end if end if end subroutine parse_value","tags":"","loc":"proc/parse_value.html","title":"parse_value â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_logical(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'value' ,. true .) Source Code subroutine json_value_create_logical ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name !! variable name logical ( LK ), intent ( in ) :: val !! variable value call json_value_create ( me ) call to_logical ( me , val , name ) end subroutine json_value_create_logical","tags":"","loc":"proc/json_value_create_logical.html","title":"json_value_create_logical â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_logical(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Wrapper for json_value_create_logical so json_create_logical can\n  be called with name of character kind 'DEFAULT' or 'ISO_10646' Source Code subroutine wrap_json_value_create_logical ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name logical ( LK ), intent ( in ) :: val call json_value_create_logical ( me , val , to_unicode ( name )) end subroutine wrap_json_value_create_logical","tags":"","loc":"proc/wrap_json_value_create_logical.html","title":"wrap_json_value_create_logical â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_integer(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'value' , 1 ) Source Code subroutine json_value_create_integer ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create ( me ) call to_integer ( me , val , name ) end subroutine json_value_create_integer","tags":"","loc":"proc/json_value_create_integer.html","title":"json_value_create_integer â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_integer(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description A wrapper procedure for json_value_create_integer so that json_create_integer may be called with either a 'DEFAULT' or 'ISO_10646' character kind 'name'\n  actual argument. Source Code subroutine wrap_json_value_create_integer ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name integer ( IK ), intent ( in ) :: val call json_value_create_integer ( me , val , to_unicode ( name )) end subroutine wrap_json_value_create_integer","tags":"","loc":"proc/wrap_json_value_create_integer.html","title":"wrap_json_value_create_integer â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_double(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'value' , 1.0 d0 ) Source Code subroutine json_value_create_double ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create ( me ) call to_double ( me , val , name ) end subroutine json_value_create_double","tags":"","loc":"proc/json_value_create_double.html","title":"json_value_create_double â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_double(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description A wrapper for json_value_create_double so that json_create_double may be\n  called with an actual argument corresponding to the dummy argument, 'name'\n  that may be of 'DEFAULT' or 'ISO_10646' character kind. Source Code subroutine wrap_json_value_create_double ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name real ( RK ), intent ( in ) :: val call json_value_create_double ( me , val , to_unicode ( name )) end subroutine wrap_json_value_create_double","tags":"","loc":"proc/wrap_json_value_create_double.html","title":"wrap_json_value_create_double â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_string(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'value' , 'hello' ) Source Code subroutine json_value_create_string ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name character ( kind = CK , len =* ), intent ( in ) :: val call json_value_create ( me ) call to_string ( me , val , name ) end subroutine json_value_create_string","tags":"","loc":"proc/json_value_create_string.html","title":"json_value_create_string â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_string(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: val character(kind=CDK,len=*), intent(in) :: name Description Wrap json_value_create_string so that json_create_string may be called with actual\n  character string arguments for 'name' and 'val' that are BOTH of 'DEFAULT' or\n  'ISO_10646' character kind. Source Code subroutine wrap_json_value_create_string ( me , val , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name character ( kind = CDK , len =* ), intent ( in ) :: val call json_value_create_string ( me , to_unicode ( val ), to_unicode ( name )) end subroutine wrap_json_value_create_string","tags":"","loc":"proc/wrap_json_value_create_string.html","title":"wrap_json_value_create_string â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_null(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'value' ) Source Code subroutine json_value_create_null ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( me ) call to_null ( me , name ) end subroutine json_value_create_null","tags":"","loc":"proc/json_value_create_null.html","title":"json_value_create_null â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_null(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name Description Wrap json_value_create_null so that json_create_null may be called with an actual\n  argument corresponding to the dummy argument 'name' that is either of 'DEFAULT' or\n  'ISO_10646' character kind. Source Code subroutine wrap_json_value_create_null ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_create_null ( me , to_unicode ( name )) end subroutine wrap_json_value_create_null","tags":"","loc":"proc/wrap_json_value_create_null.html","title":"wrap_json_value_create_null â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_object(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'objectname' ) Note The name is not significant for the root structure or an array element.\n      In those cases, an empty string can be used. Source Code subroutine json_value_create_object ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( me ) call to_object ( me , name ) end subroutine json_value_create_object","tags":"","loc":"proc/json_value_create_object.html","title":"json_value_create_object â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_object(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name Description Wrap json_value_create_object so that json_create_object may be called with an actual\n  argument corresponding to the dummy argument 'name' that is of either 'DEFAULT' or\n  'ISO_10646' character kind. Source Code subroutine wrap_json_value_create_object ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_create_object ( me , to_unicode ( name )) end subroutine wrap_json_value_create_object","tags":"","loc":"proc/wrap_json_value_create_object.html","title":"wrap_json_value_create_object â€“ JSON-Fortran"},{"text":"private  subroutine json_value_create_array(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'arrayname' ) Source Code subroutine json_value_create_array ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CK , len =* ), intent ( in ) :: name call json_value_create ( me ) call to_array ( me , name ) end subroutine json_value_create_array","tags":"","loc":"proc/json_value_create_array.html","title":"json_value_create_array â€“ JSON-Fortran"},{"text":"private  subroutine wrap_json_value_create_array(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CDK,len=*), intent(in) :: name Description A wrapper for json_value_create_array so that json_create_array may be called with\n  an actual argument, corresponding to the dummy argument 'name', that is either of\n  'DEFAULT' or 'ISO_10646' character kind. Source Code subroutine wrap_json_value_create_array ( me , name ) implicit none type ( json_value ), pointer :: me character ( kind = CDK , len =* ), intent ( in ) :: name call json_value_create_array ( me , to_unicode ( name )) end subroutine wrap_json_value_create_array","tags":"","loc":"proc/wrap_json_value_create_array.html","title":"wrap_json_value_create_array â€“ JSON-Fortran"},{"text":"private  subroutine to_logical(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me logical(kind=LK), intent(in), optional :: val if the value is also to be set (if not present, then .false. is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a logical. Source Code subroutine to_logical ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me logical ( LK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then .false. is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_logical allocate ( me % log_value ) if ( present ( val )) then me % log_value = val else me % log_value = . false . !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_logical","tags":"","loc":"proc/to_logical.html","title":"to_logical â€“ JSON-Fortran"},{"text":"private  subroutine to_integer(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me integer(kind=IK), intent(in), optional :: val if the value is also to be set (if not present, then 0 is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to an integer. Source Code subroutine to_integer ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me integer ( IK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0 is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_integer allocate ( me % int_value ) if ( present ( val )) then me % int_value = val else me % int_value = 0 !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_integer","tags":"","loc":"proc/to_integer.html","title":"to_integer â€“ JSON-Fortran"},{"text":"private  subroutine to_double(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me real(kind=RK), intent(in), optional :: val if the value is also to be set (if not present, then 0.0_rk is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a double. Source Code subroutine to_double ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me real ( RK ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then 0.0_rk is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_double allocate ( me % dbl_value ) if ( present ( val )) then me % dbl_value = val else me % dbl_value = 0.0_RK !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_double","tags":"","loc":"proc/to_double.html","title":"to_double â€“ JSON-Fortran"},{"text":"private  subroutine to_string(me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me character(kind=CK,len=*), intent(in), optional :: val if the value is also to be set (if not present, then '' is used). character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a string. Modified Izaak Beekman : 02/24/2015 Source Code subroutine to_string ( me , val , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: val !! if the value is also to be set (if not present, then '' is used). character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_string if ( present ( val )) then me % str_value = val else me % str_value = '' !default value end if !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_string","tags":"","loc":"proc/to_string.html","title":"to_string â€“ JSON-Fortran"},{"text":"private  subroutine to_null(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to a null. Source Code subroutine to_null ( me , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_null !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_null","tags":"","loc":"proc/to_null.html","title":"to_null â€“ JSON-Fortran"},{"text":"private  subroutine to_object(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to an object. Source Code subroutine to_object ( me , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_object !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_object","tags":"","loc":"proc/to_object.html","title":"to_object â€“ JSON-Fortran"},{"text":"private  subroutine to_array(me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout) :: me character(kind=CK,len=*), intent(in), optional :: name if the name is also to be changed. Description Change the json_value variable to an array. Source Code subroutine to_array ( me , name ) implicit none type ( json_value ), intent ( inout ) :: me character ( kind = CK , len =* ), intent ( in ), optional :: name !! if the name is also to be changed. !set type and value: call destroy_json_data ( me ) me % var_type = json_array !name: if ( present ( name )) me % name = trim ( name ) end subroutine to_array","tags":"","loc":"proc/to_array.html","title":"to_array â€“ JSON-Fortran"},{"text":"private recursive subroutine parse_object(unit, str, parent) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), intent(inout), pointer :: parent the parsed object will be added as a child of this Description Core parsing routine. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: pair logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c character(kind=CK,len=:), public, allocatable :: tmp this is a work-around for a bug\n in the gfortran 4.9 compiler. Source Code recursive subroutine parse_object ( unit , str , parent ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: parent !! the parsed object will be added as a child of this type ( json_value ), pointer :: pair logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c character ( kind = CK , len = :), allocatable :: tmp !! this is a work-around for a bug !! in the gfortran 4.9 compiler. if (. not . exception_thrown ) then !the routine is being called incorrectly. if (. not . associated ( parent )) then call throw_exception ( 'Error in parse_object: parent pointer not associated.' ) end if nullify ( pair ) !probably not necessary ! pair name c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing start of object.' ) return else if ( end_object == c ) then ! end of an empty object return else if ( quotation_mark == c ) then call json_value_create ( pair ) call parse_string ( unit , str , tmp ) !write to a tmp variable because of pair % name = tmp ! a bug in 4.9 gfortran compiler. deallocate ( tmp ) if ( exception_thrown ) then call json_destroy ( pair ) return end if else call throw_exception ( 'Error in parse_object: Expecting string: \"' // c // '\"' ) return end if ! pair value c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_object:' // & ' Unexpected end of file while parsing object member.' ) return else if ( colon_char == c ) then ! parse the value call parse_value ( unit , str , pair ) if ( exception_thrown ) then call json_destroy ( pair ) return else call json_add ( parent , pair ) end if else call throw_exception ( 'Error in parse_object:' // & ' Expecting : and then a value: ' // c ) return end if ! another possible pair c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_object: ' // & 'End of file encountered when parsing an object' ) return else if ( delimiter == c ) then ! read the next member call parse_object ( unit = unit , str = str , parent = parent ) else if ( end_object == c ) then ! end of object return else call throw_exception ( 'Error in parse_object: Expecting end of object: ' // c ) return end if end if end subroutine parse_object","tags":"","loc":"proc/parse_object.html","title":"parse_object â€“ JSON-Fortran"},{"text":"private recursive subroutine parse_array(unit, str, array) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), intent(inout), pointer :: array Description Core parsing routine. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: element logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c Source Code recursive subroutine parse_array ( unit , str , array ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: array type ( json_value ), pointer :: element logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c do if ( exception_thrown ) exit ! try to parse an element value nullify ( element ) call json_value_create ( element ) call parse_value ( unit , str , element ) if ( exception_thrown ) then if ( associated ( element )) call json_destroy ( element ) exit end if ! parse value will disassociate an empty array value if ( associated ( element )) call json_add ( array , element ) ! popped the next character c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then ! The file ended before array was finished: call throw_exception ( 'Error in parse_array: ' // & 'End of file encountered when parsing an array.' ) exit else if ( delimiter == c ) then ! parse the next element cycle else if ( end_array == c ) then ! end of array exit else call throw_exception ( 'Error in parse_array: ' // & 'Unexpected character encountered when parsing array.' ) exit end if end do end subroutine parse_array","tags":"","loc":"proc/parse_array.html","title":"parse_array â€“ JSON-Fortran"},{"text":"private  subroutine parse_string(unit, str, string) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=:), intent(out), allocatable :: string Description Parses a string while reading a JSON file. History Jacob Williams : 6/16/2014 : Added hex validation. Variables Type Visibility Attributes Name Initial logical(kind=LK), public :: eof logical(kind=LK), public :: is_hex logical(kind=LK), public :: escape character(kind=CK,len=1), public :: c character(kind=CK,len=1), public :: last character(kind=CK,len=4), public :: hex integer(kind=IK), public :: i integer(kind=IK), public :: ip index to put next character,\n to speed up by reducing the number of character string reallocations. Source Code subroutine parse_string ( unit , str , string ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len = :), allocatable , intent ( out ) :: string logical ( LK ) :: eof , is_hex , escape character ( kind = CK , len = 1 ) :: c , last character ( kind = CK , len = 4 ) :: hex integer ( IK ) :: i integer ( IK ) :: ip !! index to put next character, !! to speed up by reducing the number of character string reallocations. !at least return a blank string if there is a problem: string = repeat ( space , chunk_size ) if (. not . exception_thrown ) then !initialize: ip = 1 last = space is_hex = . false . escape = . false . i = 0 do !get the next character from the file: c = pop_char ( unit , str = str , eof = eof , skip_ws = . false .) if ( eof ) then call throw_exception ( 'Error in parse_string: Expecting end of string' ) return else if ( c == quotation_mark . and . last /= backslash ) then if ( is_hex ) call throw_exception ( 'Error in parse_string:' // & ' incomplete hex string: \\u' // trim ( hex )) exit else !if the string is not big enough, then add another chunk: if ( ip > len ( string )) string = string // repeat ( space , chunk_size ) !append to string: string ( ip : ip ) = c ip = ip + 1 !hex validation: if ( is_hex ) then !accumulate the four characters after '\\u' i = i + 1 hex ( i : i ) = c if ( i == 4 ) then if ( valid_json_hex ( hex )) then i = 0 hex = '' is_hex = . false . else call throw_exception ( 'Error in parse_string:' // & ' invalid hex string: \\u' // trim ( hex )) exit end if end if else !when the '\\u' string is encountered, then !  start accumulating the hex string (should be the next 4 characters) if ( escape ) then escape = . false . is_hex = ( c == 'u' ) !the next four characters are the hex string else escape = ( c == backslash ) end if end if !update for next char: last = c end if end do !trim the string if necessary: if ( ip < len ( string ) + 1 ) then if ( ip == 1 ) then string = '' else string = string ( 1 : ip - 1 ) end if end if end if end subroutine parse_string","tags":"","loc":"proc/parse_string.html","title":"parse_string â€“ JSON-Fortran"},{"text":"private  subroutine parse_for_chars(unit, str, chars) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) character(kind=CK,len=*), intent(in) :: chars the string to check for. Description Core parsing routine. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: i integer(kind=IK), public :: length logical(kind=LK), public :: eof character(kind=CK,len=1), public :: c Source Code subroutine parse_for_chars ( unit , str , chars ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) character ( kind = CK , len =* ), intent ( in ) :: chars !! the string to check for. integer ( IK ) :: i , length logical ( LK ) :: eof character ( kind = CK , len = 1 ) :: c if (. not . exception_thrown ) then length = len_trim ( chars ) do i = 1 , length c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected end of file while parsing array.' ) return else if ( c /= chars ( i : i )) then call throw_exception ( 'Error in parse_for_chars:' // & ' Unexpected character.: \"' // c // '\" ' // chars ( i : i )) return end if end do end if end subroutine parse_for_chars","tags":"","loc":"proc/parse_for_chars.html","title":"parse_for_chars â€“ JSON-Fortran"},{"text":"private  subroutine parse_number(unit, str, value) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: unit file unit number (if parsing from a file) character(kind=CK,len=*), intent(in) :: str JSON string (if parsing from a string) type( json_value ), intent(inout), pointer :: value Description Read a numerical value from the file (or string).\n  The routine will determine if it is an integer or a double, and\n  allocate the type accordingly. Note Complete rewrite of the original FSON routine, which had some problems. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: tmp character(kind=CK,len=1), public :: c logical(kind=LK), public :: eof real(kind=RK), public :: rval integer(kind=IK), public :: ival logical(kind=LK), public :: first logical(kind=LK), public :: is_integer integer(kind=IK), public :: ip Source Code subroutine parse_number ( unit , str , value ) implicit none integer ( IK ), intent ( in ) :: unit !! file unit number (if parsing from a file) character ( kind = CK , len =* ), intent ( in ) :: str !! JSON string (if parsing from a string) type ( json_value ), pointer :: value character ( kind = CK , len = :), allocatable :: tmp character ( kind = CK , len = 1 ) :: c logical ( LK ) :: eof real ( RK ) :: rval integer ( IK ) :: ival logical ( LK ) :: first logical ( LK ) :: is_integer !to speed up by reducing the number of character string reallocations: integer ( IK ) :: ip !index to put next character if (. not . exception_thrown ) then tmp = repeat ( space , chunk_size ) ip = 1 first = . true . is_integer = . true . !assume it may be an integer, unless otherwise determined !read one character at a time and accumulate the string: do !get the next character: c = pop_char ( unit , str = str , eof = eof , skip_ws = . true .) if ( eof ) then call throw_exception ( 'Error in parse_number:' // & ' Unexpected end of file while parsing number.' ) return else select case ( c ) case ( CK_ '-' , CK_ '+' ) !note: allowing a '+' as the first character here. if ( is_integer . and . (. not . first )) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '.' , CK_ 'E' , CK_ 'e' ) !can be present in real numbers if ( is_integer ) is_integer = . false . !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case ( CK_ '0' : CK_ '9' ) !valid characters for numbers !add it to the string: !tmp = tmp // c   !...original if ( ip > len ( tmp )) tmp = tmp // repeat ( space , chunk_size ) tmp ( ip : ip ) = c ip = ip + 1 case default !push back the last character read: call push_char ( c ) !string to value: if ( is_integer ) then ival = string_to_integer ( tmp ) call to_integer ( value , ival ) else rval = string_to_double ( tmp ) call to_double ( value , rval ) end if exit !finished end select end if if ( first ) first = . false . end do !cleanup: if ( allocated ( tmp )) deallocate ( tmp ) end if end subroutine parse_number","tags":"","loc":"proc/parse_number.html","title":"parse_number â€“ JSON-Fortran"},{"text":"private  subroutine push_char(c) Arguments Type Intent Optional Attributes Name character(kind=CK,len=1), intent(in) :: c Description Core routine. See also pop_char History Jacob Williams : 5/3/2015 : replaced original version of this routine. Variables Type Visibility Attributes Name Initial character(kind=CK,len=max_numeric_str_len), public :: istr Source Code subroutine push_char ( c ) implicit none character ( kind = CK , len = 1 ), intent ( in ) :: c character ( kind = CK , len = max_numeric_str_len ) :: istr if (. not . exception_thrown ) then if ( use_unformatted_stream ) then !in this case, c is ignored, and we just !decrement the stream position counter: ipos = ipos - 1 else pushed_index = pushed_index + 1 if ( pushed_index > 0 . and . pushed_index <= len ( pushed_char )) then pushed_char ( pushed_index : pushed_index ) = c else call integer_to_string ( pushed_index , istr ) call throw_exception ( 'Error in push_char: ' // & 'invalid valid of pushed_index: ' // trim ( istr )) end if end if end if end subroutine push_char","tags":"","loc":"proc/push_char.html","title":"push_char â€“ JSON-Fortran"},{"text":"private pure subroutine integer_to_string(ival, str) Arguments Type Intent Optional Attributes Name integer(kind=IK), intent(in) :: ival integer value. character(kind=CK,len=*), intent(out) :: str ival converted to a string. Description Convert an integer to a string. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istat Source Code pure subroutine integer_to_string ( ival , str ) implicit none integer ( IK ), intent ( in ) :: ival !! integer value. character ( kind = CK , len =* ), intent ( out ) :: str !! ival converted to a string. integer ( IK ) :: istat write ( str , fmt = int_fmt , iostat = istat ) ival if ( istat == 0 ) then str = adjustl ( str ) else str = repeat ( star , len ( str )) end if end subroutine integer_to_string","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string â€“ JSON-Fortran"},{"text":"private  subroutine real_to_string(rval, str) Arguments Type Intent Optional Attributes Name real(kind=RK), intent(in) :: rval real value. character(kind=CK,len=*), intent(out) :: str rval converted to a string. Description Convert a real value to a string. Modified Izaak Beekman : 02/24/2015 : added the compact option. Variables Type Visibility Attributes Name Initial integer(kind=IK), public :: istat Source Code subroutine real_to_string ( rval , str ) implicit none real ( RK ), intent ( in ) :: rval !! real value. character ( kind = CK , len =* ), intent ( out ) :: str !! rval converted to a string. integer ( IK ) :: istat !default format: write ( str , fmt = real_fmt , iostat = istat ) rval if ( istat == 0 ) then !in this case, the default string will be compacted, ! so that the same value is displayed with fewer characters. if ( compact_real ) call compact_real_string ( str ) else str = repeat ( star , len ( str )) end if end subroutine real_to_string","tags":"","loc":"proc/real_to_string.html","title":"real_to_string â€“ JSON-Fortran"},{"text":"private  subroutine compact_real_string(str) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(inout) :: str string representation of a real number. Description Compact a string representing a real number, so that\n  the same value is displayed with fewer characters. See also real_to_string Variables Type Visibility Attributes Name Initial character(kind=CK,len=len(str)), public :: significand character(kind=CK,len=len(str)), public :: expnt character(kind=CK,len=2), public :: separator integer(kind=IK), public :: exp_start integer(kind=IK), public :: decimal_pos integer(kind=IK), public :: sig_trim integer(kind=IK), public :: exp_trim integer(kind=IK), public :: i Source Code subroutine compact_real_string ( str ) implicit none character ( kind = CK , len =* ), intent ( inout ) :: str !! string representation of a real number. character ( kind = CK , len = len ( str )) :: significand , expnt character ( kind = CK , len = 2 ) :: separator integer ( IK ) :: exp_start , decimal_pos , sig_trim , exp_trim , i str = adjustl ( str ) exp_start = scan ( str , CK_ 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( str , CK_ '-+' , back = . true .) decimal_pos = scan ( str , CK_ '.' ) if ( exp_start /= 0 ) separator = str ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then !possibly signed, exponent-less float significand = str sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s !but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do str = trim ( significand ( 1 : sig_trim )) else if ( exp_start > decimal_pos ) then !float has exponent significand = str ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 !look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit end if end do expnt = adjustl ( str ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( str ( exp_start + 1 :)) end if exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) !look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit end if end do str = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable end if end subroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string â€“ JSON-Fortran"},{"text":"public  subroutine json_print_error_message(io_unit) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: io_unit Description Print any error message, and then clear the exceptions. Note This routine is used by the unit tests.\n      It was originally in json_example.f90, and was\n      moved here 2/26/2015 by Izaak Beekman. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: error_msg logical, public :: status_ok Source Code subroutine json_print_error_message ( io_unit ) implicit none integer , intent ( in ), optional :: io_unit character ( kind = CK , len = :), allocatable :: error_msg logical :: status_ok !get error message: call json_check_for_errors ( status_ok , error_msg ) !print it if there is one: if (. not . status_ok ) then if ( present ( io_unit )) then write ( io_unit , '(A)' ) error_msg else write ( * , '(A)' ) error_msg end if deallocate ( error_msg ) call json_clear_exceptions () end if end subroutine json_print_error_message","tags":"","loc":"proc/json_print_error_message.html","title":"json_print_error_message â€“ JSON-Fortran"},{"text":"private interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object Example ... type ( json_file ) :: my_file type ( json_value ) :: json_object ... ! Construct a json_object my_file = json_file ( json_object ) Module Procedures private  function initialize_json_file (p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object Return Value type( json_file ) Description Cast a json_value object as a json_file object","tags":"","loc":"interface/json_file.html","title":"json_file â€“ JSON-Fortran"},{"text":"public interface json_get_child Get a child, either by index or name string.\n  Both of these return a json_value pointer. Note Formerly, this was called json_value_get_child Module Procedures private  subroutine json_value_get_by_index (me, idx, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), intent(inout), pointer :: p pointer to the child Description Returns a child in the object or array given the index. private  subroutine json_value_get_by_name_chars (me, name, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: name the name of a child of \"me\" type( json_value ), intent(inout), pointer :: p pointer to the child Description Returns a child in the object or array given the name string.","tags":"","loc":"interface/json_get_child.html","title":"json_get_child â€“ JSON-Fortran"},{"text":"public interface json_add Add objects to a linked list of json_value s. Note Formerly, this was called json_value_add Module Procedures private  subroutine json_value_add_member (me, member) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me type( json_value ), intent(inout), pointer :: member the child member to add Description Adds \"member\" as a child of \"me\". private  subroutine json_value_add_integer (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Add an integer value child to the json_value variable private  subroutine json_value_add_integer_vec (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Add an integer vector to the structure. private  subroutine json_value_add_double (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Add a real value child to the json_value variable private  subroutine json_value_add_double_vec (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Add a real vector to the structure. private  subroutine json_value_add_logical (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Add a logical value child to the json_value variable private  subroutine json_value_add_logical_vec (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Add a logical vector to the structure. private  subroutine json_value_add_string (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Add a character string child to the json_value variable. private  subroutine json_value_add_string_vec (me, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Add an array of character strings to the structure.","tags":"","loc":"interface/json_add.html","title":"json_add â€“ JSON-Fortran"},{"text":"public interface json_update These are like json_add , except if a child with the same name is\n  already present, then its value is simply updated.\n  Note that currently, these only work for scalar variables.\n  These routines can also change the variable's type (but an error will be\n  thrown if the existing variable is not a scalar). Note It should not be used to change the type of a variable in an array,\n      or it may result in an invalid JSON file. Module Procedures private  subroutine json_update_logical (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_update_double (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_update_integer (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_update_string (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value.","tags":"","loc":"interface/json_update.html","title":"json_update â€“ JSON-Fortran"},{"text":"public interface json_get Get data from a json_value linked list. Note There are two versions (e.g. json_get_integer and json_get_integer_with_path ).\n      The first one gets the value from the json_value passed into the routine,\n      while the second one gets the value from the json_value found by parsing the\n      path.  The path version is split up into unicode and non-unicode versions. Module Procedures private  subroutine json_get_by_path (me, path, p, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. private  subroutine json_get_integer (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . private  subroutine json_get_integer_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. private  subroutine json_get_integer_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Get an integer vector from a json_value . private  subroutine json_get_integer_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. private  subroutine json_get_double (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . private  subroutine json_get_double_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. private  subroutine json_get_double_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Get a double vector from a json_value . private  subroutine json_get_double_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. private  subroutine json_get_logical (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(inout) :: value Description Get a logical value from a json_value . private  subroutine json_get_logical_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(inout) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. private  subroutine json_get_logical_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Get a logical vector from json_value . private  subroutine json_get_logical_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. private  subroutine json_get_string (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . private  subroutine json_get_string_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. private  subroutine json_get_string_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Get a string vector from a json_file . private  subroutine json_get_string_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_file , given the path. private  subroutine json_get_array (me, array_callback) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me procedure( array_callback_func ), intent(inout) :: array_callback Description This routine calls the user-supplied array_callback_func subroutine\n      for each element in the array. private  subroutine json_get_array_with_path (me, path, array_callback, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( array_callback_func ), intent(inout) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path).","tags":"","loc":"interface/json_get.html","title":"json_get â€“ JSON-Fortran"},{"text":"public interface json_print_to_string Print the json_value structure to an allocatable string. Module Procedures private  subroutine json_value_to_string (me, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Description Print the json_value structure to an allocatable string.","tags":"","loc":"interface/json_print_to_string.html","title":"json_print_to_string â€“ JSON-Fortran"},{"text":"public interface json_print Print the json_value to a file. Example type ( json_value ) :: p !... call json_print ( p , 'test.json' ) !this is json_print_2 Module Procedures private  subroutine json_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Print the json_value structure to a file. private  subroutine json_print_2 (me, filename) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Print the json_value structure to a file.","tags":"","loc":"interface/json_print.html","title":"json_print â€“ JSON-Fortran"},{"text":"public interface json_destroy Destructor routine for a json_value pointer.\n  This must be called explicitly if it is no longer needed,\n  before it goes out of scope.  Otherwise, a memory leak will result. Example Destroy the json_value pointer before the variable goes out of scope: subroutine example1 () type ( json_value ), pointer :: p call json_create_object ( p , '' ) call json_add ( p , 'year' , 2015 ) call json_print ( p ) call json_destroy ( p ) end subroutine example1 Note: it should NOT be called for a json_value pointer than has already been\n  added to another json_value structure, since doing so may render the\n  other structure invalid.  Consider the following example: subroutine example2 ( p ) type ( json_value ), pointer , intent ( out ) :: p type ( json_value ), pointer :: q call json_create_object ( p , '' ) call json_add ( p , 'year' , 2015 ) call json_create_object ( q , 'q' ) call json_add ( q , 'val' , 1 ) call json_add ( p , q ) !add q to p structure ! do NOT call json_destroy(q) here, because q is ! now part of the output structure p.  p should be destroyed ! somewhere upstream by the caller of this routine. nullify ( q ) !OK, but not strictly necessary end subroutine example2 Module Procedures private recursive subroutine json_value_destroy (me, destroy_next) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in), optional :: destroy_next if true, then me%next is also destroyed (default is true) Description Destroy a json_value linked-list structure.","tags":"","loc":"interface/json_destroy.html","title":"json_destroy â€“ JSON-Fortran"},{"text":"public interface json_remove Remove a json_value from a linked-list structure. Module Procedures private  subroutine json_value_remove (me, destroy) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Description Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure.","tags":"","loc":"interface/json_remove.html","title":"json_remove â€“ JSON-Fortran"},{"text":"public interface json_remove_if_present If the child variable is present, then remove it. Module Procedures private  subroutine json_value_remove_if_present (p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name Description Given the path string, remove the variable from\n  the json_value structure, if it exists.","tags":"","loc":"interface/json_remove_if_present.html","title":"json_remove_if_present â€“ JSON-Fortran"},{"text":"public interface json_create_double Allocate a json_value pointer and make it a double variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create_double ( p , 'value' , 1.0 d0 ) Module Procedures private  subroutine json_value_create_double (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_double.html","title":"json_create_double â€“ JSON-Fortran"},{"text":"public interface json_create_array Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'arrayname' ) Module Procedures private  subroutine json_value_create_array (me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_array.html","title":"json_create_array â€“ JSON-Fortran"},{"text":"public interface json_create_object Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create ( p , 'objectname' ) Note The name is not significant for the root structure or an array element.\n      In those cases, an empty string can be used. Module Procedures private  subroutine json_value_create_object (me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_object.html","title":"json_create_object â€“ JSON-Fortran"},{"text":"public interface json_create_null Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create_null ( p , 'value' ) Module Procedures private  subroutine json_value_create_null (me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_null.html","title":"json_create_null â€“ JSON-Fortran"},{"text":"public interface json_create_string Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create_string ( p , 'value' , 'foobar' ) Module Procedures private  subroutine json_value_create_string (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_string.html","title":"json_create_string â€“ JSON-Fortran"},{"text":"public interface json_create_integer Allocate a json_value pointer and make it an integer variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create_integer ( p , 'value' , 42 ) Module Procedures private  subroutine json_value_create_integer (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_integer.html","title":"json_create_integer â€“ JSON-Fortran"},{"text":"public interface json_create_logical Allocate a json_value pointer and make it a logical variable.\n  The pointer should not already be allocated. Example type ( json_value ), pointer :: p call json_create_logical ( p , 'value' ,. true .) Module Procedures private  subroutine json_value_create_logical (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated.","tags":"","loc":"interface/json_create_logical.html","title":"json_create_logical â€“ JSON-Fortran"},{"text":"public interface json_parse Parse the JSON file and populate the json_value tree. Module Procedures private  subroutine json_parse_file (file, p, unit) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), intent(inout), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. private  subroutine json_parse_string (p, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree.","tags":"","loc":"interface/json_parse.html","title":"json_parse â€“ JSON-Fortran"},{"text":"public interface to_unicode Convert a 'DEFAULT' kind character input to 'ISO_10646' kind and return it Module Procedures private pure function to_uni (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Convert string to unicode (CDK to CK). private pure function to_uni_vec (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Description Convert array of strings to unicode (CDK to CK).","tags":"","loc":"interface/to_unicode.html","title":"to_unicode â€“ JSON-Fortran"},{"text":"private interface throw_exception Throw an exception. Module Procedures private  subroutine json_throw_exception (msg) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: msg Description Throw an exception in the JSON module.\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called.","tags":"","loc":"interface/throw_exception.html","title":"throw_exception â€“ JSON-Fortran"},{"text":"public  subroutine test_1(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read a sample JSON file and retrieve some data from it Variables Type Visibility Attributes Name Initial type( json_file ), public :: json integer, public :: ival character(kind=CK,len=:), public, allocatable :: cval real(kind=wp), public :: rval logical, public :: found type( json_value ), public, pointer :: p Source Code subroutine test_1 ( error_cnt ) !! Read a sample JSON file and retrieve some data from it implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval logical :: found type ( json_value ), pointer :: p error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 1' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file ' // dir // filename1 call json % load_file ( filename = dir // filename1 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the file...' write ( output_unit , '(A)' ) '{ \"part a\" :' !Wrap 3 outputs to make stdout valid json call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'get some data from the file...' write ( error_unit , '(A)' ) '' call json % get ( 'version.svn' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,I5)' ) 'version.svn = ' , ival end if write ( error_unit , '(A)' ) '' call json % get ( 'data(1).array(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'data(1).array(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(1)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(1) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(2)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(2) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files(3)' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files(3) = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'data(2).real' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,E30.16)' ) 'data(2).real = ' , rval end if write ( error_unit , '(A)' ) '' call json % get ( 'files[4]' , cval ) !has hex characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[4] = ' // trim ( cval ) end if write ( error_unit , '(A)' ) '' call json % get ( 'files[5]' , cval ) !string with spaces and no escape characters if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'files[5] = ' // trim ( cval ) end if ! ! Test of values that aren't there: ! Note: when using the \"found\" output, the exceptions are cleared automatically. ! write ( error_unit , '(A)' ) '' call json % get ( 'files[10]' , cval , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'files[10] not in file.' else write ( error_unit , '(1x,A)' ) 'files[10] = ' // trim ( cval ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' call json % get ( 'version.blah' , ival , found ) !value that isn't there if (. not . found ) then write ( error_unit , '(A)' ) 'version.blah not in file.' else write ( error_unit , '(A)' ) 'version.blah = ' , ival error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test removing data from the json structure:' call json % get ( 'files' , p ) !in the middle of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(1).array' , p ) !at the end of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json % get ( 'data(2).number' , p ) !at the beginning of a list call json_remove ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part b\" : ' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' Test replacing data from the json structure:' call json % get ( 'data(1)' , p ) call json_update ( p , 'name' , 'Cuthbert' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !call json%get('data(2)', p) !call json_update(p,'real',[1.0_wp, 2.0_wp, 3.0_wp],found)   !don't have one like this yet... !use the json_file procedure to update a variable: call json % update ( 'version.svn' , 999 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'printing the modified structure...' write ( output_unit , '(A)' ) ', \"part c\" : ' call json % print_file () write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_1","tags":"","loc":"proc/test_1.html","title":"test_1 â€“ JSON-Fortran"},{"text":"public  subroutine test_10(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Test some of the lesser-used features of the library Variables Type Visibility Attributes Name Initial character(kind=CK,len=256), public, dimension(:), allocatable :: str_vec type( json_file ), public :: f type( json_file ), public :: f2 type( json_value ), public, pointer :: p character(kind=CK,len=:), public, allocatable :: str character(kind=CK,len=:), public, allocatable :: name logical, public :: found logical, public :: lval integer, public :: var_type integer, public :: n_children character(kind=CDK,len=*), public, parameter :: json_str = '{ \"blah\": 123 }' Source Code subroutine test_10 ( error_cnt ) !! Test some of the lesser-used features of the library implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = 256 ), dimension (:), allocatable :: str_vec type ( json_file ) :: f , f2 type ( json_value ), pointer :: p character ( kind = CK , len = :), allocatable :: str , name logical :: found , lval integer :: var_type , n_children character ( kind = CDK , len =* ), parameter :: json_str = '{ \"blah\": 123 }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 10 ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) // '...' call f % load_file ( dir // filename ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_move_pointer...' call f2 % move ( f ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_load_from_string...' call f % load_from_string ( json_str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_print_to_string...' call f % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_variable_info...' call f % info ( 'blah' , found , var_type , n_children ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( var_type == json_integer . and . n_children == 0 ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error invalid values:' , var_type , n_children error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_get_logical...' call f2 % get ( 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . lval ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result.' error_cnt = error_cnt + 1 end if end if ! json_file_get_logical_vec .... [add this] write ( error_unit , '(A)' ) 'json_file_get_string_vec...' call f2 % get ( 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable present]...' call f2 % update ( 'data(1).tf1' ,. false ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_logical [variable not present]...' call f2 % update ( 'new_logical' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_real [variable present]...' call f2 % update ( 'data[2].real' , 10 0.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_real [variable not present]...' call f2 % update ( 'new_real' , 177 6.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_file_update_string [variable present]...' call f2 % update ( 'version.string' , '10.0.0' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_file_update_string [variable not present]...' call f2 % update ( 'new_string' , 'foo' , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'json_file_get_integer...' call f2 % get ( '$' , p , found ) !get root if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' write ( error_unit , '(A)' ) 'json_info...' call json_info ( p , var_type , n_children , name ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if write ( error_unit , '(A)' ) 'json_remove_if_present...' call json_remove_if_present ( p , 'version.patch' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_logical...' call json_update ( p , 'data(1).tf1' ,. true ., found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_update_double...' call json_update ( p , 'data(2).real' , - 1.0 d0 , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_logical...' call json_get ( p , 'data(1).tf1' , lval , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else if ( found ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: variable was not there.' error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_get_string_vec...' call json_get ( p , 'files' , str_vec , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else !also make sure the values are correct: if ( found . and . size ( str_vec ) == 5 . and . & str_vec ( 1 ) == '..\\path\\to\\files\\file1.txt' ) then write ( error_unit , '(A)' ) '...success' else write ( error_unit , '(A)' ) 'Error: incorrect result: ' // trim ( str_vec ( 1 )) error_cnt = error_cnt + 1 end if end if write ( error_unit , '(A)' ) 'json_create...' write ( error_unit , '(A)' ) 'json_create_logical...' ; call json_destroy ( p ); call json_create_logical ( p ,. true ., 'foo' ) write ( error_unit , '(A)' ) 'json_create_integer...' ; call json_destroy ( p ); call json_create_integer ( p , 1000 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_double ...' ; call json_destroy ( p ); call json_create_double ( p , 9.0 d0 , 'foo' ) write ( error_unit , '(A)' ) 'json_create_string ...' ; call json_destroy ( p ); call json_create_string ( p , 'foo' , 'bar' ) write ( error_unit , '(A)' ) 'json_create_null   ...' ; call json_destroy ( p ); call json_create_null ( p , 'foo' ) write ( error_unit , '(A)' ) 'json_create_object ...' ; call json_destroy ( p ); call json_create_object ( p , 'foo' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '...success' end if !-------------------------------- !cleanup: !call f%destroy()   !WARNING: causing \"pointer being freed was not allocated\" errors.... need to investigate !call f2%destroy() end subroutine test_10","tags":"","loc":"proc/test_10.html","title":"test_10 â€“ JSON-Fortran"},{"text":"public  subroutine test_11(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file and extract some data from it. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: cval type( json_file ), public :: json Source Code subroutine test_11 ( error_cnt ) !! Read the file and extract some data from it. implicit none integer , intent ( out ) :: error_cnt character ( kind = CK , len = :), allocatable :: cval type ( json_file ) :: json !the JSON structure read from the file: # ifdef USE_UCS4 type ( json_file ) :: clone # endif error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 11' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' # ifdef USE_UCS4 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // unicode_file call json % load_file ( filename = dir // unicode_file ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' call clone % load_from_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call clone % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // unicode_file // '\"' call clone % print_file ( '../files/' // unicode_file ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call clone % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if # endif ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // ascii_equivalent write ( error_unit , '(A)' ) 'This is the ascii equivalent of \"../files/inputs/hello-world-ucs4.json\"' call json % load_file ( filename = dir // ascii_equivalent ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' write ( error_unit , '(A)' ) '' call json % get ( 'UCS4 support?' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'UCS4 support? ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Amharic' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Amharic : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Portuguese' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Portuguese : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Russian' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Russian : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Hebrew' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Hebrew : ' // cval end if write ( error_unit , '(A)' ) '' call json % get ( 'hello world.Urdu' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'hello world.Urdu : ' // cval end if write ( error_unit , '(A)' ) '' call json % print_to_string ( cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'The contents of the file were:' write ( error_unit , '(A)' ) cval end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Printing same file, but now to stdout:' call json % print_file ( output_unit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Writing json file object to \"../files/' // ascii_equivalent // '\"' call json % print_file ( '../files/' // ascii_equivalent ) if ( json_failed () ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_11","tags":"","loc":"proc/test_11.html","title":"test_11 â€“ JSON-Fortran"},{"text":"public  subroutine test_12(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Variables Type Visibility Attributes Name Initial integer, public, parameter :: imx = 5 integer, public, parameter :: jmx = 3 integer, public, parameter :: kmx = 4 dimensions for raw work array of primitive type integer, public, dimension(3) :: shape shape of work array integer, public, dimension(:), allocatable :: fetched_shape retrieved shape type( json_value ), public, pointer :: root type( json_value ), public, pointer :: meta_array json nodes to work with type( json_value ), public, pointer :: tmp_json_ptr type( json_file ), public :: my_file real(kind=wp), public, dimension(imx,jmx,kmx) :: raw_array raw work array real(kind=wp), public :: array_element real(kind=wp), public, dimension(:), allocatable :: fetched_array character(kind=CK,len=:), public, allocatable :: description integer, public :: i integer, public :: j integer, public :: k loop indices integer, public :: array_length integer, public :: lun logical, public :: existed logical, public, dimension(:), allocatable :: SOS Subroutines subroutine check_errors(assertion) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: assertion subroutine get_3D_from_array(element, i, count) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: element integer, intent(in) :: i index integer, intent(in) :: count size of array Source Code subroutine test_12 ( error_cnt ) implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller integer , parameter :: imx = 5 , jmx = 3 , kmx = 4 !! dimensions for raw work array of primitive type integer , dimension ( 3 ) :: shape !! shape of work array integer , dimension (:), allocatable :: fetched_shape !! retrieved shape type ( json_value ), pointer :: root , meta_array !! json nodes to work with type ( json_value ), pointer :: tmp_json_ptr type ( json_file ) :: my_file real ( wp ), dimension ( imx , jmx , kmx ) :: raw_array !! raw work array real ( wp ) :: array_element real ( wp ), dimension (:), allocatable :: fetched_array character ( kind = CK , len = :), allocatable :: description integer :: i , j , k !! loop indices integer :: array_length , lun logical :: existed logical , dimension (:), allocatable :: SOS error_cnt = 0 call json_initialize ( verbose = . true ., real_format = 'G' ) call check_errors () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 12' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! populate the raw array forall ( i = 1 : imx , j = 1 : jmx , k = 1 : kmx ) ! could use size(... , dim=...) instead of constants raw_array ( i , j , k ) = i + ( j - 1 ) * imx + ( k - 1 ) * imx * jmx end forall call json_create_object ( root , dir // file ) call check_errors () call json_create_object ( meta_array , 'array data' ) call check_errors () shape = [ size ( raw_array , dim = 1 ), size ( raw_array , dim = 2 ), size ( raw_array , dim = 3 )] call json_add ( meta_array , 'shape' , shape ) call check_errors () call json_add ( meta_array , 'total size' , size ( raw_array )) call check_errors () call json_update ( meta_array , 'total size' , size ( raw_array ), found = existed ) call check_errors ( existed ) call json_add ( meta_array , CK_ 'description' , 'test data' ) call check_errors () ! now add the array ! N.B. `json_add()` only accepts 1-D arrays and scalars, so transform with `reshape` ! N.B. reshape populates new array in \"array element order\". ! C.F. \"Modern Fortran Explained\", by Metcalf, Cohen and Reid, p. 24. ! N.B. Fortran is a column major language call json_add ( meta_array , 'data' , reshape ( raw_array , [ size ( raw_array ) ] ) ) call check_errors () ! now put it all together call json_add ( root , meta_array ) call check_errors () write ( error_unit , '(A)' ) \"Print the JSON object to stderr:\" call json_print ( root , error_unit ) call check_errors () call json_get ( root , '$.array data.data(1)' , array_element ) call check_errors ( abs ( array_element - 1.0_wp ) <= TOL ) call json_get ( root , '@.array data.shape' , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_update ( meta_array , 'description' , CK_ 'Test Data' , found = existed ) call check_errors ( existed ) call json_update ( meta_array , CK_ 'description' , 'Test data' , found = existed ) call check_errors ( existed ) call json_get ( meta_array , 'description' , description ) call check_errors ( 'Test data' == description ) call json_get ( root , 'array data.total size' , array_length ) call check_errors ( array_length == imx * jmx * kmx ) sos = [. true ., . true ., . true ., & . false ., . false ., . false ., & . true ., . true ., . true .] call json_add ( root , 'SOS' , sos ) call check_errors () call json_get ( root , 'SOS' , sos ) call check_errors () call json_add ( root , 'vector string' , [ CK_ 'only one value' ]) call check_errors () call json_add ( root , CK_ 'page' , [ 'The quick brown fox     ' , 'jumps over the lazy dog.' ]) call check_errors () call json_get ( root , 'SOS' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , sos ) call check_errors () call json_get ( meta_array , 'shape' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_shape ) call check_errors ( all ( fetched_shape == shape )) call json_get ( meta_array , 'data' , tmp_json_ptr ) call check_errors () call json_get ( tmp_json_ptr , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call json_get ( root , 'array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) raw_array = 0 call json_get ( me = root , path = 'array data.data' , array_callback = get_3D_from_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) my_file = json_file ( root ) call my_file % update ( 'array data.description' , CK_ 'vector data' , found = existed ) call check_errors ( existed ) call my_file % update ( CK_ 'array data.description' , 'Vector data' , found = existed ) call check_errors ( existed ) call my_file % get ( 'SOS' , sos ) call check_errors () call my_file % get ( '$array data.data' , fetched_array ) call check_errors ( all ( abs ( fetched_array - reshape ( raw_array ,[ size ( raw_array )])) <= TOL )) call my_file % get ( tmp_json_ptr ) call check_errors ( associated ( tmp_json_ptr , root )) open ( file = dir // file , newunit = lun , form = 'formatted' , action = 'write' ) call my_file % print_file ( lun ) call check_errors () close ( lun ) contains subroutine check_errors ( assertion ) logical , optional , intent ( in ) :: assertion if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( present ( assertion )) then if (. not . assertion ) error_cnt = error_cnt + 1 end if end subroutine check_errors subroutine get_3D_from_array ( element , i , count ) type ( json_value ), pointer , intent ( in ) :: element integer , intent ( in ) :: i !!index integer , intent ( in ) :: count !!size of array integer :: useless !! assign count to this to silence warnings ! let's pretend we're c programmers! call json_get ( element , raw_array ( & mod ( i - 1 , imx ) + 1 , & ! i index mod (( i - 1 ) / imx , jmx ) + 1 , & ! j index mod (( i - 1 ) / imx / jmx , kmx ) + 1 ) ) ! k inded useless = count end subroutine get_3D_from_array end subroutine test_12","tags":"","loc":"proc/test_12.html","title":"test_12 â€“ JSON-Fortran"},{"text":"public  subroutine test_13(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests different real format strings using repeated calls to json_initialize . Variables Type Visibility Attributes Name Initial type( json_file ), public :: my_file character(kind=CK,len=:), public, allocatable :: str integer, public :: i character(len=2), public, parameter, dimension(4) :: fmts = ['g ','g ','g ','g '] format statements to test Source Code subroutine test_13 ( error_cnt ) !! Tests different real format strings using repeated calls to [[json_initialize]]. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_file ) :: my_file character ( kind = CK , len = :), allocatable :: str integer :: i character ( len = 2 ), dimension ( 4 ), parameter :: fmts = [ 'g ' , 'e ' , 'en' , 'es' ] !! format statements to test write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 13' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 do i = 1 , size ( fmts ) call json_initialize ( real_format = trim ( fmts ( i ))) call my_file % load_from_string ( '{ \"value\": 1234.56789 }' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call my_file % print_to_string ( str ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( output_unit , '(A)' ) str end if call my_file % destroy () end do end subroutine test_13","tags":"","loc":"proc/test_13.html","title":"test_13 â€“ JSON-Fortran"},{"text":"public  subroutine test_14(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests the traversal of a JSON structure It traverses the structure, looks for all \"name\" variables, and changes the name. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: json Source Code subroutine test_14 ( error_cnt ) !! Tests the traversal of a JSON structure !! !! It traverses the structure, looks for all \"name\" variables, and changes the name. implicit none integer , intent ( out ) :: error_cnt !! report number of errors to caller type ( json_value ), pointer :: json write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   TEST 14' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' error_cnt = 0 icount = 0 !number of name changes (should be 2) call json_initialize () !initialize the module call json_parse ( dir // filename1 , json ) !read the file if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_traverse ( json , rename ) !traverse all nodes in the structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( icount /= 2 ) then write ( error_unit , '(A)' ) 'Error: should be 2 \"name\" variables in this file: ' // filename1 error_cnt = error_cnt + 1 end if if ( error_cnt == 0 ) then write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) ' All names changed to Fred:' write ( error_unit , '(A)' ) '' call json_print ( json , output_unit ) write ( error_unit , '(A)' ) '' end if call json_destroy ( json ) !clean up if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_14","tags":"","loc":"proc/test_14.html","title":"test_14 â€“ JSON-Fortran"},{"text":"public  subroutine rename(p, finished) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: p logical, intent(out) :: finished Description change all \"name\" variable values to \"Fred\" Variables Type Visibility Attributes Name Initial integer, public :: var_type character(kind=CK,len=:), public, allocatable :: str logical, public :: found Source Code subroutine rename ( p , finished ) !! change all \"name\" variable values to \"Fred\" implicit none type ( json_value ), pointer , intent ( in ) :: p logical , intent ( out ) :: finished integer :: var_type character ( kind = CK , len = :), allocatable :: str logical :: found !get info about this variable: call json_info ( p , var_type = var_type , name = str ) !it must be a string named \"name\": if ( var_type == json_string . and . str == 'name' ) then call json_get ( p , '@' , str ) ! get original name call json_update ( p , '@' , 'Fred' , found ) !change it write ( error_unit , '(A)' ) str // ' name changed' icount = icount + 1 end if !cleanup: if ( allocated ( str )) deallocate ( str ) !always false, since we want to traverse all nodes: finished = . false . end subroutine rename","tags":"","loc":"proc/rename.html","title":"rename â€“ JSON-Fortran"},{"text":"public  subroutine test_2(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure and write it to a file. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p type( json_value ), public, pointer :: inp type( json_value ), public, pointer :: traj integer, public :: iunit Source Code subroutine test_2 ( error_cnt ) !! Populate a JSON structure and write it to a file. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp , traj integer :: iunit error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 2' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !root: call json_create_object ( p , dir // filename2 ) ! create the value and associate the pointer ! add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'initialize the structure...' !config structure: call json_create_object ( inp , 'inputs' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory structure: call json_create_array ( traj , 'trajectory' ) !an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( p , traj ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'adding some data to structure...' !add some variables: !input variables: call json_add ( inp , 't0' , 0.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'tf' , 1.1_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'x0' , 999 9.000_wp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_scalar' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'integer_array' , [ 2 , 4 , 99 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'names' , [ 'aaa' , 'bbb' , 'ccc' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_scalar' , . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( inp , 'logical_vector' , [. true ., . false ., . true .]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) !trajectory variables: call add_variables_to_input ( traj , 'Rx' , 'km' , 'J2000' , 'EARTH' , [ 1.0_wp , 2.0_wp , 3.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Ry' , 'km' , 'J2000' , 'EARTH' , [ 1 0.0_wp , 2 0.0_wp , 3 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Rz' , 'km' , 'J2000' , 'EARTH' , [ 10 0.0_wp , 20 0.0 d0 , 30 0.0_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vx' , 'km/s' , 'J2000' , 'EARTH' , [ 1.0e-3_wp , 2.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vy' , 'km/s' , 'J2000' , 'EARTH' , [ 2.0e-3_wp , 2 0.0e-3_wp , 3.0e-3_wp ], error_cnt ) call add_variables_to_input ( traj , 'Vz' , 'km/s' , 'J2000' , 'EARTH' , [ 3.0e-3_wp , 3 0.0e-3_wp , 4 0.0e-3_wp ], error_cnt ) nullify ( traj ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'writing file ' // trim ( dir // filename2 ) // '...' open ( newunit = iunit , file = dir // filename2 , status = 'REPLACE' ) call json_print ( p , iunit ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if close ( iunit ) !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_2","tags":"","loc":"proc/test_2.html","title":"test_2 â€“ JSON-Fortran"},{"text":"public  subroutine add_variables_to_input(me, variable, units, frame, center, rdata, error_cnt) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(len=*), intent(in) :: variable character(len=*), intent(in) :: units character(len=*), intent(in) :: frame character(len=*), intent(in) :: center real(kind=wp), intent(in), dimension(:) :: rdata integer, intent(inout) :: error_cnt Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: var Source Code subroutine add_variables_to_input ( me , variable , units , frame , center , rdata , error_cnt ) !Used by test_2. implicit none type ( json_value ), pointer :: me character ( len =* ), intent ( in ) :: variable , units , frame , center real ( wp ), dimension (:), intent ( in ) :: rdata integer , intent ( inout ) :: error_cnt type ( json_value ), pointer :: var !a variable in the trajectory: !initialize: nullify ( var ) !create the object before data can be added: call json_create_object ( var , '' ) !name does not matter if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !variable info: call json_add ( var , 'VARIABLE' , trim ( variable )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'UNITS' , trim ( units )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'FRAME' , trim ( frame )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( var , 'CENTER' , trim ( center )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !trajectory [vector of reals]: call json_add ( var , 'DATA' , rdata ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add this variable to trajectory structure: call json_add ( me , var ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !cleanup: nullify ( var ) end subroutine add_variables_to_input","tags":"","loc":"proc/add_variables_to_input.html","title":"add_variables_to_input â€“ JSON-Fortran"},{"text":"public  subroutine test_3(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file generated in test_2 , and extract some data from it. Variables Type Visibility Attributes Name Initial integer, public :: ival character(kind=CK,len=:), public, allocatable :: cval real(kind=wp), public :: rval type( json_file ), public :: json integer, public :: i character(kind=CK,len=10), public :: str real(kind=wp), public, dimension(:), allocatable :: rvec Source Code subroutine test_3 ( error_cnt ) !! Read the file generated in [[test_2]], and extract some data from it. implicit none integer , intent ( out ) :: error_cnt integer :: ival character ( kind = CK , len = :), allocatable :: cval real ( wp ) :: rval type ( json_file ) :: json !the JSON structure read from the file: integer :: i character ( kind = CK , len = 10 ) :: str real ( wp ), dimension (:), allocatable :: rvec error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 3' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'parsing file: ' // dir // filename2 call json % load_file ( filename = dir // filename2 ) if ( json_failed ()) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'reading data from file...' !get scalars: write ( error_unit , '(A)' ) '' call json % get ( 'inputs.integer_scalar' , ival ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,I5)' ) 'inputs.integer_scalar = ' , ival end if !get one element from a vector: write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(1).DATA(2)' , rval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,F30.16)' ) 'trajectory(1).DATA(2) = ' , rval end if !get vectors: do i = 1 , 4 write ( str , fmt = '(I10)' ) i str = adjustl ( str ) write ( error_unit , '(A)' ) '' call json % get ( 'trajectory(' // trim ( str ) // ').VARIABLE' , cval ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'trajectory(' // trim ( str ) // ').VARIABLE = ' // trim ( cval ) !...get the vector using the callback method: call json % get ( 'trajectory(' // trim ( str ) // ').DATA' , rvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A,1X,*(F30.16,1X))' ) 'trajectory(' // trim ( str ) // ').DATA = ' , rvec end if end if end do end if ! clean up write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'destroy...' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_3","tags":"","loc":"proc/test_3.html","title":"test_3 â€“ JSON-Fortran"},{"text":"public  subroutine test_4(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure, write it to a file,\n then read it. Also tests the json_value_to_string routine to write\n the file to a character string. Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p type( json_value ), public, pointer :: inp type( json_file ), public :: json integer, public :: i character(kind=CK,len=10), public :: istr character(kind=CK,len=:), public, allocatable :: string Source Code subroutine test_4 ( error_cnt ) !! Populate a JSON structure, write it to a file, !! then read it. !! !! Also tests the json_value_to_string routine to write !! the file to a character string. implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p , inp type ( json_file ) :: json integer :: i character ( kind = CK , len = 10 ) :: istr character ( kind = CK , len = :), allocatable :: string error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 4' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'creating structure' call json_create_object ( p , dir // filename4 ) !create the value and associate the pointer !add the file name as the name of the overall structure if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !config structure: call json_create_object ( inp , 'INPUTS' ) !an object if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if !add just integers: do i = 1 , 100 write ( istr , fmt = '(I10)' ) i istr = adjustl ( istr ) call json_add ( inp , 'x' // trim ( istr ), i ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do call json_add ( p , inp ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( inp ) write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to file' !write the file: call json_print ( p , trim ( dir // filename4 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'write to string' write ( error_unit , '(A)' ) '' !write it to a string, and print to console: call json_print_to_string ( p , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) string deallocate ( string ) !cleanup !cleanup: call json_destroy ( p ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'read file' call json % load_file ( filename = dir // filename4 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'cleanup' call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_4","tags":"","loc":"proc/test_4.html","title":"test_4 â€“ JSON-Fortran"},{"text":"public  subroutine test_5(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Github issue example: https://github.com/josephalevin/fson/issues/12 Read an existing file and extract some variables. Variables Type Visibility Attributes Name Initial integer, public :: vv integer, public, dimension(:), allocatable :: vvv real(kind=wp), public :: d type( json_file ), public :: json logical, public :: found Source Code subroutine test_5 ( error_cnt ) !! Github issue example: https://github.com/josephalevin/fson/issues/12 !! !! Read an existing file and extract some variables. implicit none integer , intent ( out ) :: error_cnt integer :: vv integer , dimension (:), allocatable :: vvv real ( wp ) :: d type ( json_file ) :: json logical :: found error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 5' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' ! parse the json file: write ( error_unit , '(A)' ) 'load file...' call json % load_file ( filename = dir // filename5 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! print the parsed data to the console: write ( error_unit , '(A)' ) 'print file...' call json % print_file () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! extract data from the parsed value: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'extract data...' write ( error_unit , '(A)' ) '--------------------------' call json % get ( 'Correl.ID2' , vv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,I5)' ) 'vv = ' , vv call json % get ( 'Correl.ID1' , vvv , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,*(I5,1X))' ) 'vvv= ' , vvv call json % get ( 'Prior[3].mode' , d , found ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if if ( found ) write ( error_unit , '(A,E30.16)' ) 'd  = ' , d write ( error_unit , '(A)' ) '' end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_5","tags":"","loc":"proc/test_5.html","title":"test_5 â€“ JSON-Fortran"},{"text":"public  subroutine test_6(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description This example tries to read an invalid JSON file. Variables Type Visibility Attributes Name Initial type( json_file ), public :: json integer, public :: i character(len=*), public, parameter, dimension(2) :: files = ['invalid.json ','invalid.json '] Source Code subroutine test_6 ( error_cnt ) !! This example tries to read an invalid JSON file. implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: json integer :: i character ( len =* ), dimension ( 2 ), parameter :: files = [ 'invalid.json ' ,& 'invalid2.json' ] error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 6 : invalid JSON files' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' do i = 1 , 2 ! parse the json file: write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'load file: ' // trim ( files ( i )) write ( error_unit , '(A)' ) '' call json % load_file ( filename = dir // trim ( files ( i ))) if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'An error should have been raised!' error_cnt = error_cnt + 1 end if ! clean up call json % destroy () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end do end subroutine test_6","tags":"","loc":"proc/test_6.html","title":"test_6 â€“ JSON-Fortran"},{"text":"public  subroutine test_7(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Indent test Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: root type( json_value ), public, pointer :: a type( json_value ), public, pointer :: b type( json_value ), public, pointer :: c type( json_value ), public, pointer :: d type( json_value ), public, pointer :: e type( json_value ), public, pointer :: e1 type( json_value ), public, pointer :: e2 type( json_value ), public, pointer :: escaped_string type( json_value ), public, pointer :: p logical, public :: found character(kind=CK,len=1), public, dimension(:), allocatable :: strvec character(kind=CK,len=:), public, allocatable :: string Source Code subroutine test_7 ( error_cnt ) !! Indent test implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: root , a , b , c , d , e , e1 , e2 , escaped_string , p logical :: found character ( kind = CK , len = 1 ), dimension (:), allocatable :: strvec character ( kind = CK , len = :), allocatable :: string found = . false . error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 7 : indent test' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' !----------------------- ! jsonlint indention is !----------------------- !{ !    \"a\": { !        \"ints\": [ !            1, !            2, !            3 !        ], !        \"chars\": [ !            \"a\", !            \"b\", !            \"c\" !        ] !    }, !    \"b\": { !        \"c\": { !            \"val1\": 1066 !        } !    }, !    \"d\": { !        \"val2\": 1815 !    }, !    \"array\": [ !        { !            \"int1\": 1 !        }, !        { !            \"int1\": 1, !            \"int2\": 2 !        } !    ] !    \"escaped string\": \"\\\\\\/\\b\\f\\n\\r\\t\" !} !create a json structure: call json_create_object ( root , 'root' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( a , 'a' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'ints' , [ 1 , 2 , 3 ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( b , 'b' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( a , 'chars' , [ 'a' , 'b' , 'c' ]) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get_child ( a , 'chars' , p ) call json_get ( p , strvec ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( c , 'c' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( c , 'val1' , 1066 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( d , 'd' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( d , 'val2' , 1815 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_array ( e , 'array' ) !objects in an array if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e1 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e1 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_create_object ( e2 , '' ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int1' , 1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e2 , 'int2' , 2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e1 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( e , e2 ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , a ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , b ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( b , c ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , d ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , e ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'escaped string' ,& '\\/' // & achar ( 8 ) // & achar ( 12 ) // & achar ( 10 ) // & achar ( 13 ) // & achar ( 9 )) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_add ( root , 'wacky string' ,[ 'trim   ' , '  and  ' , ' adjust' , '   left' ],& trim_str = . true ., adjustl_str = . true .) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if nullify ( a ) !don't need these anymore nullify ( b ) nullify ( c ) nullify ( d ) nullify ( e ) nullify ( e1 ) nullify ( e2 ) nullify ( escaped_string ) call json_print ( root , output_unit ) !print to the console if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if ! look for the 'escaped string' entry call json_get ( root , 'escaped string' , escaped_string , found ) if ( json_failed () . or . . not . found ) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_get ( escaped_string , string ) if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) \"Fetched unescaped 'escaped string': \" // string ! remove the escaped string entry if ( found ) call json_remove ( escaped_string , destroy = . true .) call json_print ( root , error_unit ) !print to stderr if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( root ) !cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine test_7","tags":"","loc":"proc/test_7.html","title":"test_7 â€“ JSON-Fortran"},{"text":"public  subroutine test_8(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description read a JSON structure from a string Variables Type Visibility Attributes Name Initial type( json_value ), public, pointer :: p character(len=*), public, parameter :: newline = achar(10) character(len=*), public, parameter :: str = '{ \"label\": \"foo\",'//newline//'{ \"label\": \"foo\",' character(len=*), public, parameter :: str2 = '{ \"label\": \"foo\",'//newline//'{ \"label\": \"foo\",'//newline//'{ \"label\": \"foo\",'//newline//'{ \"label\": \"foo\",'//newline//'{ \"label\": \"foo\",' character(len=*), public, parameter :: str_invalid = '{ \"label\": \"foo\",'//newline//'{ \"label\": \"foo\",' Source Code subroutine test_8 ( error_cnt ) !! read a JSON structure from a string implicit none integer , intent ( out ) :: error_cnt type ( json_value ), pointer :: p character ( len =* ), parameter :: newline = achar ( 10 ) character ( len =* ), parameter :: str = '{ \"label\": \"foo\",' // newline // ' \"value\": \"bar\" }' character ( len =* ), parameter :: str2 = '{ \"label\": \"foo\",' // newline // & '  \"value\": \"bar\",' // newline // & '  \"empty_array\": [],' // newline // & '  \"empty_object\": {}' // newline // & '}' character ( len =* ), parameter :: str_invalid = '{ \"label\": \"foo\",' // newline // ' \"value : \"bar\" }' error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 8 : read JSON from string' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 1:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '{ \"part a\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Valid test 2:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str2 , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part b\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) ',' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) ' Invalid test:' write ( error_unit , '(A)' ) '**************' write ( error_unit , '(A)' ) '' call json_parse ( str = str_invalid , p = p ) ! read it from str if ( json_failed ()) then call json_print_error_message ( error_unit ) else write ( error_unit , '(A)' ) 'This should have failed!' error_cnt = error_cnt + 1 end if write ( output_unit , '(A)' ) '\"part c\" : ' call json_print ( p , output_unit ) ! print to console write ( output_unit , '(A)' ) '}' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if call json_destroy ( p ) ! cleanup if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' end subroutine test_8","tags":"","loc":"proc/test_8.html","title":"test_8 â€“ JSON-Fortran"},{"text":"public  subroutine test_9(error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Open a random JSON file generated by http://www.json-generator.com Variables Type Visibility Attributes Name Initial type( json_file ), public :: f real, public :: tstart real, public :: tend character(len=:), public, allocatable :: str Source Code subroutine test_9 ( error_cnt ) !! Open a random JSON file generated by http://www.json-generator.com implicit none integer , intent ( out ) :: error_cnt type ( json_file ) :: f real :: tstart , tend character ( len = :), allocatable :: str error_cnt = 0 call json_initialize () if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9a ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_file' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call f % load_file ( dir // filename ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !cleanup: call f % destroy () write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '   EXAMPLE 9b ' write ( error_unit , '(A)' ) '=================================' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) '  Load a file using json_file%load_from_string' write ( error_unit , '(A)' ) '' write ( error_unit , '(A)' ) 'Loading file: ' // trim ( filename ) call cpu_time ( tstart ) call read_file ( dir // filename , str ) if ( allocated ( str )) then call f % load_from_string ( str ) call cpu_time ( tend ) write ( error_unit , '(A,1X,F10.3,1X,A)' ) 'Elapsed time to parse: ' , tend - tstart , ' sec' if ( json_failed ()) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else write ( error_unit , '(A)' ) 'File successfully read' end if write ( error_unit , '(A)' ) '' !write(error_unit,'(A)') str   !!!! test !!!! !write(error_unit,'(A)') ''    !!!! test !!!! else write ( error_unit , '(A)' ) 'Error loading file' end if !cleanup: call f % destroy () end subroutine test_9","tags":"","loc":"proc/test_9.html","title":"test_9 â€“ JSON-Fortran"},{"text":"public  subroutine read_file(filename, str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: str Description Reads the contents of the file into the allocatable string str.\n If there are any problems, str will be returned unallocated. Warning Will this routine work if the file contains unicode characters?? Variables Type Visibility Attributes Name Initial integer, public :: iunit integer, public :: istat integer, public :: filesize Source Code subroutine read_file ( filename , str ) !! Reads the contents of the file into the allocatable string str. !! If there are any problems, str will be returned unallocated. !! !!@warning Will this routine work if the file contains unicode characters?? implicit none character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable , intent ( out ) :: str integer :: iunit , istat , filesize open ( newunit = iunit ,& file = filename ,& status = 'OLD' ,& form = 'UNFORMATTED' ,& access = 'STREAM' ,& iostat = istat ) if ( istat == 0 ) then inquire ( file = filename , size = filesize ) if ( filesize > 0 ) then allocate ( character ( len = filesize ) :: str ) read ( iunit , pos = 1 , iostat = istat ) str if ( istat /= 0 ) deallocate ( str ) close ( iunit , iostat = istat ) end if end if end subroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file â€“ JSON-Fortran"},{"text":"Uses: iso_fortran_env JSON -Fortran: A Fortran 2008 JSON (JavaScript Object Notation) API . JSON-Fortran: License History See also This module provides an interface for reading and writing JSON files. Note -DUSE_UCS4 is an optional preprocessor flag.\n      When present, Unicode support is enabled. Note that this\n      is currently only supported with the gfortran compiler.\n      Example: gfortran -DUSE_UCS4 ... The documentation given here assumes USE_UCS4 is not defined. Warning CK and CDK are the JSON -Fortran character kind and JSON -Fortran default\n         character kind respectively. Client code MUST ensure characters of kind=CK are used for all character variables and strings passed to the JSON -Fortran\n         library EXCEPT for file names which must be of 'DEFAULT' character kind,\n         provided here as CDK . In particular, any variable that is a: json path, string\n         value or object name passed to the JSON -Fortran library MUST be of type CK . Note Most string literal constants of default kind are fine to pass as arguments to JSON -Fortran procedures since they have been overloaded to accept intent(in) character arguments of the default ( CDK ) kind. If you find a procedure which does\n      not accept an intent(in) literal string argument of default kind, please file an issue on github. License JSON -Fortran License: JSON-Fortran: A Fortran 2008 JSON API\n\nhttp://github.com/jacobwilliams/json-fortran\n\nCopyright (c) 2014-2015, Jacob Williams\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n* The names of its contributors may not be used to endorse or promote products\n  derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Original FSON License: Copyright (c) 2012 Joseph A. Levin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this\nsoftware and associated documentation files (the \"Software\"), to deal in the Software\nwithout restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or\nsubstantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\nOR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE. History Joseph A. Levin : March 2012 : Original FSON code [retrieved on 12/2/2013]. Jacob Williams : 2/8/2014 : Extensive modifications to the original FSON code.\n    The original F95 code was split into four files:\n    fson_path_m.f95, fson_string_m.f95, fson_value_m.f95, and fson.f95.\n    The new code has been extensively updated, refactored and combined into this\n    one module (json_module.f90).\n    Various Fortran 2003/2008 features are now used\n    (e.g., allocatable strings, newunit, generic, class, and abstract interface). Development continues at: Github See also json-fortran development site json-fortran online documentation JSON website JSON validator Variables Type Visibility Attributes Name Initial integer, private, parameter :: RK = real64 Default real kind [8 bytes] integer, private, parameter :: IK = int32 Default integer kind [4 bytes]. integer, public, parameter :: CDK = selected_char_kind(\"0\") Processor dependendant 'DEFAULT' character kind.\n  This is 1 byte for the Intel and Gfortran compilers. integer, private, parameter :: LK = logical_kinds(min(3,size(logical_kinds))) Default logical kind.\n  This is 4 bytes for the Intel and Gfortran compilers\n  (and perhaps others).\n  The declaration ensures a valid kind\n  if the compiler doesn't have a logical_kinds(3). character(kind=CDK,len=*), private, parameter :: json_fortran_string_kind = 'DEFAULT' String kind preprocessor macro. this is the string kind to use unless compiling with GFortran AND\n UCS4/ISO 10646 support is requested integer, public, parameter :: CK = selected_char_kind(json_fortran_string_kind) Default character kind used by JSON -Fortran.\n  If ISO 10646 (UCS4) support is available, use that,\n  otherwise, gracefully fall back on 'DEFAULT' characters.\n  Currently only gfortran >= 4.9.2 will correctly support\n  UCS4 which is stored in 4 bytes.\n  (and perhaps others). logical, private, parameter :: use_unformatted_stream = .true. If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. character(kind=CDK,len=*), private, parameter :: access_spec = 'STREAM' If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. character(kind=CDK,len=*), private, parameter :: form_spec = 'UNFORMATTED' If Unicode is not enabled, then JSON files are opened using access='STREAM' and\n  form='UNFORMATTED'.  This allows the file to\n  be read faster. integer(kind=IK), public, parameter :: json_unknown = 0 Unknown JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_null = 1 Null JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_object = 2 Object JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_array = 3 Array JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_logical = 4 Logical JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_integer = 5 Integer JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_double = 6 Double JSON data type (see json_file_variable_info and json_info ) integer(kind=IK), public, parameter :: json_string = 7 String JSON data type (see json_file_variable_info and json_info ) character(kind=CDK,len=*), public, parameter :: json_ext = '.json' JSON file extension character(kind=CK,len=*), private, parameter :: space = ' ' character(kind=CK,len=*), private, parameter :: start_object = '{' character(kind=CK,len=*), private, parameter :: end_object = '}' character(kind=CK,len=*), private, parameter :: start_array = '[' character(kind=CK,len=*), private, parameter :: end_array = ']' character(kind=CK,len=*), private, parameter :: delimiter = ',' character(kind=CK,len=*), private, parameter :: colon_char = ':' character(kind=CK,len=*), private, parameter :: bspace = achar(8) character(kind=CK,len=*), private, parameter :: horizontal_tab = achar(9) character(kind=CK,len=*), private, parameter :: newline = achar(10) character(kind=CK,len=*), private, parameter :: formfeed = achar(12) character(kind=CK,len=*), private, parameter :: carriage_return = achar(13) character(kind=CK,len=*), private, parameter :: quotation_mark = achar(34) character(kind=CK,len=*), private, parameter :: slash = achar(47) character(kind=CK,len=*), private, parameter :: backslash = achar(92) character(kind=CK,len=4), private :: null_str = 'null' character(kind=CK,len=4), private :: true_str = 'true' character(kind=CK,len=5), private :: false_str = 'false' integer, private :: i_ character(kind=CK,len=*), private, parameter :: control_chars (32) = [(achar(i_),i_=1,31),achar(127)] integer(kind=IK), private, parameter :: spaces_per_tab = 2 logical(kind=LK), private :: compact_real = .true. to use the \"compact\" form of real numbers for output integer(kind=IK), private, parameter :: rp_safety_factor = 1 integer(kind=IK), private, parameter :: rp_addl_safety = 1 integer(kind=IK), private, parameter :: real_precision = rp_safety_factor*precision(1.0_RK)+rp_addl_safety integer(kind=IK), private, parameter :: maxexp = maxexponent(1.0_RK) integer(kind=IK), private, parameter :: minexp = minexponent(1.0_RK) integer(kind=IK), private, parameter :: real_exponent_digits = floor(1+log10(real(max(maxexp,abs(maxexp)),kind=RK))) integer(kind=IK), private, parameter :: max_numeric_str_len = real_precision+real_exponent_digits+6 6 = sign + leading 0 + decimal + 'E' + exponent sign + 1 extra character(kind=CDK,len=*), private, parameter :: int_fmt = '(ss,I0)' minimum width format for integers character(kind=CK,len=*), private, parameter :: star = '*' for invalid numbers character(kind=CDK,len=:), private, allocatable :: real_fmt the format string to use for real numbers\n it is set in json_initialize logical(kind=LK), private :: is_verbose = .false. if true, all exceptions are immediately printed to console logical(kind=LK), private :: exception_thrown = .true. the error flag (by default, this is true to make sure that json_initialize is called. character(kind=CK,len=:), private, allocatable :: err_message the error message integer(kind=IK), private :: char_count = 0 integer(kind=IK), private :: line_count = 1 integer(kind=IK), private :: pushed_index = 0 character(kind=CK,len=10), private :: pushed_char = '' integer(kind=IK), private, parameter :: chunk_size = 100 for allocatable strings: allocate chunks of this size integer(kind=IK), private :: ipos = 1 for allocatable strings: next character to read integer(kind=IK), private, parameter :: unit2str = -1 unit number to cause stuff to be\n output to strings rather than files.\n See 9.5.6.12 in the F2003/08 standard Interfaces private interface json_file Structure constructor to initialize a json_file object\n  with an existing json_value object private  function initialize_json_file (p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), optional pointer :: p json_value object to cast\n as a json_file object Return Value type( json_file ) Description Cast a json_value object as a json_file object public interface json_get_child Get a child, either by index or name string.\n  Both of these return a json_value pointer. private  subroutine json_value_get_by_index (me, idx, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me object or array JSON data integer(kind=IK), intent(in) :: idx index of the child type( json_value ), intent(inout), pointer :: p pointer to the child Description Returns a child in the object or array given the index. private  subroutine json_value_get_by_name_chars (me, name, p) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: name the name of a child of \"me\" type( json_value ), intent(inout), pointer :: p pointer to the child Description Returns a child in the object or array given the name string. public interface json_add Add objects to a linked list of json_value s. private  subroutine json_value_add_member (me, member) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me type( json_value ), intent(inout), pointer :: member the child member to add Description Adds \"member\" as a child of \"me\". private  subroutine json_value_add_integer (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val Description Add an integer value child to the json_value variable private  subroutine json_value_add_integer_vec (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable integer(kind=IK), intent(in), dimension(:) :: val value Description Add an integer vector to the structure. private  subroutine json_value_add_double (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name variable name real(kind=RK), intent(in) :: val real value Description Add a real value child to the json_value variable private  subroutine json_value_add_double_vec (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in), dimension(:) :: val Description Add a real vector to the structure. private  subroutine json_value_add_logical (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable logical(kind=LK), intent(in) :: val value Description Add a logical value child to the json_value variable private  subroutine json_value_add_logical_vec (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the vector logical(kind=LK), intent(in), dimension(:) :: val value Description Add a logical vector to the structure. private  subroutine json_value_add_string (me, name, val) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name name of the variable character(kind=CK,len=*), intent(in) :: val value Description Add a character string child to the json_value variable. private  subroutine json_value_add_string_vec (me, name, val, trim_str, adjustl_str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name variable name character(kind=CK,len=*), intent(in), dimension(:) :: val array of strings logical(kind=LK), intent(in), optional :: trim_str if TRIM() should be called for each element logical(kind=LK), intent(in), optional :: adjustl_str if ADJUSTL() should be called for each element Description Add an array of character strings to the structure. public interface json_update These are like json_add , except if a child with the same name is\n  already present, then its value is simply updated.\n  Note that currently, these only work for scalar variables.\n  These routines can also change the variable's type (but an error will be\n  thrown if the existing variable is not a scalar). private  subroutine json_update_logical (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name logical(kind=LK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_update_double (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name real(kind=RK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_update_integer (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name integer(kind=IK), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. private  subroutine json_update_string (p, name, val, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name character(kind=CK,len=*), intent(in) :: val logical(kind=LK), intent(out) :: found Description Given the path string, if the variable is present,\n  and is a scalar, then update its value.\n  If it is not present, then create it and set its value. public interface json_get Get data from a json_value linked list. private  subroutine json_get_by_path (me, path, p, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path type( json_value ), intent(out), pointer :: p logical(kind=LK), intent(out), optional :: found true if it was found Description Returns the json_value pointer given the path string. private  subroutine json_get_integer (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(out) :: value Description Get an integer value from a json_value . private  subroutine json_get_integer_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get an integer value from a json_value , given the path string. private  subroutine json_get_integer_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(out), dimension(:), allocatable :: vec Description Get an integer vector from a json_value . private  subroutine json_get_integer_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path integer(kind=IK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get an integer vector from a json_value , given the path string. private  subroutine json_get_double (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(out) :: value Description Get a double value from a json_value . private  subroutine json_get_double_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out) :: value logical(kind=LK), intent(out), optional :: found Description Get a double value from a json_value , given the path. private  subroutine json_get_double_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(out), dimension(:), allocatable :: vec Description Get a double vector from a json_value . private  subroutine json_get_double_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: path real(kind=RK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a double vector from a json_value , given the path. private  subroutine json_get_logical (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(inout) :: value Description Get a logical value from a json_value . private  subroutine json_get_logical_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(inout) :: value logical(kind=LK), intent(out), optional :: found Description Get a logical value from a json_value , given the path. private  subroutine json_get_logical_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me logical(kind=LK), intent(out), dimension(:), allocatable :: vec Description Get a logical vector from json_value . private  subroutine json_get_logical_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path logical(kind=LK), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a logical vector from a json_value , given the path. private  subroutine json_get_string (me, value) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: value Description Get a character string from a json_value . private  subroutine json_get_string_with_path (me, path, value, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=:), intent(out), allocatable :: value logical(kind=LK), intent(out), optional :: found Description Get a character string from a json_value , given the path. private  subroutine json_get_string_vec (me, vec) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec Description Get a string vector from a json_file . private  subroutine json_get_string_vec_with_path (me, path, vec, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path character(kind=CK,len=*), intent(out), dimension(:), allocatable :: vec logical(kind=LK), intent(out), optional :: found Description Get a string vector from a json_file , given the path. private  subroutine json_get_array (me, array_callback) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me procedure( array_callback_func ), intent(inout) :: array_callback Description This routine calls the user-supplied array_callback_func subroutine\n      for each element in the array. private  subroutine json_get_array_with_path (me, path, array_callback, found) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=*), intent(in) :: path procedure( array_callback_func ), intent(inout) :: array_callback logical(kind=LK), intent(out), optional :: found Description This routine calls the user-supplied array_callback subroutine\n  for each element in the array (specified by the path). public interface json_print_to_string Print the json_value structure to an allocatable string. private  subroutine json_value_to_string (me, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CK,len=:), intent(out), allocatable :: str prints structure to this string Description Print the json_value structure to an allocatable string. public interface json_print Print the json_value to a file. private  subroutine json_print_1 (me, iunit) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me integer(kind=IK), intent(in) :: iunit the file unit (the file must already have been opened, can't be -1). Description Print the json_value structure to a file. private  subroutine json_print_2 (me, filename) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: me character(kind=CDK,len=*), intent(in) :: filename the filename to print to (should not already be open) Description Print the json_value structure to a file. public interface json_destroy Destructor routine for a json_value pointer.\n  This must be called explicitly if it is no longer needed,\n  before it goes out of scope.  Otherwise, a memory leak will result. private recursive subroutine json_value_destroy (me, destroy_next) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in), optional :: destroy_next if true, then me%next is also destroyed (default is true) Description Destroy a json_value linked-list structure. public interface json_remove Remove a json_value from a linked-list structure. private  subroutine json_value_remove (me, destroy) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in), optional :: destroy If destroy is not present, it is also destroyed.\n If destroy is present and true, it is destroyed.\n If destroy is present and false, it is not destroyed. Description Remove a json_value (and all its children)\n  from a linked-list structure, preserving the rest of the structure. public interface json_remove_if_present If the child variable is present, then remove it. private  subroutine json_value_remove_if_present (p, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p character(kind=CK,len=*), intent(in) :: name Description Given the path string, remove the variable from\n  the json_value structure, if it exists. public interface json_create_double Allocate a json_value pointer and make it a double variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_double (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me real(kind=RK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a real(RK) variable.\n  The pointer should not already be allocated. public interface json_create_array Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_array (me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an array variable.\n  The pointer should not already be allocated. public interface json_create_object Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_object (me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an object variable.\n  The pointer should not already be allocated. public interface json_create_null Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_null (me, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a null variable.\n  The pointer should not already be allocated. public interface json_create_string Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_string (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(kind=CK,len=*), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it a string variable.\n  The pointer should not already be allocated. public interface json_create_integer Allocate a json_value pointer and make it an integer variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_integer (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me integer(kind=IK), intent(in) :: val character(kind=CK,len=*), intent(in) :: name Description Allocate a json_value pointer and make it an integer(IK) variable.\n  The pointer should not already be allocated. public interface json_create_logical Allocate a json_value pointer and make it a logical variable.\n  The pointer should not already be allocated. private  subroutine json_value_create_logical (me, val, name) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me logical(kind=LK), intent(in) :: val variable value character(kind=CK,len=*), intent(in) :: name variable name Description Allocate a json_value pointer and make it a logical(LK) variable.\n  The pointer should not already be allocated. public interface json_parse Parse the JSON file and populate the json_value tree. private  subroutine json_parse_file (file, p, unit) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: file JSON file name type( json_value ), intent(inout), pointer :: p output structure integer(kind=IK), intent(in), optional :: unit file unit number (/= 0) Description Parse the JSON file and populate the json_value tree. private  subroutine json_parse_string (p, str) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: p output structure character(kind=CK,len=*), intent(in) :: str string with JSON data Description Parse the JSON string and populate the json_value tree. public interface to_unicode Convert a 'DEFAULT' kind character input to 'ISO_10646' kind and return it private pure function to_uni (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in) :: str Return Value character(kind=CK,len=len(str)) Description Convert string to unicode (CDK to CK). private pure function to_uni_vec (str) Arguments Type Intent Optional Attributes Name character(kind=CDK,len=*), intent(in), dimension(:) :: str Return Value character(kind=CK,len=len(str)),\n  dimension(size(str)) Description Convert array of strings to unicode (CDK to CK). private interface throw_exception Throw an exception. private  subroutine json_throw_exception (msg) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: msg Description Throw an exception in the JSON module.\n  This routine sets the error flag, and prevents any subsequent routine\n  from doing anything, until json_clear_exceptions is called.","tags":"","loc":"module/json_module.html","title":"json_module â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the first unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename1 = 'test1.json' Subroutines public  subroutine test_1 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read a sample JSON file and retrieve some data from it","tags":"","loc":"module/jf_test_1_mod.html","title":"jf_test_1_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the tenth unit test. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: filename = 'test1.json' character(len=*), public, parameter :: dir = '../files/inputs/' Subroutines public  subroutine test_10 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Test some of the lesser-used features of the library","tags":"","loc":"module/jf_test_10_mod.html","title":"jf_test_10_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the 11th unit test to test unicode support if enabled. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: ascii_equivalent = 'hello-world-ascii.json' Subroutines public  subroutine test_11 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file and extract some data from it.","tags":"","loc":"module/jf_test_11_mod.html","title":"jf_test_11_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the 12th unit test. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' Path to write JSON file to character(len=*), public, parameter :: file = 'test12.json' Filename to write real(kind=wp), public, parameter :: TOL = 100*epsilon(1.0_wp) Tolerance for real comparisons Subroutines public  subroutine test_12 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller","tags":"","loc":"module/jf_test_12_mod.html","title":"jf_test_12_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the 13th unit test. Subroutines public  subroutine test_13 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests different real format strings using repeated calls to json_initialize .","tags":"","loc":"module/jf_test_13_mod.html","title":"jf_test_13_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the 14th unit test. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename1 = 'test1.json' the file to read integer, public :: icount = 0 a count of the number of \"name\" variables found Subroutines public  subroutine test_14 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt report number of errors to caller Description Tests the traversal of a JSON structure public  subroutine rename (p, finished) Arguments Type Intent Optional Attributes Name type( json_value ), intent(in), pointer :: p logical, intent(out) :: finished Description change all \"name\" variable values to \"Fred\"","tags":"","loc":"module/jf_test_14_mod.html","title":"jf_test_14_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the second unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' working directory character(len=*), public, parameter :: filename2 = 'test2.json' Subroutines public  subroutine test_2 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure and write it to a file. public  subroutine add_variables_to_input (me, variable, units, frame, center, rdata, error_cnt) Arguments Type Intent Optional Attributes Name type( json_value ), intent(inout), pointer :: me character(len=*), intent(in) :: variable character(len=*), intent(in) :: units character(len=*), intent(in) :: frame character(len=*), intent(in) :: center real(kind=wp), intent(in), dimension(:) :: rdata integer, intent(inout) :: error_cnt","tags":"","loc":"module/jf_test_2_mod.html","title":"jf_test_2_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the third unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' character(len=*), public, parameter :: filename2 = 'test2.json' Subroutines public  subroutine test_3 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Read the file generated in test_2 , and extract some data from it.","tags":"","loc":"module/jf_test_3_mod.html","title":"jf_test_3_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the forth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/' working directory character(len=*), public, parameter :: filename4 = 'test4.json' Subroutines public  subroutine test_4 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Populate a JSON structure, write it to a file,\n then read it.","tags":"","loc":"module/jf_test_4_mod.html","title":"jf_test_4_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the fifth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory character(len=*), public, parameter :: filename5 = 'test5.json' Subroutines public  subroutine test_5 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Github issue example: https://github.com/josephalevin/fson/issues/12","tags":"","loc":"module/jf_test_5_mod.html","title":"jf_test_5_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the sixth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: dir = '../files/inputs/' working directory Subroutines public  subroutine test_6 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description This example tries to read an invalid JSON file.","tags":"","loc":"module/jf_test_6_mod.html","title":"jf_test_6_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the seventh unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Subroutines public  subroutine test_7 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Indent test","tags":"","loc":"module/jf_test_7_mod.html","title":"jf_test_7_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the eighth unit test. HISTORY Izaak Beekman : 2/18/2015 : Created (refactoried original json_example.f90 file) Subroutines public  subroutine test_8 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description read a JSON structure from a string","tags":"","loc":"module/jf_test_8_mod.html","title":"jf_test_8_mod â€“ JSON-Fortran"},{"text":"Uses: json_module Module for the ninth unit test. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: filename = 'big.json' character(len=*), public, parameter :: dir = '../files/inputs/' Subroutines public  subroutine test_9 (error_cnt) Arguments Type Intent Optional Attributes Name integer, intent(out) :: error_cnt Description Open a random JSON file generated by http://www.json-generator.com public  subroutine read_file (filename, str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: str Description Reads the contents of the file into the allocatable string str.\n If there are any problems, str will be returned unallocated.","tags":"","loc":"module/jf_test_9_mod.html","title":"jf_test_9_mod â€“ JSON-Fortran"},{"text":"First unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_1 !! First unit test. use jf_test_1_mod , only : test_1 implicit none integer :: n_errors n_errors = 0 call test_1 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_1","tags":"","loc":"program/jf_test_1.html","title":"jf_test_1 â€“ JSON-Fortran"},{"text":"Tenth unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_10 !! Tenth unit test. use jf_test_10_mod , only : test_10 implicit none integer :: n_errors n_errors = 0 call test_10 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_10","tags":"","loc":"program/jf_test_10.html","title":"jf_test_10 â€“ JSON-Fortran"},{"text":"11th unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_11 !! 11th unit test. use jf_test_11_mod , only : test_11 implicit none integer :: n_errors n_errors = 0 call test_11 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_11","tags":"","loc":"program/jf_test_11.html","title":"jf_test_11 â€“ JSON-Fortran"},{"text":"Uses: jf_test_12_mod 12th unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_12 !! 12th unit test. use jf_test_12_mod , only : test_12 implicit none integer :: n_errors n_errors = 0 call test_12 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_12","tags":"","loc":"program/jf_test_12.html","title":"jf_test_12 â€“ JSON-Fortran"},{"text":"Uses: jf_test_13_mod 13th unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_13 !! 13th unit test. use jf_test_13_mod , only : test_13 implicit none integer :: n_errors call test_13 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_13","tags":"","loc":"program/jf_test_13.html","title":"jf_test_13 â€“ JSON-Fortran"},{"text":"Uses: jf_test_14_mod 14th unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_14 !! 14th unit test. use jf_test_14_mod , only : test_14 implicit none integer :: n_errors call test_14 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_14","tags":"","loc":"program/jf_test_14.html","title":"jf_test_14 â€“ JSON-Fortran"},{"text":"Second unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_2 !! Second unit test. use jf_test_2_mod , only : test_2 implicit none integer :: n_errors n_errors = 0 call test_2 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_2","tags":"","loc":"program/jf_test_2.html","title":"jf_test_2 â€“ JSON-Fortran"},{"text":"Third unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_3 !! Third unit test. use jf_test_3_mod , only : test_3 implicit none integer :: n_errors n_errors = 0 call test_3 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_3","tags":"","loc":"program/jf_test_3.html","title":"jf_test_3 â€“ JSON-Fortran"},{"text":"Fourth unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_4 !! Fourth unit test. use jf_test_4_mod , only : test_4 implicit none integer :: n_errors n_errors = 0 call test_4 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_4","tags":"","loc":"program/jf_test_4.html","title":"jf_test_4 â€“ JSON-Fortran"},{"text":"Fifth unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_5 !! Fifth unit test. use jf_test_5_mod , only : test_5 implicit none integer :: n_errors n_errors = 0 call test_5 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_5","tags":"","loc":"program/jf_test_5.html","title":"jf_test_5 â€“ JSON-Fortran"},{"text":"Sixth unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_6 !! Sixth unit test. use jf_test_6_mod , only : test_6 implicit none integer :: n_errors n_errors = 0 call test_6 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_6","tags":"","loc":"program/jf_test_6.html","title":"jf_test_6 â€“ JSON-Fortran"},{"text":"Seventh unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_7 !! Seventh unit test. use jf_test_7_mod , only : test_7 implicit none integer :: n_errors n_errors = 0 call test_7 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_7","tags":"","loc":"program/jf_test_7.html","title":"jf_test_7 â€“ JSON-Fortran"},{"text":"Eighth unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_8 !! Eighth unit test. use jf_test_8_mod , only : test_8 implicit none integer :: n_errors n_errors = 0 call test_8 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_8","tags":"","loc":"program/jf_test_8.html","title":"jf_test_8 â€“ JSON-Fortran"},{"text":"Ninth unit test. Variables Type Attributes Name Initial integer :: n_errors Source Code program jf_test_9 !! Ninth unit test. use jf_test_9_mod , only : test_9 implicit none integer :: n_errors n_errors = 0 call test_9 ( n_errors ) if ( n_errors /= 0 ) stop 1 end program jf_test_9","tags":"","loc":"program/jf_test_9.html","title":"jf_test_9 â€“ JSON-Fortran"},{"text":"This program is run when configuring the json-fortran build,\n to determine whether or not ISO 10646/UCS4 characters are\n supported by the compiler. Variables Type Attributes Name Initial integer, parameter :: UCS4_K = selected_char_kind(\"0\") Source Code program test_iso_10646_support use iso_fortran_env , only : output_unit , error_unit implicit none integer , parameter :: UCS4_K = selected_char_kind ( 'ISO_10646' ) if ( UCS4_K == - 1 ) then !Not supported! write ( error_unit , '(A)' ) 'Your compiler does not support ISO 10646/UCS4 characters!' write ( error_unit , '(A)' ) 'JSON-Fortran must/will be configured to use the \"DEFAULT\"' write ( error_unit , '(A)' ) 'character set. (Should be \"ASCII\" on a reasonable system.)' stop 2 else write ( error_unit , '(A)' ) 'Congratulations! Your compiler supports ISO 10646/UCS4!' write ( error_unit , '(A)' ) 'JSON-Fortran may be configured to enable UCS4 support.' write ( output_unit , '(A)' ) 'UCS4_SUPPORTED' end if end program test_iso_10646_support","tags":"","loc":"program/test_iso_10646_support.html","title":"test_iso_10646_support â€“ JSON-Fortran"}]}