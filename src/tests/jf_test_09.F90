!*****************************************************************************************
!> author: Jacob Williams
!  date: 3/2/2015
!
! Module for the ninth unit test.

module jf_test_9_mod

    use json_module, CK => json_CK
    use, intrinsic :: iso_fortran_env , only: error_unit, output_unit

    implicit none

    private
    public :: test_9

    !small file - 0.0 sec : http://www.json-generator.com
    !character(len=*),parameter :: filename = 'random1.json'

    !7 MB - 5.4 sec : http://www.json-generator.com
    character(len=*),parameter :: filename = 'big.json'

    !13 MB - 7.6 sec : http://mtgjson.com
    !character(len=*),parameter :: filename = 'AllSets.json'

    !100 MB - 3 sec : https://github.com/seductiveapps/largeJSON
    !character(len=*),parameter :: filename = '100mb.json'

    !small file that contains unicode characters:
    !character(len=*),parameter :: filename = 'hello-world-ucs4.json'  !!!! test !!!!

    ! file generated by `python generate_json.py -o deep.json -d 20 -b 10 -a 0.7`
    ! character(len=*),parameter :: filename = 'deep.json'

    character(len=*),parameter :: dir = 'files/inputs/' !working directory

contains

    subroutine test_9(error_cnt)

    !! Open a random JSON file generated by http://www.json-generator.com
    !! and compare the results from recursive and non-recursive parsers

    implicit none

    integer,intent(out) :: error_cnt

    type(json_file) :: f, f1, f2
    type(json_core) :: json
    real :: tstart, tend
    character(kind=CK, len=:),allocatable :: str, json_str
    integer :: i !! counter
    logical :: are_equal
    type(json_value),pointer :: p1, p2

    error_cnt = 0

    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '================================='
    write(error_unit,'(A)') '   EXAMPLE 9a '
    write(error_unit,'(A)') '================================='

    ! Load file with recursive parser
    call f1%initialize( parser_mode = 1 )
    str = 'recursive parser'

    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '  Load a file using json_file%load ['//trim(str)//']'
    write(error_unit,'(A)') ''
    write(error_unit,'(A)') 'Loading file: '//trim(filename)

    call cpu_time(tstart)
    call f1%load(dir//filename)
    call cpu_time(tend)
    write(error_unit,'(A,1X,F10.3,1X,A)') 'Elapsed time: ',tend-tstart,' sec'

    if (f1%failed()) then
        call f1%print_error_message(error_unit)
        error_cnt = error_cnt + 1
    else
        write(error_unit,'(A)') 'File successfully read'
    end if
    write(error_unit,'(A)') ''

    ! Load file with non-recursive parser
    call f2%initialize( parser_mode = 2 )
    str = 'non-recursive parser'

    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '  Load a file using json_file%load ['//trim(str)//']'
    write(error_unit,'(A)') ''
    write(error_unit,'(A)') 'Loading file: '//trim(filename)

    call cpu_time(tstart)
    call f2%load(dir//filename)
    call cpu_time(tend)
    write(error_unit,'(A,1X,F10.3,1X,A)') 'Elapsed time: ',tend-tstart,' sec'

    if (f2%failed()) then
        call f2%print_error_message(error_unit)
        error_cnt = error_cnt + 1
    else
        write(error_unit,'(A)') 'File successfully read'
    end if
    write(error_unit,'(A)') ''

    ! Compare the two parsed structures
    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '  Comparing recursive vs non-recursive parser results...'

    call f1%get(p1)
    call f2%get(p2)
    are_equal = json%equals(p1, p2)
    if (are_equal) then
        write(error_unit,'(A)') '  SUCCESS: Both parsers produced identical results!'
    else
        write(error_unit,'(A)') '  ERROR: Parsers produced different results!'
        error_cnt = error_cnt + 1
    end if
    write(error_unit,'(A)') ''

    !time serialize to string:
    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '  Serializing JSON to string...'
    call cpu_time(tstart)
    call json%print_to_string(p1, json_str)
    call cpu_time(tend)
    write(error_unit,'(A,1X,F10.3,1X,A)') 'Elapsed time: ',tend-tstart,' sec'
    !now, reparse the string to make sure we get the same structure back:
    call json%deserialize(p2, json_str)
    are_equal = json%equals(p1, p2, verbose = .true.)
    if (are_equal) then
        write(error_unit,'(A)') '  SUCCESS: serialized and deserialized structures are identical!'
    else
        write(error_unit,'(A)') '  ERROR: serialized and deserialized structures are different!'
        error_cnt = error_cnt + 1
    end if
    write(error_unit,'(A)') ''

    !cleanup:
    call f1%destroy()
    call f2%destroy()
    deallocate(str)
    deallocate(json_str)

    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '================================='
    write(error_unit,'(A)') '   EXAMPLE 9b '
    write(error_unit,'(A)') '================================='

    write(error_unit,'(A)') ''
    write(error_unit,'(A)') '  Load a file using json_file%deserialize'
    write(error_unit,'(A)') ''
    write(error_unit,'(A)') 'Loading file: '//trim(filename)

    call cpu_time(tstart)
    call read_file(dir//filename, str)

    if (allocated(str)) then
        call f%deserialize(str)
        call cpu_time(tend)
        write(error_unit,'(A,1X,F10.3,1X,A)') 'Elapsed time to parse: ',tend-tstart,' sec'
        if (f%failed()) then
            call f%print_error_message(error_unit)
            error_cnt = error_cnt + 1
        else
            write(error_unit,'(A)') 'File successfully read'
        end if
        write(error_unit,'(A)') ''
        !write(error_unit,'(A)') str   !!!! test !!!!
        !write(error_unit,'(A)') ''    !!!! test !!!!
    else
        write(error_unit,'(A)') 'Error loading file'
    end if

    !cleanup:
    call f%destroy()

    end subroutine test_9

    subroutine read_file(filename,str)

    !! Reads the contents of the file into the allocatable string str.
    !! If there are any problems, str will be returned unallocated.
    !!
    !!@warning Will this routine work if the file contains unicode characters??

    implicit none

    character(len=*),intent(in) :: filename
    character(len=:),allocatable,intent(out) :: str

    integer :: iunit,istat,filesize

    open( newunit = iunit,&
          file    = filename,&
          status  = 'OLD',&
          form    = 'UNFORMATTED',&
          access  = 'STREAM',&
          iostat  = istat )

    if (istat==0) then
        inquire(file=filename, size=filesize)
        if (filesize>0) then
            allocate( character(len=filesize) :: str )
            read(iunit,pos=1,iostat=istat) str
            if (istat/=0) deallocate(str)
            close(iunit, iostat=istat)
        end if
    end if

    end subroutine read_file

end module jf_test_9_mod
!*****************************************************************************************
#ifndef INTEGRATED_TESTS
!*****************************************************************************************
program jf_test_9

    !! Ninth unit test.

    use jf_test_9_mod , only: test_9
    implicit none
    integer :: n_errors
    call test_9(n_errors)
    if (n_errors /= 0) stop 1

end program jf_test_9
!*****************************************************************************************
#endif
